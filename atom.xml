<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>十三的个人博客</title>
  
  <subtitle>我不在彩虹，彩虹在我.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Binshao.site/"/>
  <updated>2019-03-29T02:16:32.520Z</updated>
  <id>http://Binshao.site/</id>
  
  <author>
    <name>十三</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搞懂 Java 内部类</title>
    <link href="http://Binshao.site/2019/03/28/InnerClass/"/>
    <id>http://Binshao.site/2019/03/28/InnerClass/</id>
    <published>2019-03-28T05:01:18.000Z</published>
    <updated>2019-03-29T02:16:32.520Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;还记得在刚学习内部类时，经常对外部类以及各种内部类傻傻分不清楚，等到后来知道是怎么一回事后，又随着时间的流逝，再要说出个大概却是什么都回顾不起来了，因此本文就对内部类做个回顾，也为方便日后能够快速复习做个笔记。</p><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0071oueply1g1jfj5pogzj30j60csdi3.jpg" alt=""><br><br><br>&emsp;&emsp;关于内部类的定义就是<code>可以将一个类的定义放在另一个类的定义内部</code>，内部类是一种非常有用的特性，它允许我们把一些逻辑相关的类组织在一起，并且可以控制位于内部的类的可视性。对于上面提到的各种内部类，我们可以大概分为下面张图片的分类：</div></p><p><img src="https://ws1.sinaimg.cn/large/0071oueply1g1jfco5clqj30xw0eumyn.jpg" alt="内部类"></p><p><br></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>&emsp;&emsp;从上图中可以看到，内部类分成静态内部类和非静态内部类，而非静态内部类又可以分为局部内部类和匿名内部类，同时我们把包裹内部类的类称之为外部类，就如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非静态内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;外部类可以使用 public 或者默认包权限来修饰，而内部类则可以使用 private、protected、public 以及包权限进行修饰。使用内部类和我们平时使用普通类并没什么不同，<code>此外当生成内部类对象的时候，内部类持有当前外部类的引用，通过这个引用它可以访问外部类所有的成员变量，包括私有变量</code>，也就是说实际上内部类和它所在的外部类实例对象是相关联的，它不能脱离外部类实例而独自存在，那么我们可能会好奇，它是怎么样和外部类进行相关联的呢？其实是编译器在生成 Java 字节码的时候通过给非静态内部类添加构造方法，使其在进行实例化时得到外部类的引用。</p><p>&emsp;&emsp;既然构建内部类时需要持有外部类对象的引用，那么要想创建内部类对象就要使用外部类的对象来创建该内部类对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        OuterClass.Inner in = out.new Inner();</span><br><span class="line">        <span class="comment">// 也可以使用这种方式进行创建</span></span><br><span class="line">        Inner oin = out.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>&emsp;&emsp;当我们不想内部类对象与其外部类对象之间有联系的时候，我们可以将内部类声明为 static，这样它变成了静态内部类，既然没有和外部类对象有任何相关联，所以它也不需要再依赖与外部类对象，这样它也不能访问外部类的非静态成员，只能够访问外部类的静态成员，此外静态内部类和非静态内部类在创建时也稍有区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OuterClass 为外部类，类含有静态内部类 S 以及非静态内部类 I</span></span><br><span class="line">OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line"><span class="comment">// 创建静态内部类</span></span><br><span class="line">out.S staticClass = out.S();</span><br><span class="line"><span class="comment">// 创建非静态内部类</span></span><br><span class="line">out.I in = out.new I();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里对静态内部类和非静态内部类做个总结：</p><ol><li>静态内部类可以有静态成员，而非静态内部类则不能有静态成员；</li><li>静态内部类可以访问外部类的静态变量，而不可访问外部类的非静态变量；</li><li>非静态内部类的非静态成员可以访问外部类的非静态变量；</li><li>静态内部类的创建不依赖于外部类，而非静态内部类必须依赖于外部类的创建而创建；</li></ol><p><br></p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>&emsp;&emsp;如果一个内部类只在一个方法中使用，那么我们就可以将这个类定义在方法内部，这种内部类被称为局部内部类，其作用域也仅限于该方法区内，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类方法"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFunctionClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionClass</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是局部内部类"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        FunctionClass FunctionClass = <span class="keyword">new</span> FunctionClass();</span><br><span class="line">FunctionClass.show();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line">out.show();</span><br><span class="line">out.showFunctionClass();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">//外部类方法</span></span><br><span class="line"><span class="comment">//我是局部内部类</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此外，局部内部类注意事项如下：</p><ol><li>局部内部类对外是隐藏的，只能通过创建这个类的方法中进行访问；</li><li>局部内部类不允许使用访问权限修饰符；</li></ol><p><br></p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>&emsp;&emsp;匿名内部类是没有类名的局部类，匿名内部类使得类的定义和实例化同时进行，所以通常用来进行简化代码编写，而由于它没有类名也就不存在构造方法，下面通过两个小实验来学习匿名内部类的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"eat..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Child child = <span class="keyword">new</span> Child();</span><br><span class="line">child.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是没有使用匿名内部类的普通写法，先实现接口再重写其中的方法，最后再实例化对象并调用方法，前面我们说到匿名内部类可以简化代码，那接下来看同样的例子用匿名内部类怎么来写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span>  </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Person() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"eat..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样引入匿名内部类直接就将接口中的方法进行重写，就省略了一个类的编写，<code>所以只要是一个类是抽象类或者是一个接口，那么其子类方法或接口方法都可以使用匿名内部类来实现</code>，匿名内部类常用的典型场景是使用 Thread 类或者 Runnable 接口来实现多线程。此外，还需要注意的是，匿名内部类如果使用一个在其外部定义的对象时，编译器会要求该变量必须是 final，原因便是要保持参数的一致性。</p><p><br></p><h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>&emsp;&emsp;到这里，我们大概搞清楚内部类的相关知识点，其中在《Thinking in Java》一书中作者说到内部类最吸引人的原因是：</p><blockquote><p>每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p></blockquote><p>&emsp;&emsp;看到这儿，我想说的是大师就是大师，说的我都一脸懵逼了（太菜了），总结了下还是有下面几点：</p><ul><li>内部类方法可以访问该类定义所在作用域中的数据，包括被 private 修饰的私有数据；</li><li>内部类可以对同一包中的其他类隐藏起来；</li><li>内部类可以解决 Java 单继承的缺陷；</li><li>对于一些有大量冗余代码的回调函数可以通过匿名内部类来实现；<br><br><br><br></li></ul><hr><p>参考文献：<br>《Thinking in Java》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;还记得在刚学习内部类时，经常对外部类以及各种内部类傻傻分不清楚，等到后来知道是怎么一回事后，又随着时间的流逝，再要说出个大概却是什么都回顾不起来了，因此本文就对内部类做个回顾，也为方便日后能够快速复习做个笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://Binshao.site/categories/Java/"/>
    
    
      <category term="内部类 Java" scheme="http://Binshao.site/tags/%E5%86%85%E9%83%A8%E7%B1%BB-Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 跨进程通信机制</title>
    <link href="http://Binshao.site/2019/02/01/IPC/"/>
    <id>http://Binshao.site/2019/02/01/IPC/</id>
    <published>2019-02-01T06:18:45.000Z</published>
    <updated>2019-02-02T08:49:48.605Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，最近有在追美剧《海豹突击队 第二季》的小朋友吗，举个爪！</p></blockquote><p>&emsp;&emsp;最近又把艺术探索这本书翻了一遍，还记得第一次翻阅此书的时候感觉有些内容可真是难懂阿，现在回想起来自己那时候就是个小菜鸟，同时也很佩服感叹刚哥可真是好牛逼。都说笨鸟先飞，学习还是不能落下的。本篇学习笔记就记录下 Android 中的 IPC 机制学习过程，同时也是艺术探索的读书笔记。</p><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzqwc4lehhj30p00e2431.jpg" alt=""><br><br></div></p><h2 id="IPC-简介"><a href="#IPC-简介" class="headerlink" title="IPC 简介"></a>IPC 简介</h2><p>&emsp;&emsp;IPC 它的完整全称是 Inter-Process Communication，意思是跨进程通信，也就是两个进程间进行数据交换的过程。说起跨进程通信，就会对 Binder 一定不会感到陌生，从框架层角度来说，Binder 是 ServiceManager 连接各种 Manager 和 ManagerService 的桥梁，所以后续我们想要深入地阅读相关源码，我们就要对多进程有一定的了解。此外，为了保护进程空间不被其他进程干扰破坏，Linux 中的进程都是相互独立的，也就是进程隔离，所以进程之间是不能直接访问或操作另外一个线程，为了能够进行通信协作，就需要使用跨进程通信的技术。</p><p>&emsp;&emsp;在学习 IPC 之前，首先我们得要搞明白两个概念，什么是进程和什么是线程，进程和线程是截然不同的概念，这里就不做多介绍了。那么可能我们会有疑问，跨进程通信究竟是用来解决什么问题的呢？我们知道 Android 中每个应用中数据是不共享的，当前应用需要使用其他应用的数据，就要通过跨进程的方式去获取数据，比如四大金刚中的 ContentProvider 也是一种进程间通信。那么接下来我们看看多进程在 Android 中的使用。<br><br></p><h2 id="Android-中的多进程"><a href="#Android-中的多进程" class="headerlink" title="Android 中的多进程"></a>Android 中的多进程</h2><p>&emsp;&emsp;在 Android 中开启多进程的方式很简单，只需要在 AndroidManifest 权限文件中指定 android:process 属性即可，具体详情如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.example.ipcdemo"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:process</span>=<span class="string">":remote"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的代码中，我们为 SecondActivity 指定了 process 属性，这样当前应用就增加了一个新进程，接下来运行起来看看，这里通过 shell 命令来查看当前包名存在的进程信息，如下图：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fznhs59rkpj30pb043q3b.jpg" alt="进程信息"></div></p><p>&emsp;&emsp;我们可以看到当前只有一个包名为 com.example.ipcdemo 的进程，也就是 MainActivity  所运行在的默认进程，那么我们的另外手动创建的新进程呢？那是因为我们的 SecondActivity 还没有被启动，所以我们给它来个 Intent 跳转页面，让系统给它创建一个单独的进程，接着我们再来查看进程信息：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzni1wlh0xj30pc02xq39.jpg" alt="进程信息"></div></p><p>&emsp;&emsp;如上图中，可以看到我们已经开启了多进程，似乎很简单的说，下面我们再来看看多进程中一些注意事项。<br><br></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>&emsp;&emsp;前面我们开启了多线程了，那么这里我们做个小实验，首先新建个类并且类中添加个静态变量，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> numID = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们要做的是，在 MainActivity 中把这个 numID 重新赋值为 2 并且通过 Log 打印出当前变量值，然后在 SecondActivity 中也来打印一下 numID 的变量值，下面来看看它们的打印记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01-26 21:32:25.176 22193-22193/? I/MainActivity: NumManager.numID = 2</span><br><span class="line">01-26 21:33:21.956 22280-22280/? I/SecondActivity: onCreate</span><br><span class="line">01-26 21:33:21.956 22280-22280/? I/SecondActivity: NumManager.numID = 1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上面的打印日志看到，即使我们已经把变量值重新进行赋值，然而结果却不是我们认为的那样子，<code>也就是说即使两个进程中都存在这个 NumManager 这个类，但是它们之间是不会互相影响的，</code>这也就是我们之前即使手动赋值也没有得到同样变量值的原因，除此之外，使用多进程需要注意以下问题：</p><ol><li>静态成员和单例模式完全失效；</li><li>线程同步机制完全失效；</li><li>SharePreferences 的可靠性下降；</li><li>Application 会多次创建；</li></ol><p>&emsp;&emsp;上面我们说到多线程带来的问题，为了解决这些问题，Android 系统也给我们提供了很多的跨进程通信的方法，下面将会逐一来介绍它们。<br><br></p><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>&emsp;&emsp;我们使用 Binder 跨进程通信传输数据时需要使用 Serializable 或 Parcelable，这里对它们做个简单的介绍，<code>Serializable</code> 是 Java 提供的序列化接口，可以声明一个serialVersionUID 但并不是必需的，但是如果不声明会对反序列化过程产生影响。序列化后的数据中的 serialVersionUID 只有和当前类的 serialVersionUID 相同时，才能被正常地反序列化。</p><p>&emsp;&emsp;<code>Parcelable</code> 则是 Android 提供的序列化接口，相比于 Serializable 它使用过程稍显繁琐，但其性能更优于 Serializable，因此 Parcelable 主要也用于内存序列化操作上，实现方式就是类实现 Parcelable 接口，并实现 createFromParcel 和 writeToParcel 等方法。</p><p>&emsp;&emsp;值得要注意的是，我们通过上面提供的接口去序列化相关的对象，最后再执行相关的反序列化操作，产生的都会是新的对象，它们可不是同一个对象，这一点我们可是要清楚地知道。具体关于 Serializable 和 Parcelable 的详细讲解这里就不再展开叙述了。<br><br></p><h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>&emsp;&emsp;Binder 中文译为粘合剂，即是把两个不同的进程粘合在一起，可以想象为河岸两边有座桥，使得可以互相来往，同时个人认为 Binder 在不同的场景下定义也不同，这一点在艺术探索也可以看到，书中是这样描述的：</p><blockquote><p>直观来说，Binder 是 Android 中的一个类，实现了 IBinder 接口。从 IPC 角度来说，Binder 是 Android 中的一种跨进程的通信方式，也可以理解为一种虚拟的物理设备；从 Android Framework 角度来说，Binder 是 ServiceManager 连接各种 Manager 和相应 ManagerService 的桥梁；从 Android 应用层来说，Binder 是客户端和服务端进行通信的媒介。</p></blockquote><p>&emsp;&emsp;在 Android 开发中，系统主要提供以下的跨进程通信方式：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fznp2qyceuj30va0cg0t1.jpg" alt="跨进程通信"></div></p><p>&emsp;&emsp;上图主要列出了主要的 IPC 方式，而一些如 Bundle 或 Intent 等就没有再列出来，但是不代表我们就不用知道和了解。这里我们首先学习 AIDL 并以此去了解 Binder 的工作机制。首先新建一个类 Book 并让它实现 Parcelable 接口，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String bookName;</span><br><span class="line">    <span class="keyword">public</span> String bookDescribe;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String bookName, String bookDescribe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">        <span class="keyword">this</span>.bookDescribe = bookDescribe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        bookName = in.readString();</span><br><span class="line">        bookDescribe = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(bookName);</span><br><span class="line">        dest.writeString(bookDescribe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;都是些实现 Parcelable 接口的基本操作，我们接着在 Java 同级目录下新建一个 IBookManager.aidl 文件，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.ipcdemo;</span><br><span class="line"><span class="keyword">import</span> com.example.ipcdemo.Book;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;它是我们定义的一个接口，并且里面有两个方法。我们看到第二个方法 addBook() 的方法参数中有 in，in 表示的是输入型参数；除此之外，还有 out 和 inout，它们分别表示输出型参数和输入输出型参数。此外，在 AIDL 文件中只支持以下数据类型：</p><ul><li>基本数据类型（int、long、char、boolean、double 等）；</li><li>String 和 CharSequence；</li><li>List ：只支持 ArrayList；</li><li>Map ：只支持 HashMap；</li><li>Parcelable ：所有实现了 Parcelable 接口的对象；</li><li>AIDL ：所有的 AIDL 接口本身也可以在 AIDL 文件中使用；</li></ul><p>&emsp;&emsp;这里还有一个值得注意的是，我们自定义的 Parcelable 对象需要把它手动地 import 进来，从上面代码的第 三 行处我们也可以看到。另外如果在 AIDL 文件中使用了自定义 Parcelable 对象，还必须要创建一个与它同名的 AIDL 文件并声明为 Parcelable 类型，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Book.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.ipcdemo;</span><br><span class="line"></span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;完成上面的工作后，这个时候需要重新编译项目，工程就会自动生成对应的接口文件，下面来看看它的具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 Binder 中传输的接口都要继承自 IInterface 接口.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment">     * 当户端和服务端在同一个进程时不会走 onTransact 过程，当客户端和服务端不在同一个进程时， </span></span><br><span class="line"><span class="comment">     * 会走 onTransact过程，并且逻辑有内部类 Proxy 完成.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">ipcdemo</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Binder 的唯一标识，通常都是用当前类名表示.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.example.ipcdemo.IBookManager"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct the stub at attach it to the interface.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an com.example.ipcdemo.IBookManager interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         * 用于将服务端的 Binder 对象，转换成客户端所需的 IInterface 接口对象. </span></span><br><span class="line"><span class="comment">         * 这个过程是区分进程的：如果客户端和服务端在同一个进程，此方法返回服务端的 Stub 对象本身；</span></span><br><span class="line"><span class="comment">         * 否则就返回 Stub 的内部类 Proxy 对象.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.example.ipcdemo.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.ipcdemo.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.example.ipcdemo.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.example.ipcdemo.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前的 Binder 对象.</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  此方法运行在服务端的 Binder 线程池中，当客户端发起跨进程请求时，远程请</span></span><br><span class="line"><span class="comment">         * 求会通过系统底层封装之后，交给该方法执行.</span></span><br><span class="line"><span class="comment">         *  它会服务端根据 code 参数确定应该执行的目标方法，接着从 data 中取出目标  </span></span><br><span class="line"><span class="comment">         * 方法需要的参数(如果目标参数需要传入参数)，目标方法执行完成后，将结果写          </span></span><br><span class="line"><span class="comment">         * 入 reply 中(如果目标方法有返回值).</span></span><br><span class="line"><span class="comment">         *  如果该方法返回 false，代表客户端请求失败。所以可以在这里面加自己的业</span></span><br><span class="line"><span class="comment">         * 务，比如权限验证，当不通过时直接返回 false.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    java.util.List&lt;com.example.ipcdemo.Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    com.example.ipcdemo.Book _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.example.ipcdemo.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">ipcdemo</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 此方法运行在客户端，当客户端远程调用此方法时，先创建输入和输出 Parcel _data 和 _reply.</span></span><br><span class="line"><span class="comment">             * 然后调用 transact发起 RPC 远程调用，同时线程挂起；</span></span><br><span class="line"><span class="comment">             * 此时服务端的 onTransact 被调用，直到 RPC 结果返回，客户端线程继续运行，并从 _reply</span></span><br><span class="line"><span class="comment">             * 中取出RPC的返回结果，最后返回结果</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;com.example.ipcdemo.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.example.ipcdemo.Book&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.example.ipcdemo.Book.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此方法同上面，只是多了将参数写入到 _data ，由于该方法没有返回值，所以不会从 _reply 中取结果</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.example.ipcdemo.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明了两个整型的 id 用于标识声明的两个方法.</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们在 IBookManager.aidl 文件中声明的方法.</span></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.example.ipcdemo.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.example.ipcdemo.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面我们把 AIDL 文件转换成了一个 Java 类文件，当然我们也可以自己手动来编写。继续来看生成这个类文件都做了什么：</p><ol><li><p>首先它是一个 interface 接口，它包含了我们前面在 AIDL 文件中声明的两个方法函数，并且还发现它继承自 IInterface 接口，而继承 IInterface 接口还需要提供 asBinder() 方法.</p></li><li><p>包含了一个抽象类 Stub，它继承自 Binder 类并且还实现 IBookManager 接口，这个类定义为抽象类的原因是具体相关的服务方法需要由我们去实现。此外在这个类中定义了一些 int 整形常量，这些常量与服务方法函数是对应的，并且是作为 onTransact() 方法中的第一个参数值 Code，此外还有 asInterface() 这个方法，除了其他进程想要使用服务端提供的服务，服务进程内的其他类也可以使用，显然对于其他进程而言，它们不需要跨进程而可以直接获得服务，为了判断 Binder 对象是否是本地引用，Binder 中提供了个方法 queryLocalInterface() 函数。</p></li><li><p>最后还定义了个 Proxy 类，这个类是作为客户端程序访问服务端的代理，当从远程获取服务端的 Binder 对象就会返回 Binder 驱动中的 Binder 对象。</p></li></ol><p>&emsp;&emsp;到这里我们对 Binder 的工作流程算是有一个大致的认识，这里值得注意的是，当客户端发起远程请求时当前线程会被挂起，一直等到服务端进程返回数据，假若远程方法是个耗时方法，那么为了避免 ANR 我们就不能在 UI 线程中去发起远程请求。还有就是服务端的 Binder 方法是运行在 Binder 的线程池中，当多个客户端同时发起请求连接时，就会存在多个线程同时访问的情况，这时候应该采用同步的方式来处理线程同步的问题。文不如图，下面来一张 Binder 的工作机制图，图片来自于艺术探索：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fznuw2353oj30nu0bagm0.jpg" alt="Binder 的工作机制"><br><br></div></p><h2 id="跨进程通信"><a href="#跨进程通信" class="headerlink" title="跨进程通信"></a>跨进程通信</h2><p>&emsp;&emsp;在理解 Binder 的工作流程之后，接下来将继续学习系统提供的 IPC 方法，主要有 AIDL、Messenger、ContentProvider、Socket，下面我们将会逐个地进行学习。<br><br></p><h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>&emsp;&emsp;在上面学习 Binder 的时候，AIDL 接口文件我们已经是创建好了，这里就不再重复赘述，忘记的同学可以再滑到前面看看。使用 AIDL 进行进程间通信，分为客户端和服务端，首先我们先来看服务端的实现，前面定义了 AIDL 接口，这里我们就要实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIDLService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mBookList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mBookList.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="string">"艺术探索"</span>, <span class="string">"刚哥牛逼!!!"</span>));</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="string">"进阶解密"</span>, <span class="string">"皇叔牛逼!!!"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先创建一个 Service 用来监听客户端的请求连接，在 onCreate() 方法中添加两本书籍信息，然后又创建 Binder 对象实现 AIDL 文件中定义的方法，接着最后在 onBind() 方法中将 Binder 对象返回。这里看到上面代码中第三行处的 CopyOnWriteArrayList，前面我们知道 AIDL 方法是在服务端中的 Binder 线程池中执行的，所以需要处理线程同步的问题，而这个 CopyOnWriteArrayList 支持并发读写，这一点我们是要注意的。</p><p>&emsp;&emsp;服务端的代码编写完后，接下来就到客户端的调用，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, AIDLService.class);</span><br><span class="line">        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mServiceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            IBookManager bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">            Book book = <span class="keyword">new</span> Book(<span class="string">"进阶之光"</span>, <span class="string">"必备好书!!!"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bookManager.addBook(book);</span><br><span class="line">                List&lt;Book&gt; bookList = bookManager.getBookList();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookList.size(); i++) &#123;</span><br><span class="line">                    Book mBook = bookList.get(i);</span><br><span class="line">                    Log.i(TAG, mBook.bookName + <span class="string">"---"</span> + mBook.bookDescribe);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unbindService(mServiceConnection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先在客户端 onCreate() 方法中调用 bindService() 方法去绑定远程服务，绑定完成后将服务端返回的 Binder 对象转换成 AIDL 接口，接下来我们就可以通过这个接口去调用服务端的远程方法。这里我们可能会有疑问，为什么通过调用 bindService() 方法就可以绑定远程服务呢？我们先来看 bindService() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看到这个方法的第二个参数 ServiceConnection，我们跟进去看看，可以发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceConnection</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个 ServiceConnection 它是个接口，其中它的 onServiceConnected() 方法中第二个参数是个 IBinder 类型的，也就是说当我们启动这个 Service 后，因为启动调用的参数含有当前 Service 的 Binder 引用，也就是这样客户端获得了远程服务的 Binder 引用，那么接下来就可以调用远程服务。</p><p>&emsp;&emsp;最后一步就是我们的服务端是运行在另外一个进程里的，所以我们要记得在权限文件开启多线程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.example.ipcdemo"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".AIDLService"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:process</span>=<span class="string">":remote"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在客户端我们又创建新的 Book 对象并调用远程服务端的 addBook() 方法将书添加进去，把程序运行起来看看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01-28 16:02:11.474 21501-21501/com.example.ipcdemo I/MainActivity: 艺术探索---刚哥牛逼!!!</span><br><span class="line">01-28 16:02:11.474 21501-21501/com.example.ipcdemo I/MainActivity: 进阶解密---皇叔牛逼!!!</span><br><span class="line">01-28 16:02:11.474 21501-21501/com.example.ipcdemo I/MainActivity: 进阶之光---必备好书!!!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过 Log 的打印日志可以看到，我们成功地在客户端通过 AIDL 调用远程服务端的方法。到这里我们这个 AIDL 小实验似乎是完成的比较顺利，还记得在前面学习 Binder 的时候，<code>我们说到当客户端和服务端位于同一个进程时，方法调用并不会走跨进程的 onTransact</code>，假若对此比较迷惑，下面我们通过以 Debug 的形式来看看，前面的结论是否准确：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzon5l6u9wj317k095abz.jpg" alt="位于同一进程"></div></p><p>&emsp;&emsp;从上图中可以发现，当它们处于同一个进程的时候，就会调用 queryLocalInterface() 方法返回的对象，那么如果不是位于同一个进程时，看下图：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzonbco9bbj314909agnf.jpg" alt="跨进程"></div></p><p>&emsp;&emsp;可以看到方法就会由 Stub 的内部代理类 Proxy 返回代理对象，并且是会走 onTransact 这个方法。从这里我们也可以验证前面的结论是成立并且准确的，源代码是不会骗人的。这里需要注意的是，跨进程通信时，Binder 驱动并不会给 Client 进程返回真正的它想要调用的 obj 对象，而是返回一个和 obj 一模一样的代理对象，似乎给人感觉 Server 进程直接把 obj 对象传递到 Client 进程，事实上并不是这样的，Client 进程得到的是个代理对象并且也是在代理对象进行的操作，最后 Binder 驱动才让真身完成操作，引用维术大神博客中的总结就是：</p><blockquote><p>Client 进程只不过是持有了 Server 的代理，代理对象协助驱动完成了跨进程通信。</p></blockquote><p>&emsp;&emsp;看到这里我们已经对 AIDL 有了一定的了解，最后我们再学习关于在 AIDL 中使用权限验证的功能，毕竟我们不希望远程服务都可以被任何人连接。添加权限验证主要有两种方法：</p><ul><li>通过定义并使用 permission 进行权限校验；</li><li>通过获取应用的 Uid 和 Pid 进行包名验证；</li></ul><p>&emsp;&emsp;使用 permission 进行验证，首先我们要在 AndroidManifest 文件中添加权限，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 声明所需要的权限</span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.ipcdemo.permission.ACCESS_BOOK_SERVICE"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// 如若绑定远程服务，则要添加此权限以验证通过</span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.example.ipcdemo.permission.ACCESS_BOOK_SERVICE"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们就可以在 Service 的 onBind() 方法中做权限验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> check = checkCallingOrSelfPermission(<span class="string">"com.example.ipcdemo.permission"</span> +</span><br><span class="line">               <span class="string">".ACCESS_BOOK_SERVICE"</span>);</span><br><span class="line">       <span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> mBinder;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果应用试图绑定远程服务时，会去验证当前应用是否含有验证所需的权限，如果没有则当前应用无法绑定服务。下面来看看使用包名来进行验证的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> check = checkCallingOrSelfPermission(<span class="string">"com.example.ipcdemo.permission"</span> +</span><br><span class="line">                    <span class="string">".ACCESS_BOOK_SERVICE"</span>);</span><br><span class="line">            <span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String packageName = <span class="keyword">null</span>;</span><br><span class="line">            String[] packages = getPackageManager().getPackagesForUid(getCallingUid());</span><br><span class="line">            <span class="keyword">if</span> (packages != <span class="keyword">null</span> &amp;&amp; packages.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                packageName = packages[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!packageName.startsWith(<span class="string">"com.example.ipcdemo"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(<span class="string">"MainActivity"</span>, <span class="string">"packageName :"</span> + packageName);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面我们通过 getCallingUid 拿到当前客户端所属应用的 Uid，并通过包名进行校验，当前应用必须是以 com.example.ipcdemo 开头且还要使用定义的自定义权限，只有符合条件才能通过验证。到此我们学习利用 AIDL 来完成跨进程通信，那么接下来我们继续学习其他跨进程通信方法。<br><br></p><h3 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h3><p>&emsp;&emsp;Messenger 可以在不同进程之间传递 Message 对象，从官方文档中我们也可以看到对它的简介：</p><blockquote><p>This allows for the implementation of message-based communication across<br>processes, by creating a Messenger pointing to a Handler in one process,<br>and handing that Messenger to another process.</p><p>可以实现基于消息的进程之间通信的方式.</p></blockquote><p>&emsp;&emsp;有了这个特性，我们可以在 Message 中加入想要传递的数据然后进行数据传递，下面我们就来看看具体它是怎么实现的，首先来写服务端的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MessengerService"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_FROM_CLIENT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_FROM_CLIENT :</span><br><span class="line">                    Log.i(TAG, <span class="string">"收到客户端信息------"</span> + msg.getData().getString(<span class="string">"msg"</span>));</span><br><span class="line">                    <span class="comment">// 接收来自客户端的 Messenger 对象</span></span><br><span class="line">                    Messenger client = msg.replyTo;</span><br><span class="line">                    Message replyMessage = Message.obtain(<span class="keyword">null</span>, MSG_FROM_CLIENT);</span><br><span class="line">                    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">                    bundle.putString(<span class="string">"reply"</span>, <span class="string">"这里是服务端，你的信息已收到，over!"</span>);</span><br><span class="line">                    replyMessage.setData(bundle);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        client.send(replyMessage);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler()).getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样也是先创建 Service 来处理来自客户端的请求连接，接着通过使用 Handler 处理从客户端发送过来的消息，取出发送过来的消息并且进行打印。在 onBind() 方法中创建 Messenger 对象并关联接收消息的 Handler，接着通过调用 getBinder() 来获取 Binder 对象。</p><p>&emsp;&emsp;现在服务端就可以接收客户端的消息，那么往下使得服务端能过回应客户端，通过调用 Message.replyTo 获得客户端传来的 Messenger 对象，这里服务端通过这个 replyTo 参数就可以回应客户端，当然这里 Client 端的代码我们还没写，先这样写着，后面到客户端再贴代码。得到 Messenger 对象后创建 Message 对象并放入想要回应客户端的消息，然后通过 Messenger 讲消息发送给客户端。最后 Service 要记得另开一个新的进程。</p><p>&emsp;&emsp;紧接着来看看客户端这边的逻辑，首先还是通过绑定服务端进程的 Service，然后使用服务端返回的 Binder 对象创建 Messenger 并使用它往服务端发送信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class);</span><br><span class="line">        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mServiceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            Messenger mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            Message msg = Message.obtain(<span class="keyword">null</span>, MessengerService.MSG_FROM_CLIENT);</span><br><span class="line">            Bundle data = <span class="keyword">new</span> Bundle();</span><br><span class="line">            data.putString(<span class="string">"msg"</span>, <span class="string">"这里是客户端，服务端收到请回答!"</span>);</span><br><span class="line">            msg.setData(data);</span><br><span class="line">            <span class="comment">// 将 Messenger 传送给服务端</span></span><br><span class="line">            msg.replyTo = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mService.send(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MessengerService.MSG_FROM_CLIENT :</span><br><span class="line">                    Log.i(TAG, <span class="string">"收到服务端信息------"</span> + msg.getData().getString(<span class="string">"reply"</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unbindService(mServiceConnection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行程序，看看打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">01-30 22:35:07.030 2203-2203/com.example.ipcdemo:remote I/MessengerService: 收到客户端信息------这里是客户端，服务端收到请回答!</span><br><span class="line">01-30 22:35:07.030 2156-2156/com.example.ipcdemo I/MainActivity: 收到服务端信息------这里是服务端，你的信息已收到，over!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Messenger 的使用很简单，实际上 Messenger 的底层实现是 AIDL，至于它的内部实现，鸿神也有博客分析：<a href="https://blog.csdn.net/lmj623565791/article/details/47017485" target="_blank" rel="noopener">Android 基于 Message 的进程间通信 Messenger完全解析</a>.</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzpn0ufyetj30pc0bbq32.jpg" alt="Messenger 工作原理"><br><br></div></p><h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>&emsp;&emsp;ContentProvider 为我们存储和获取数据提供方便的便利，它可以在不同的应用之间共享数据，非常适合进程间通信。下面我们学习使用 ContentProvider 进行进程间通信，首先新建数据库和表，表中有两个字段分别用来记录书籍名字和简介，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_NAME = <span class="string">"book_provider.db"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_TABLE_NAME = <span class="string">"book"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DB_VERSION = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> String CREATE_BOOK_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + BOOK_TABLE_NAME +</span><br><span class="line">            <span class="string">"(_id INTEGER PRIMARY KEY,"</span> + <span class="string">"name TEXT,"</span> + <span class="string">"describe TEXT)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, DB_NAME, <span class="keyword">null</span>, DB_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        db.execSQL(CREATE_BOOK_TABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来使用 ContentProvider 对创建的数据库进行操作，放码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.example.ipcdemo.BookProvider"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase db;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="keyword">private</span> String table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        matcher.addURI(AUTHORITY, <span class="string">"book"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        table = DBOpenHelper.BOOK_TABLE_NAME;</span><br><span class="line">        context = getContext();</span><br><span class="line">        initProvider();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        db = <span class="keyword">new</span> DBOpenHelper(context).getWritableDatabase();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                db.execSQL(<span class="string">"DELETE FROM "</span> + DBOpenHelper.BOOK_TABLE_NAME);</span><br><span class="line">                db.execSQL(<span class="string">"INSERT INTO book VALUES(1, '艺术探索', '刚哥牛逼!!!')"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        String table = DBOpenHelper.BOOK_TABLE_NAME;</span><br><span class="line">        Cursor mCursor = db.query(table, projection, selection, selectionArgs, <span class="keyword">null</span>, sortOrder, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> mCursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">        db.insert(table, <span class="keyword">null</span>, values);</span><br><span class="line">        context.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;还是老套路，类继承自 ContentProvider 并实现相应的方法，在 initProvider() 方法中开启线程对数据进行添加表数据，此时数据库表中已经插入了一条字段名为艺术探索的数据记录。此外，当前这个 BookProvider 是要运行在另外一个进程上，所以不要忘记配置多进程属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.example.ipcdemo"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".BookProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"com.example.ipcdemo.BookProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:process</span>=<span class="string">":provider"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要注意的是，android:authorities 是 ContentProvider 的唯一标识，通过这个属性外部应用就可以访问这个 BookProvider，那么下面我们模拟在 Client 进程再插入一条表数据，然后再打印此时表中的所有数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Uri uri = Uri.parse(<span class="string">"content://com.example.ipcdemo.BookProvider"</span>);</span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"_id"</span>, <span class="number">2</span>);</span><br><span class="line">        values.put(<span class="string">"name"</span>, <span class="string">"进阶之光"</span>);</span><br><span class="line">        values.put(<span class="string">"describe"</span>, <span class="string">"皇叔牛逼!!!"</span>);</span><br><span class="line">        getContentResolver().insert(uri, values);</span><br><span class="line">        Cursor bookCursor = getContentResolver().query(uri, <span class="keyword">new</span> String[]&#123;<span class="string">"name"</span>, <span class="string">"describe"</span>&#125;,</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (bookCursor.moveToNext()) &#123;</span><br><span class="line">            Book book = <span class="keyword">new</span> Book(bookCursor.getString(<span class="number">0</span>), bookCursor.getString(<span class="number">1</span>));</span><br><span class="line">            Log.i(TAG, book.bookName + <span class="string">"------"</span> + book.bookDescribe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们通过 ContentValues 往表中插入数据，然后再调用 query() 方法查询数据库中的表数据，最终的打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">01-31 14:59:25.025 31263-31263/? I/MainActivity: 艺术探索------刚哥牛逼!!!</span><br><span class="line">01-31 14:59:25.025 31263-31263/? I/MainActivity: 进阶之光------皇叔牛逼!!!</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>&emsp;&emsp;最后我们再来看看通过 Socket 来实现进程间通信，Socket 是网络通信中的概念，关于这方面让我想起以前刚刚入门学 Java 语法的时候那会，下面就使用 Socket 来实现一个小实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isDestroyed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TcpServer()).start();</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ServerSocket serverSocket;</span><br><span class="line">            <span class="comment">// 监听9096端口</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9096</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!isDestroyed) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等待客户端发起请求并且接收信息</span></span><br><span class="line">                    <span class="keyword">final</span> Socket client = serverSocket.accept();</span><br><span class="line">                    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                responseClient(client);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;.start();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">responseClient</span><span class="params">(Socket clinet)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 接收客户端信息</span></span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clinet.getInputStream()));</span><br><span class="line">        <span class="comment">// 向客户端发送信息</span></span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedOutputStream(clinet.getOutputStream()), <span class="keyword">true</span>);</span><br><span class="line">        out.println(<span class="string">"这里是服务端"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!isDestroyed) &#123;</span><br><span class="line">            String str = in.readLine();</span><br><span class="line">            Log.i(<span class="string">"SocketService"</span>, <span class="string">"来自客户端 : "</span> + str);</span><br><span class="line">            <span class="keyword">if</span> (TextUtils.isEmpty(str)) &#123;</span><br><span class="line">                <span class="comment">// 客户端断开连接</span></span><br><span class="line">                Log.i(<span class="string">"SocketService"</span>, <span class="string">"客户端已下线..."</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String message = <span class="string">"好的，收到!"</span>;</span><br><span class="line">            out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">        clinet.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isDestroyed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样还是利用 Service 作为远程的服务端，当 Service 启动的时候建立 TCP 服务并且监听的 9096 这个端口，当客户端连接时就会生成 Socket 并且服务端可以通过 Socket 和不同客户端进行通信，这里使用流向客户端发送回应，此外需要注意的是主线程中进行网络操作是个耗时操作，接着来看客户端的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button bt_send;</span><br><span class="line">    <span class="keyword">private</span> EditText et_receive;</span><br><span class="line">    <span class="keyword">private</span> Socket mClientSocket;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter mPrintWriter;</span><br><span class="line">    <span class="keyword">private</span> TextView tv_message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        initView();</span><br><span class="line">        Intent service = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SocketService.class);</span><br><span class="line">        startService(service);</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                connectSocketServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        et_receive = findViewById(R.id.et_receive);</span><br><span class="line">        bt_send = findViewById(R.id.bt_send);</span><br><span class="line">        tv_message = findViewById(R.id.tv_message);</span><br><span class="line">        bt_send.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> String msg = et_receive.getText().toString();</span><br><span class="line">                <span class="comment">//向服务器发送信息</span></span><br><span class="line">                <span class="keyword">if</span> (!TextUtils.isEmpty(msg) &amp;&amp; <span class="keyword">null</span> != mPrintWriter) &#123;</span><br><span class="line">                    mPrintWriter.println(msg);</span><br><span class="line">                    tv_message.setText(tv_message.getText() + <span class="string">"\n"</span> + <span class="string">"客户端："</span> + msg);</span><br><span class="line">                    et_receive.setText(<span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSocketServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (socket == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//选择和服务器相同的端口8688</span></span><br><span class="line">                socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">9096</span>);</span><br><span class="line">                mClientSocket = socket;</span><br><span class="line">                mPrintWriter = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream())), <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 接收服务器端的消息</span></span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            <span class="keyword">while</span> (!isFinishing()) &#123;</span><br><span class="line">                <span class="keyword">final</span> String msg = br.readLine();</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            tv_message.setText(tv_message.getText() + <span class="string">"\n"</span> + <span class="string">"服务端："</span> + msg);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mPrintWriter.close();</span><br><span class="line">            br.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先在 onCreate() 中开启线程去连接服务端，连接成功后就是发送消息并且接收服务端回应的消息，此外，记得最后关闭 Socket，来看看运行结果：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzq32d6hcyj30dw0c4t9h.jpg" alt="效果预览"><br><br></div></p><h2 id="IPC-总览"><a href="#IPC-总览" class="headerlink" title="IPC 总览"></a>IPC 总览</h2><p>&emsp;&emsp;最后到这里，我们基本已经将 IPC 方法都简单地过了遍，下面贴出不同 IPC 方式优缺点和适用场景的图表总结：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzqtygge76j314p0if42m.jpg" alt="IPC 方式的优缺点及适用场景"><br><br><br><br></div></p><hr><p>参考文献：<br>《Android 艺术开发探索》<br>&emsp;<a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="noopener">Binder 学习指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，最近有在追美剧《海豹突击队 第二季》的小朋友吗，举个爪！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;最近又把艺术探索这本书翻了一遍，还记得第一次翻阅此书的时候感觉有些内容可真是难懂阿，现在回想起来自己那时候就是个小菜鸟，同时也很佩服感叹刚哥可真是好牛逼。都说笨鸟先飞，学习还是不能落下的。本篇学习笔记就记录下 Android 中的 IPC 机制学习过程，同时也是艺术探索的读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://Binshao.site/categories/Android/"/>
    
    
      <category term="IPC" scheme="http://Binshao.site/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>我的个人小程序上线了</title>
    <link href="http://Binshao.site/2018/10/29/MiniProgram/"/>
    <id>http://Binshao.site/2018/10/29/MiniProgram/</id>
    <published>2018-10-29T13:29:17.000Z</published>
    <updated>2019-01-24T09:00:45.835Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，大家好久不见，不知道各位那边天气如何，反正广府(广州)已经开始转凉了，每到换季一大堆人感冒……</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs58592ej30j60cs0tc.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="关于小程序"><a href="#关于小程序" class="headerlink" title="关于小程序"></a>关于小程序</h2><p>&emsp;&emsp;对于小程序近来可是越来越火热，从一开始经典的跳一跳，再到前些天上线推出的<code>云开发</code>功能，让人有种感觉这是要上天阿？确实，随着<code>云开发</code>的开放，这让开发小程序的门槛又近一步降低，我们知道没有后端的支持，前端都是些静态页面数据，而现在推出<code>云开发</code>之后确实是方便了不少。</p><p>&emsp;&emsp;毫无疑问看到这就坐不住了，要不自己也弄个小程序玩玩，于是说干就干，就有了自己这个博客小程序的存在，我把博客内容都搬到了小程序里了。这里说下小程序的官方文档挺详细的，建议大家先看看文档了解下大概，挺好上手的。<br><br></p><h2 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h2><p>&emsp;&emsp;总体上小程序功能不是很多，内容都是来自我的博客里的，算是一个博客小程序吧，下面我们分别看看各个页面的效果：</p><p>&emsp;&emsp;首页：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs4rk7w1g30a60i37wk.gif" alt=""></div></p><p>&emsp;&emsp;点击打开文章详情页面，出现 object 什么鬼，估计这里解析 Markdown 文档出了点问题，后续慢慢优化吧……</p><p>&emsp;&emsp;归档：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs3j6m03g30a60i3b29.gif" alt=""></div></p><p>&emsp;&emsp;归档页面对不同文章进行归类，也可以点击打开文章详情页面，并且点击顶部的 Tab 都会进行刷新。</p><p>&emsp;&emsp;妹子：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs0li90ug30a60i3npe.gif" alt=""></div></p><p>&emsp;&emsp;这里就算是个福利了，看文章看累了可以来看看妹子放松放松，嘿嘿，是不是美的一塌糊涂。</p><p>&emsp;&emsp;我的：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrzp0qh5g30a60i3b29.gif" alt=""></div></p><p>&emsp;&emsp;相比于其他页面，这里就没什么看点了，主要是这里会让用户进行授权，由于我之前已经做过授权了，所以演示里没有出现，具体大家也可以访问我的博客小程序玩玩。<br><br></p><h2 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h2><p>&emsp;&emsp;首先为什么要弄了个小程序，肯定是为了学习阿，关于小程序技术上的利弊这里就不多说了，微信用户量是十分庞大的，而且随着一些小程序的出现也确实是方便了生活。</p><p>&emsp;&emsp;目前小程序已经上线，对于整个小程序的开发流程也算是有了个大概了解，在这里对本项目用到的接口及参考的开源项目表示感谢，同时对于这次小程序入门也让我有了不同想法，这是我之前没去仔细想过的，比如假如我要取到数据，那么后端该怎么处理数据并返回等等，怎么说呢，学的越多发现不懂的也就越多，后面也将对小程序不断进行优化以及些新功能的实现，慢慢来。</p><p>&emsp;&emsp;最后奉上小程序码，欢迎大家体验我的小程序，当然也可以在小程序里直接搜索<code>十三的个人博客</code>。</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrz0ko4nj30760760t6.jpg" alt=""><br><br><br><br></div></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，大家好久不见，不知道各位那边天气如何，反正广府(广州)已经开始转凉了，每到换季一大堆人感冒……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs58592ej30j60cs0tc.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="http://Binshao.site/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://Binshao.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>RxJava 创建操作符详解</title>
    <link href="http://Binshao.site/2018/10/17/RxJava1/"/>
    <id>http://Binshao.site/2018/10/17/RxJava1/</id>
    <published>2018-10-17T07:25:36.000Z</published>
    <updated>2019-01-24T09:15:17.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsk8wspej30zk0b4ac4.jpg" alt=""></div></p><a id="more"></a><p>&emsp;&emsp;关于这个 create 操作符相信大家应该不会陌生，在我们上一篇的学习记录中就是用它来创建被观察者对象，是最基本的操作符。下面我们来看看它的具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Just"><a href="#Just" class="headerlink" title="Just"></a>Just</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsjuyukqj30zk0h8abi.jpg" alt=""></div></p><blockquote><p>The Just operator converts an item into an Observable that emits that item. </p></blockquote><p>对于 just 操作符文档给出的注释是它可以将传入的对象或一组对象转换为发出事件的<code>Observable</code>，也就是它可以直接发送传入的事件，还是挺方便的，来，我们一起来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsjgj80sj30zk0iwdjy.jpg" alt=""></div></p><blockquote><p>The Defer operator waits until an observer subscribes to it, and then it generates an Observable.</p></blockquote><p>&emsp;&emsp;这个操作符的作用是假如有<code>Observer</code>订阅时，才去为观察者创建新的<code>Observable</code>并且开始发送事件，每一个观察者订阅时都会得到一个新的<code>Observable</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="From"><a href="#From" class="headerlink" title="From"></a>From</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsiuvgywj30zk0hiwj5.jpg" alt=""></div></p><blockquote><p>convert various other objects and data types into Observables.</p></blockquote><p>&emsp;&emsp;From 操作符可以将各种对象或数据结构转换为<code>Observable</code>对象，我们可以将一组数组里的值转换为<code>Observable</code>对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Interval"><a href="#Interval" class="headerlink" title="Interval"></a>Interval</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsiex491j30zk0aut9y.jpg" alt=""></div></p><blockquote><p>create an Observable that emits a sequence of integers spaced by a given time interval.</p></blockquote><p>&emsp;&emsp;Interval 操作符创建的<code>Observable</code>会根据我们给定的间隔时间发送事件，类似于定时器的概念，发送事件从 0 开始且无限递增下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsi0vqlsj30zk0audhg.jpg" alt=""></div></p><blockquote><p>create an Observable that emits a particular range of sequential integers.</p></blockquote><p>&emsp;&emsp;Range 操作符创建一个发出特定范围且是连续整数的<code>Observable</code>，也就是说我们可以指定其中的选择范围的起点及长度，直接看码就懂了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhshjwqopj30zk0gy0ut.jpg" alt=""></div></p><blockquote><p>create an Observable that emits a particular item multiple times.</p></blockquote><p>&emsp;&emsp;Repeat 顾名思义就是重复的意思，那么毫无疑问这个操作符可以创建一个多次发出特定事件的<code>Observable</code>，放码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testRepeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">                .repeat(<span class="number">3</span>,Schedulers.io())</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer item)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">"TAG"</span>, <span class="string">"onNext:"</span> + item);</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">"TAG"</span>, <span class="string">"onErr:"</span> + error.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">"TAG"</span>, <span class="string">"Sequence complete."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsgxvxxmj30zk0b475d.jpg" alt=""></div></p><blockquote><p>create an Observable that emits a particular item after a given delay.</p></blockquote><p>&emsp;&emsp;Timer 操作符创建<code>Observable</code>并且同样也是根据指定延迟时间发射事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Create&quot;&gt;&lt;a href=&quot;#Create&quot; class=&quot;headerlink&quot; title=&quot;Create&quot;&gt;&lt;/a&gt;Create&lt;/h2&gt;&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsk8wspej30zk0b4ac4.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava2" scheme="http://Binshao.site/categories/RxJava2/"/>
    
    
      <category term="RxJava 创建操作符" scheme="http://Binshao.site/tags/RxJava-%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2 入门笔记</title>
    <link href="http://Binshao.site/2018/10/14/RxJava/"/>
    <id>http://Binshao.site/2018/10/14/RxJava/</id>
    <published>2018-10-14T11:06:09.000Z</published>
    <updated>2019-01-24T09:11:28.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，最近在项目学习中使用到 RxJava 并且随着它越来越流行没有理由不去了解它，但是刚开始接触的时候，还是一脸懵逼的，这里我就来记录下 RxJava 的学习笔记！</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsgckswrj30j60cs751.jpg" alt=""></div></p><a id="more"></a><p>&emsp;&emsp;网络上关于 RxJava 的讲解多不胜数，其中更是不乏好的博客文章，但是别人的知识终究还是别人的，在看懂理解的基础上自己再去动手实践，最后以输入倒逼输出，这样我们才能掌握到知识同时也能加深印象，废话不多说了！</p><h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsfxzcadj30j609owgi.jpg" alt="官网"></div></p><p>&emsp;&emsp;在 GitHub 上我们可以看到 RxJava 的简介：</p><blockquote><p>RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.</p></blockquote><p>&emsp;&emsp;翻译为 <code>RxJava 是一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库，</code>不明觉厉……说得我们能听懂的话就是 RxJava 是一个基于事件流，实现异步操作的库。</p><p>&emsp;&emsp;说到异步操作，我们下意识就会想到 Android 当中的 Handler 又或是 AsyncTask ，那么可能就会有疑问了，为什么我们不用它们而用 RxJava 呢？原因是随着请求增多并且代码逻辑会变得越来越复杂而它依然能够保持简洁清晰的逻辑，真的那么神奇吗？？？光说不练假把式，那么下面我们就先按照国际惯例先来写个 Hello World。<br><br></p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>&emsp;&emsp;其实 RxJava 的异步操作是基于扩展的观察者模式来实现的，关于观察者模式之前也记录过一篇学习总结，大家可以去翻翻。理论概念一上是不是一脸懵逼，最好还是结合代码来学习，事不宜迟，放码过来！这里我们先来看看使用步骤：</p><p>&emsp;&emsp;首先要想在 Android 中使用 RxJava2 就要先添加配置： <code>implementation &#39;io.reactivex.rxjava2:rxjava:2.2.2&#39;</code>，目前版本是 2.2.2。</p><ol><li>创建 Observable (被观察者) : 定义事件触发行为.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个被观察者 Observable 对象</span></span><br><span class="line">        Observable&lt;String&gt; observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 向观察者发送事件</span></span><br><span class="line">                e.onNext(<span class="string">"Hello World, RxJava!"</span>);</span><br><span class="line">                e.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们创建 Observable 对象是通过 create() 方法来创建，然后我们在重写的 subscribe() 方法里定义发送的事件，那么它是通过什么手段发送的呢？我们接着往下看到 <code>ObservableEmitter</code> 这个类，其实它是一个事件发射器，而我们就是通过它向观察者发送事件，可以通过它分别调用 onNext()、 onComplete() 和 onError() 方法就可以发射相对应的事件。</p><ol start="2"><li>创建 Observer (观察者) : 定义响应事件行为.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个观察者 Observer 对象</span></span><br><span class="line">        Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"进行连接..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收事件并作出响应</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"发生错误了..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"完成事件..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们创建观察者并通过重写对应事件方法，从而响应对应的事件。当观察者接收到事件前，最先调用的是 onSubscribe() 方法。</p><p>&emsp;&emsp;那么在前面的被观察者我们发射了 Next 事件，在这里我们的观察者接收到事件后就会调用 onNext() 方法进行事件的响应，而 onError() 和 onComplete() 方法也是类似，当被观察者发射事件后观察者接收到事件并进行响应。<code>此外，这里要注意的是，当 Observable（被观察者）发射了 onComplete() 事件后，Observable 之后的事件还将会继续发送事件，而 Observer (观察者) 接受到 onComplete 事件后就不会继续接受事件了。</code></p><ol start="3"><li>通过 Subscribe (订阅) 连接观察者和被观察者.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过订阅(subscribe)连接观察者和被观察者</span></span><br><span class="line">        observable.subscribe(observer);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么最后一步就是把两者连接起来。        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 打印结果</span><br><span class="line">10-15 14:33:39.890 15860-15860/? I/RxJava: 进行连接...</span><br><span class="line">    Hello World, RxJava!</span><br><span class="line">    完成事件...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到这里我们的 Hello World 就运行起来了，这里我把完整代码再贴出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = <span class="string">"RxJava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个被观察者 Observable 对象</span></span><br><span class="line">        Observable&lt;String&gt; observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 向观察者发送事件</span></span><br><span class="line">                e.onNext(<span class="string">"Hello World, RxJava!"</span>);</span><br><span class="line">                e.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个观察者 Observer 对象</span></span><br><span class="line">        Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"进行连接..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收事件并作出响应</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"发生错误了..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"完成事件..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过订阅(subscribe)连接观察者和被观察者</span></span><br><span class="line">        observable.subscribe(observer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然上面的代码我们还可以使用链式调用的方式将代码连在一起，使得逻辑简洁，同样贴码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = <span class="string">"RxJava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个被观察者 Observable 对象</span></span><br><span class="line">        Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 向观察者发送事件</span></span><br><span class="line">                e.onNext(<span class="string">"Hello World, RxJava!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(TAG, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 打印结果</span><br><span class="line">10-15 16:26:06.675 24477-24477/com.example.binshao.rxjavademo I/RxJava: Hello World, RxJava!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到我们同样也能得到结果，有仔细的同学可能会发现这里的 subscribe() 方法里的 Consumer 又是什么，其实这个 Observer 观察者的 subscribe() 是具有多个重载的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError, Action onComplete)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError, Action onComplete, Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们上面使用到的带有一个 Consumer 参数的方法表示 Observer 只关心 onNext 事件，其他我一概不接收处理，按照这个逻辑分析，没有任何参数的方法就是什么事件都不管，其他方法我们也可以举一反三！<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;到这里这篇 RxJava2 的入坑学习记录算是接近尾声了，接下来将继续记录 RxJava2 的学习过程，最后放张图来帮我们加深对 RxJava2 的学习理解：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsf5x8gtj30j609jaa6.jpg" alt=""></div></p><p>&emsp;&emsp;上游水库相当于 <code>Observable(被观察者)</code>, 而下游水库就相当于我们的<code>Observer(观察者)</code>，当下游水库缺水时，上游水库就会往下游放水，这个过程就相当于 <code>Observable</code> 向 <code>Observer</code> 发射事件；上游放水最终流到下游水库补充了水源，我们可以看作响应事件；最后最关键的，也是最重要的一点是水源能够流动的前提是我们的水闸必须是否开着的，也就是通过 <code>Subscribe(订阅)</code> 连接观察者和被观察者，不然水闸都是关着的，水源又怎么进行流动呢？<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，最近在项目学习中使用到 RxJava 并且随着它越来越流行没有理由不去了解它，但是刚开始接触的时候，还是一脸懵逼的，这里我就来记录下 RxJava 的学习笔记！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsgckswrj30j60cs751.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava2" scheme="http://Binshao.site/categories/RxJava2/"/>
    
    
      <category term="RxJava2 入门" scheme="http://Binshao.site/tags/RxJava2-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>简单实现个购物车商品数量控件</title>
    <link href="http://Binshao.site/2018/09/27/NumAddSubView/"/>
    <id>http://Binshao.site/2018/09/27/NumAddSubView/</id>
    <published>2018-09-27T12:02:16.000Z</published>
    <updated>2019-01-24T09:02:11.343Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，最近突然对马克思感兴趣了起来，此前可是一点都不感冒……看来凡事都不要太早下定论了。</p></blockquote><p>&emsp;&emsp;平时我们在各大电商平台上购物时，购物车清单里的商品数量选择器都很常见，它可以让用户选择购买商品的数量，而在最近学习项目中我们需要用到，索性我们就自己来自定义这个控件。</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs6pqgtlj30j60csmxg.jpg" alt=""></div></p><a id="more"></a><h2 id="演示效果"><a href="#演示效果" class="headerlink" title="演示效果"></a>演示效果</h2><p>&emsp;&emsp;老规矩，我们先来看看我们要实现的效果：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs65unw8g309s08j43e.gif" alt=""></div></p><p>&emsp;&emsp;你没看错，这家平台胆还真肥阿！我们从演示图中可以看到，左右两边分别是一个按钮，点击可以对商品数量进行选择，而中间则是一个 TextView，对选择的商品数量进行展示。其实这个控件还是挺简单的，那么我们分析完后，下面就开始动手撸码。<br><br></p><h2 id="控件布局及自定义属性"><a href="#控件布局及自定义属性" class="headerlink" title="控件布局及自定义属性"></a>控件布局及自定义属性</h2><p>&emsp;&emsp;那么我们先来看看布局代码先，上面我们分析了左右两边都是一个 Button，中间是一个 TextView，这里的布局代码就不多说了，放码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@drawable/selector_number_add_sub"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_sub"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@drawable/bg_btn_style_white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"-"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#000"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/etxt_num"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"16sp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"@color/black"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_add"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@drawable/bg_btn_style_white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"+"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#000"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然说到了自定义控件，那么自定义属性我们肯定是不陌生的，关于自定义属性十三之前有记录过一篇学习记录，大家可以移步到 <a href="https://binshao.site/2018/03/08/AttributeSet/">Android 自定义属性</a> 这里查看。</p><p>&emsp;&emsp;那么我们这里需要什么属性呢，既然商品数量选择，那么我们肯定要提供<code>当前商品数量、最低数量、以及库存的最大数量。</code>总不能库存都清空了还拿出来卖吧！还有其他一些如提供修改按钮等控件的背景色等属性，下面来看看属性文件代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"value"</span> <span class="attr">format</span>=<span class="string">"integer|reference"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"minValue"</span> <span class="attr">format</span>=<span class="string">"integer|reference"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"maxValue"</span> <span class="attr">format</span>=<span class="string">"integer|reference"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"editBackground"</span> <span class="attr">format</span>=<span class="string">"reference"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"buttonAddBackgroud"</span> <span class="attr">format</span>=<span class="string">"reference"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"buttonSubBackgroud"</span> <span class="attr">format</span>=<span class="string">"reference"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"NumAddSubView"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"value"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"minValue"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"maxValue"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"editBackground"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"buttonAddBackgroud"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"buttonSubBackgroud"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="自定义控件代码"><a href="#自定义控件代码" class="headerlink" title="自定义控件代码"></a>自定义控件代码</h2><p>&emsp;&emsp;搞定了我们的布局以及属性，接下来我们就可以来写自定义控件的代码了，这里还是直接贴出源码，看起来还是挺简单的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberAddSubView</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mTxtNum;</span><br><span class="line">    <span class="keyword">private</span> Button mBtnAdd;</span><br><span class="line">    <span class="keyword">private</span> Button mBtnSub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnButtonClickListenr onButtonClickListener;</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater mInflater;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxValue = DEFAULT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberAddSubView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberAddSubView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberAddSubView</span><span class="params">(Context context, @Nullable AttributeSet attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        mInflater = LayoutInflater.from(context);</span><br><span class="line">        initView();</span><br><span class="line">        <span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> TintTypedArray a = TintTypedArray.obtainStyledAttributes(getContext(),</span><br><span class="line">                    attrs, R.styleable.NumberAddSubView, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> val = a.getInt(R.styleable.NumberAddSubView_value, <span class="number">0</span>);</span><br><span class="line">            setValue(val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> maxVal = a.getInt(R.styleable.NumberAddSubView_maxValue, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (maxVal != <span class="number">0</span>)</span><br><span class="line">                setMaxValue(maxVal);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> minVal = a.getInt(R.styleable.NumberAddSubView_minValue, <span class="number">0</span>);</span><br><span class="line">            setMinValue(minVal);</span><br><span class="line"></span><br><span class="line">            Drawable etBackground = a.getDrawable(</span><br><span class="line">                    R.styleable.NumberAddSubView_editBackground);</span><br><span class="line">            <span class="keyword">if</span> (etBackground != <span class="keyword">null</span>)</span><br><span class="line">                setEditTextBackground(etBackground);</span><br><span class="line"></span><br><span class="line">            Drawable buttonAddBackground = a.getDrawable(</span><br><span class="line">                    R.styleable.NumberAddSubView_buttonAddBackgroud);</span><br><span class="line">            <span class="keyword">if</span> (buttonAddBackground != <span class="keyword">null</span>)</span><br><span class="line">                setButtonAddBackgroud(buttonAddBackground);</span><br><span class="line"></span><br><span class="line">            Drawable buttonSubBackground = a.getDrawable(</span><br><span class="line">                    R.styleable.NumberAddSubView_buttonSubBackgroud);</span><br><span class="line">            <span class="keyword">if</span> (buttonSubBackground != <span class="keyword">null</span>)</span><br><span class="line">                setButtonSubBackgroud(buttonSubBackground);</span><br><span class="line"></span><br><span class="line">            a.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        View view = mInflater.inflate(R.layout.widet_num_add_sub, <span class="keyword">this</span>,</span><br><span class="line">                <span class="keyword">true</span>);</span><br><span class="line">        mTxtNum = view.findViewById(R.id.etxt_num);</span><br><span class="line">        mTxtNum.setInputType(InputType.TYPE_NULL);</span><br><span class="line">        mTxtNum.setKeyListener(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        mBtnAdd = view.findViewById(R.id.btn_add);</span><br><span class="line">        mBtnSub = view.findViewById(R.id.btn_sub);</span><br><span class="line"></span><br><span class="line">        mBtnAdd.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        mBtnSub.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.btn_add) &#123;</span><br><span class="line">            numAdd();</span><br><span class="line">            <span class="keyword">if</span> (onButtonClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                onButtonClickListener.onButtonAddClick(v, <span class="keyword">this</span>.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.getId() == R.id.btn_sub) &#123;</span><br><span class="line">            numSub();</span><br><span class="line">            <span class="keyword">if</span> (onButtonClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                onButtonClickListener.onButtonSubClick(v, <span class="keyword">this</span>.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">numAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getValue();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value &lt;= maxValue)</span><br><span class="line">            <span class="keyword">this</span>.value = +<span class="keyword">this</span>.value + <span class="number">1</span>;</span><br><span class="line">        mTxtNum.setText(value + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">numSub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getValue();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value &gt; minValue)</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="keyword">this</span>.value - <span class="number">1</span>;</span><br><span class="line">        mTxtNum.setText(value + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = mTxtNum.getText().toString();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(value))</span><br><span class="line">            <span class="keyword">this</span>.value = Integer.parseInt(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        mTxtNum.setText(value + <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxValue</span><span class="params">(<span class="keyword">int</span> maxValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxValue = maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinValue</span><span class="params">(<span class="keyword">int</span> minValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.minValue = minValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEditTextBackground</span><span class="params">(Drawable drawable)</span> </span>&#123;</span><br><span class="line">        mTxtNum.setBackgroundDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEditTextBackground</span><span class="params">(<span class="keyword">int</span> drawableId)</span> </span>&#123;</span><br><span class="line">        setEditTextBackground(getResources().getDrawable(drawableId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setButtonAddBackgroud</span><span class="params">(Drawable backgroud)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBtnAdd.setBackground(backgroud);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setButtonSubBackgroud</span><span class="params">(Drawable backgroud)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBtnSub.setBackground(backgroud);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnButtonClickListener</span><span class="params">(OnButtonClickListenr onButtonClickListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onButtonClickListener = onButtonClickListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnButtonClickListenr</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">onButtonAddClick</span><span class="params">(View view, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">onButtonSubClick</span><span class="params">(View view, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;按照国际惯例，我们先初始化控件，然后再读取自定义属性值并赋值，最后再根据具体的点击按钮提供相应的点击事件，这样一来我们就完成了这个自定义控件的基本功能，还是挺简单的有木有，为了学习记录的完整性，下面贴出运行 Activity 界面布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/orange"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">"5dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.CardView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardBackgroundColor</span>=<span class="string">"@color/white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardCornerRadius</span>=<span class="string">"13dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginLeft</span>=<span class="string">"15dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/drawee_view"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"180dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"180dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:src</span>=<span class="string">"@drawable/ak74"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_marginLeft</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/text_title"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_marginTop</span>=<span class="string">"20dp"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:maxLines</span>=<span class="string">"3"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:text</span>=<span class="string">"武器型号：AK47步枪 弹匣容量：30"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:textColor</span>=<span class="string">"@color/gray"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:textSize</span>=<span class="string">"16sp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/txt_price"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_gravity</span>=<span class="string">"right"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:text</span>=<span class="string">"400$"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:textColor</span>=<span class="string">"@color/crimson"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:textSize</span>=<span class="string">"18sp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">com.example.binshao.cainiaoshop.widget.NumberAddSubView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/number_control"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_marginTop</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">app:minValue</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.v7.widget.CardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到这里这一篇学习记录就差不多接近尾声了，当然了，上面这些也只是一些 Demo，还有很多地方需要完善，比如点击数量选择器时，价格也可以跟着改变等等……</p><p>&emsp;&emsp;好了，该撤了，读马克思去……<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，最近突然对马克思感兴趣了起来，此前可是一点都不感冒……看来凡事都不要太早下定论了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;平时我们在各大电商平台上购物时，购物车清单里的商品数量选择器都很常见，它可以让用户选择购买商品的数量，而在最近学习项目中我们需要用到，索性我们就自己来自定义这个控件。&lt;/p&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs6pqgtlj30j60csmxg.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://Binshao.site/categories/Android/"/>
    
    
      <category term="自定义控件" scheme="http://Binshao.site/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>扎心的八月</title>
    <link href="http://Binshao.site/2018/08/30/Aug/"/>
    <id>http://Binshao.site/2018/08/30/Aug/</id>
    <published>2018-08-30T01:29:02.000Z</published>
    <updated>2019-01-24T08:27:27.663Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，人生中最后一个暑假假期就剩下两天了，余额严重不足感……  </p></blockquote><p>&emsp;&emsp;好些天没来记录了，这段时间都用来养病去了，以至于感觉过的没那么充实却又觉意义深远，今天家这边大雨倾盆，竟然有些凉意。</p><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhr6hv2iaj30j60eeadu.jpg" alt=""></div></p><h2 id="糟糕的八月"><a href="#糟糕的八月" class="headerlink" title="糟糕的八月"></a>糟糕的八月</h2><p>&emsp;&emsp;假期这段时间以来，大多数时间就在电脑前敲代码、查阅技术书籍，记录学习过程并总结成文，就这样一天过一天，时间如流水，转眼就来到月，也不知道是哪天感觉双眼发烫，眨眼间有种胀痛感，镜子前一看双眼充红，这一下给吓得不行，赶紧找大夫去…</p><p>&emsp;&emsp;接下来这段时间自然便是与药片相伴的日子，因用眼过度导致眼疲劳，一不小心病毒就入侵了，病毒侵占成功并大肆举起红旗，颇有得意之感。双眼看起来就像杀红了眼…每隔 2 小时就得滴眼药水，这种状态一直持续了好久，还记得养病期间和老友们去影院看电影，全程都在闭着眼睛没怎么看电影，过后还被批评不走心（你看我一脸委屈脸，哭），现在想想还觉得挺好笑，哈哈！<br><br></p><h2 id="用眼指南"><a href="#用眼指南" class="headerlink" title="用眼指南"></a>用眼指南</h2><p>&emsp;&emsp;既然出了问题就要找出问题所在，我回顾了下，长期坐在电脑跟前不动这算其一，放松娱乐就是下意识拿起手机，真当身体是刀枪不入？这样子下来眼睛肯定受不了，是该学点养生知识了：  </p><ul><li>泡点菊花枸杞茶喝喝.  </li><li>使用电脑每隔 <code>四五十</code> 分钟起身走走，让眼睛眺望远处放松放松.</li><li>有意识地增加眨眼次数.</li><li>做做眼保健操.</li><li>保证充足的睡眠.</li><li>真的要加强锻炼身体.</li></ul><p>&emsp;&emsp;是不是俨然一副手拿保温杯养生老干部的样子，高手在民间，呵…</p><p>&emsp;&emsp;经过这段时间的休息，眼睛也恢复的差不多了，然而我的假期就快要结束了，没有想到会这样度过这最后一个暑假期，我想这还真是让人印象深刻阿！吃一垫，长一智！这看似糟糕的八月，却敲响了警钟，我们始终认为自己还年轻，可事实却告诉我们这是在玩火！</p><p>&emsp;&emsp;最后希望大家都有一个强壮健康的身体！<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，人生中最后一个暑假假期就剩下两天了，余额严重不足感……  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;好些天没来记录了，这段时间都用来养病去了，以至于感觉过的没那么充实却又觉意义深远，今天家这边大雨倾盆，竟然有些凉意。&lt;/p&gt;
    
    </summary>
    
      <category term="时光任意门" scheme="http://Binshao.site/categories/%E6%97%B6%E5%85%89%E4%BB%BB%E6%84%8F%E9%97%A8/"/>
    
    
      <category term="生活杂谈" scheme="http://Binshao.site/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
      <category term="健康" scheme="http://Binshao.site/tags/%E5%81%A5%E5%BA%B7/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 runOnUiThread</title>
    <link href="http://Binshao.site/2018/08/17/runOnUiThread/"/>
    <id>http://Binshao.site/2018/08/17/runOnUiThread/</id>
    <published>2018-08-17T12:41:01.000Z</published>
    <updated>2019-01-24T09:09:54.462Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，今天对咱来说还是不太友好的，咱还是先回避回避…</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhseqpzjpj30j60b1ta1.jpg" alt=""></div></p><p>&emsp;&emsp;上篇学习记录中我们提到了 IntentService 并且是把它大致工作流程简单走了一遍，来一个传送门：<a href="https://binshao.site/2018/08/16/IntentService/">IntentService 的深入理解</a> 。</p><p>&emsp;&emsp;一方面十三是非常害怕哪里理解错或者说是理解的不够深入，但是既然是学习记录我就把学习过程记录下来，也好让自己加深印象，还望各位大牛同学一起指出错误，指点下愚钝的十三。</p><a id="more"></a><p><br></p><h2 id="runOnUiThread"><a href="#runOnUiThread" class="headerlink" title="runOnUiThread"></a>runOnUiThread</h2><p>&emsp;&emsp;那么今天我们就来看看 runOnUiThread，这是一种更加简洁的写法，它是 Activity 提供的方法，首先我们先来看看文档对它的介绍：</p><blockquote><p>Runs the specified action on the UI thread. If the current thread is the UI thread, then the action is executed immediately. If the current thread is not the UI thread, the action is posted to the event queue of the UI thread.</p></blockquote><p>&emsp;&emsp;大概意思是说：在 UI 线程上运行指定的操作。如果当前线程是 UI 线程，则立即执行该操作。如果当前线程不是 UI 线程，则将操作发布到 UI 线程的事件队列。</p><p>&emsp;&emsp;runOnUiThread 相信大家平时使用中也非常常用，那么这里我们先不说那么多，先来个小例子实战演示下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main4);</span><br><span class="line">        mTextView = findViewById(R.id.response_text);</span><br><span class="line">        Button mButton = findViewById(R.id.send_request);</span><br><span class="line">        mButton.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.send_request) &#123;</span><br><span class="line">            sendRequest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                HttpURLConnection conn = <span class="keyword">null</span>;</span><br><span class="line">                BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    URL url = <span class="keyword">new</span> URL(<span class="string">"https://www.vip.com"</span>);</span><br><span class="line">                    conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">                    conn.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">                    conn.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line">                    conn.setReadTimeout(<span class="number">5000</span>);</span><br><span class="line">                    InputStream in = conn.getInputStream();</span><br><span class="line">                    reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">                    StringBuilder response = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    String line;</span><br><span class="line">                    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        response.append(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                    showResponse(response.toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            reader.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        conn.disconnect();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showResponse</span><span class="params">(<span class="keyword">final</span> String s)</span> </span>&#123;</span><br><span class="line">        runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mTextView.setText(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码非常简单，我们点击按钮就请求访问一个 URL 站点，然后我们使用 runOnUiThread 这个方法把请求结果展示到 UI 界面上。这里我们简单的布局代码就不贴了，我们来看看演示：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhseb5cpvg307o0d54qp.gif" alt=""></div></p><p>&emsp;&emsp;从演示结果中我们可以得到请求后的一堆 H5 代码，说明我们访问请求成功并得到响应，而 runOnUiThread 方法也的确好用，我们只需要关心更新 UI 操作即可，确实是更加简洁了。<br><br></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>&emsp;&emsp;那么我们可能会好奇它是怎么做到的，我们就得去看看它的源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">            mHandler.post(action);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            action.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先它会先判断当前线程是否是 UI 线程，不是就调用 Handler 的 post 方法；是就直接调用 Runnable 的 run 方法。正如文档介绍那样，相信有了前些篇学习记录的基础上，这里的源码就知道是什么意思了，嘿嘿…十三也不瞎 BB 了，免得又说啰嗦了。<br><br></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>&emsp;&emsp;说实话，今天这一篇学习记录还挺短的，难道是今天想偷懒？不不不，我们前面就把 Handler 相关的知识做了个总结，那么到 runOnUiThread 这里也是和 Handler 有很大关系，这算不算是以不变应万变呢？</p><p>&emsp;&emsp;到这里，我们这一系列的学习记录算是完结了，我们先从线程以及线程池开始，接着从异步消息机制再到这里，脑袋都不够用，然而十三总觉得这还仅是些皮毛，还有好多东西都不知道不了解的，一步步来！</p><p>最后来一波系列回顾：</p><ol><li><p><a href="https://binshao.site/2018/08/08/ThreadPool/">Android中的线程池</a></p></li><li><p><a href="https://binshao.site/2018/08/10/AsyncTask/">AsyncTask 的深入理解</a></p></li><li><p><a href="https://binshao.site/2018/08/12/Handler/">Handler 的深入理解</a></p></li><li><p><a href="https://binshao.site/2018/08/13/HandlerThread/">HandlerThread 的深入理解</a></p></li><li><p><a href="https://binshao.site/2018/08/16/IntentService/">IntentService 的深入理解</a></p></li></ol><p>&emsp;&emsp;这一系列的学习回想起来真是好艰苦阿，前前后后不知道看了多少遍，种瓜得瓜，种豆得豆，刻苦的学习过程带来的还是知识的收获，最后我再反问自己，标题都是深入理解，那么自己是真的深入理解吗？<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，今天对咱来说还是不太友好的，咱还是先回避回避…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fzhseqpzjpj30j60b1ta1.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;上篇学习记录中我们提到了 IntentService 并且是把它大致工作流程简单走了一遍，来一个传送门：&lt;a href=&quot;https://binshao.site/2018/08/16/IntentService/&quot;&gt;IntentService 的深入理解&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;一方面十三是非常害怕哪里理解错或者说是理解的不够深入，但是既然是学习记录我就把学习过程记录下来，也好让自己加深印象，还望各位大牛同学一起指出错误，指点下愚钝的十三。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://Binshao.site/categories/Android/"/>
    
    
      <category term="runOnUiThread" scheme="http://Binshao.site/tags/runOnUiThread/"/>
    
  </entry>
  
  <entry>
    <title>IntentService 的深入理解</title>
    <link href="http://Binshao.site/2018/08/16/IntentService/"/>
    <id>http://Binshao.site/2018/08/16/IntentService/</id>
    <published>2018-08-16T12:40:45.000Z</published>
    <updated>2019-01-24T08:50:49.513Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，快要七夕了，这个中国版情人节朋友圈估计又是刷屏的节奏，不知道大家打算好怎么过呢？</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhruw8gh6j30j60csjsq.jpg" alt=""></div></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;平时我们在开发中，需要执行耗时的任务操作我们可能会交给 Service 去处理，并且为了避免 ANR，通常我们会在服务里开启子线程执行这些耗时的操作，比如如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们知道 Service 一旦启动之后，就会一直处于运行状态，那么我们就要调用 stopService() 或者 stopSelf() 方法可以使 Service 停止运行状态，这些都是基础知识，相信大家都滚瓜烂熟了，十三也就不 BB 了，Google 也提供了一个 IntentService 这个类同样也能帮助我们解决上面这些问题。</p><p>&emsp;&emsp;而我们在上一篇学习记录中提到 HandlerThread，其实它在 Android 中的具体使用场景是 IntentService，这里我们先来个传送门：<a href="https://binshao.site/2018/08/13/HandlerThread/">HandlerThread 的深入理解</a> 。<br><br></p><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>&emsp;&emsp;首先我们先来看看文档对它的介绍：</p><blockquote><p>IntentService is a base class for Services that handle asynchronous requests (expressed as Intents) on demand. Clients send requests through Context.startService(Intent) calls; the service is started as needed, handles each Intent in turn using a worker thread, and stops itself when it runs out of work.</p></blockquote><p>&emsp;&emsp;大概就是说 IntentService 继承自 Service 类，我们可以用它来处理异步请求，客户端通过调用 Context.startService(Intent) 发送请求，服务会在需要的时候启动，并且使用工作线程执行任务是依次处理每个 Intent 的，在完成所有任务后会自己停止运行状态。</p><p>&emsp;&emsp;通过上面的了解，相比于普通的 Service，我们不用再创建子线程并且也不用操心手动停止 Service 了，就好像是手动点火炸药进化到遥控炸弹那样，很方便有木有，那么下面我们来做个小例子演示怎么使用 IntentService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> android.os.Handler mUIHandler;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT_MSG = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUIHandler</span><span class="params">(android.os.Handler UIHandler)</span> </span>&#123;</span><br><span class="line">        mUIHandler = UIHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"MyIntentService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"MyIntentService"</span>, <span class="string">"Thread id："</span> + Thread.currentThread().getId());</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">           sb.append(Thread.currentThread().getName() + Thread.currentThread().getId())</span><br><span class="line">                   .append(<span class="string">"\n"</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           sendMessageToMainThread(WHAT_MSG, sb.toString());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessageToMainThread</span><span class="params">(<span class="keyword">int</span> id, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mUIHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mUIHandler.sendMessage(mUIHandler.obtainMessage(id, obj));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.i(<span class="string">"MyIntentService"</span>, <span class="string">"onDestroy()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们新建了个类并继承自 IntentService，首先我们要提供一个无参的构造方法并调用父类的构造方法，接着实现 onHandlerIntent() 这个抽象方法，我们在这里分别打印 三 次当前线程名和 id。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main6Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main6);</span><br><span class="line">        mTextView = findViewById(R.id.text_info);</span><br><span class="line">        MyIntentService.setUIHandler(<span class="keyword">new</span> Handler(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">btnClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.start_service) &#123;</span><br><span class="line">            Intent intentService = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyIntentService.class);</span><br><span class="line">            startService(intentService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MyIntentService.WHAT_MSG:</span><br><span class="line">                    mTextView.setText((String)msg.obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着 Activity 里的代码，就是点击按钮我们就启动服务，并让服务去执行任务最后并把执行任务的结果显示到 UI 上，代码非常简单，十三也就不多说了，来看看运行效果演示吧：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhruhyuepg30bn07bn0c.gif" alt=""></div></p><p>&emsp;&emsp;可以看到每点击次按钮就会执行三次打印，并且每次打印的线程名和 id 都是一样的，那么我们再来看看 logcat 中的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I/MyIntentService: Thread id：2788</span><br><span class="line">I/MyIntentService: onDestroy()</span><br><span class="line">I/MyIntentService: Thread id：2789</span><br><span class="line">I/MyIntentService: onDestroy()</span><br><span class="line">I/MyIntentService: Thread id：2790</span><br><span class="line">I/MyIntentService: onDestroy()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的演示效果里我们可以看到，我们一共点击 3 次按钮，每一次执行 3 次打印输出，尽管每一次打印 3 次，可执行的还是同一个线程，当执行完最后一个任务的时候它会自己停止，也就是 onDestroy() 方法被调用。<br><br></p><h2 id="IntentService-深入学习"><a href="#IntentService-深入学习" class="headerlink" title="IntentService 深入学习"></a>IntentService 深入学习</h2><p>&emsp;&emsp;同样我们还是去看看它的源码实现，其实它的源码非常短，先给它来张全家福：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mRedelivery;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntentService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        mRedelivery = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mServiceLooper.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@WorkerThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;把注释一删掉后就没只有 65 行左右的代码，我们首先看到它继承自 Service 并且是个抽象类，所以我们都是创建它的子类来使用 IntentService，先来看看 onCreate 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate();</span><br><span class="line">       HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">       thread.start();</span><br><span class="line"></span><br><span class="line">       mServiceLooper = thread.getLooper();</span><br><span class="line">       mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当启动 IntentService 的时候 onCreate 方法会被调用，在方法中创建一个 HandlerThread 并去启动它，然后把 HandlerThread 的 Looper 对象传入到 mServiceHandler 中去，那么这个 mServiceHandler 又是什么呢？其实它是个 Handler，我们可以看看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个 ServiceHandler 类继承自 Handler，而前面我们说到 HandlerThread 的 Looper 对象又传入给它，所以这样通过 ServiceHandler 处理异步任务了。</p><p>&emsp;&emsp;那么我们可能就会疑问了？这个 IntentService 是怎么启动任务的呢，这个我们就得看看 onStartCommand() 方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在 onStartCommand 方法中又去调用 onStart() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而在 onStart 方法中，我们可以看到 IntentService 通过 mServiceHandler 发送了一条消息，那么这条消息就会在 HandlerThread 中处理，<code>注意，因为这里的 Looper 对象是 HandlerThead 中拥有的，</code>接着 mServiceHandler 收到消息会把 Intent 对象交给 handleMessage 方法处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而在 handleMessage 方法中又调用 onHandleIntent 方法并把 Intent 对象一同传入，事实上这个 Intent 就是我们在 startService 中传入的 intent 内容，当方法执行结束后，在 代码 9 行处 IntentService 通过 stopSelf(msg.arg1) 方法停止服务，原来这个自动停止服务状态的秘密在这里！</p><p>&emsp;&emsp;那么到这里，我们可能会好奇这个 onHandleIntent 方法为什么那么眼熟呢？我们赶紧去看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过源码我们知道，原来 IntentService 的 onHandleIntent 方法是一个抽象方法，所以我们在创建 IntentService 的时候必须实现该方法，而我们在前面的示例中也确实实现了该方法，同学们可以滑到前面去看看，怪不得那么眼熟呢！</p><p>&emsp;&emsp;假如此时有一个或者多个任务，那么 onHandleIntent 就会执行任务，直到执行任务完成后，stopSelf 就会自动停止服务状态。而且每次执行后台任务都会启动一次 IntentService，而 IntentService 通过发送消息到 HandlerThread 执行任务，并且我们知道 Looper 是按顺序执行任务的，所以当有多个任务执行时它们都是顺序排队执行的。<br><br></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>&emsp;&emsp;到这里，IntentService 的学习记录就接近尾声了，越来越觉得自己不知道不懂得还有很多了，可是都后头来还是觉得学习的同时还要注意身体健康，大家都要注意锻炼身体。</p><p>技术参考文献：<br>【鸿洋大神的博客】<a href="http://blog.csdn.net/lmj623565791/article/details/47143563" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/47143563</a><br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，快要七夕了，这个中国版情人节朋友圈估计又是刷屏的节奏，不知道大家打算好怎么过呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fzhruw8gh6j30j60csjsq.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://Binshao.site/categories/Android/"/>
    
    
      <category term="IntentService" scheme="http://Binshao.site/tags/IntentService/"/>
    
  </entry>
  
  <entry>
    <title>HandlerThread 的深入理解</title>
    <link href="http://Binshao.site/2018/08/13/HandlerThread/"/>
    <id>http://Binshao.site/2018/08/13/HandlerThread/</id>
    <published>2018-08-13T12:40:30.000Z</published>
    <updated>2019-01-24T08:48:40.340Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，最近新出了一种以老师名字命名的语言——Julia，看到 Julia 相信懂的人自然就懂，嘿嘿，今晚秋名山见…</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrso0svzj30j60cs404.jpg" alt=""></div></p><p>在上篇学习记录中我们提到 Android 消息机制 Handler，并且我们也把它整个工作流程大概走了一篇，不知道十三就在说啥的同学请到这边的传送门接受安检：<a href="https://binshao.site/2018/08/12/Handler/">Handler 的深入理解</a>。</p><a id="more"></a><p>&emsp;&emsp;我们知道使用 Handler 就必须为线程创建 Looper，而主线程已经在初始化的时候为我们创建好了，所以我们可以直接使用 Handler，那么如果在子线程呢？这个问题也很好解决，相信大家在看了十三上一篇学习记录后也知道答案，我们就得这样来写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Looper.prepare();</span><br><span class="line"></span><br><span class="line">          mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                  ......</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          Looper.loop();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么这东西写一次两次还好，写多了就会觉得麻烦阿，感觉非常繁琐。这不，HandlerThread 就应运而生，那么我们来看看它有多方便。<br><br></p><h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><blockquote><p>Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called.</p></blockquote><p>&emsp;&emsp;首先我们来看看文档对它的介绍，大概意思就是说 HandlerThread 是一个包含 Looper 的类，我们可以直接使用这个 Looper 创建 Handler，注意的是必须调用 start() 方法。十三英语不好，翻译不规范还请大家多多见谅。</p><p>&emsp;&emsp;说了那么多咱们直接先用起来，下面我们用一个小例子来演示下使用过程，那个谁，放码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main5Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_UPDATE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">private</span> Handler msgHandler;</span><br><span class="line">    <span class="keyword">private</span> HandlerThread mThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main5);</span><br><span class="line">        mTextView = findViewById(R.id.id_textview);</span><br><span class="line">        initBackThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后台线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBackThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mThread = <span class="keyword">new</span> HandlerThread(<span class="string">"message"</span>);</span><br><span class="line">        mThread.start();</span><br><span class="line">        msgHandler = <span class="keyword">new</span> Handler(mThread.getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                updateInfo();</span><br><span class="line">                <span class="keyword">if</span> (isUpdate) &#123;</span><br><span class="line">                    msgHandler.sendEmptyMessageDelayed(MESSAGE_UPDATE, <span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    String data = <span class="string">"当前气温：&lt;font color='red'&gt;%d&lt;/font&gt; ℃"</span>;</span><br><span class="line">                    data = String.format(data, (<span class="keyword">int</span>) (Math.random() * <span class="number">39</span> + <span class="number">1</span>));</span><br><span class="line">                    mTextView.setText(Html.fromHtml(data));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        isUpdate = <span class="keyword">true</span>;</span><br><span class="line">        msgHandler.sendEmptyMessage(MESSAGE_UPDATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        isUpdate = <span class="keyword">false</span>;</span><br><span class="line">        msgHandler.removeMessages(MESSAGE_UPDATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mThread.quit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里布局文件代码就不贴出来了，就一个 TextView，最后我们来看看效果演示：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrs2jns9g30ac06jgpb.gif" alt=""></div></p><p>&emsp;&emsp;可以看到这里的气温变化还是蛮大的，就像是女人的心情…主要是随机数范围没写好，嘿嘿，我们代码中去获取天气数据是个耗时操作，所以我们通过 HandlerThread 去获取 Looper，然后通过 Handler 的 post(Runnable r) 并在 handleMessage 方法里进行处理，感觉很方便有没有，并且很方便进行线程间的通信。<br>那么这时候问题就来了，它是怎么做到的呢？<br><br></p><h2 id="HandlerThread-的深入学习"><a href="#HandlerThread-的深入学习" class="headerlink" title="HandlerThread 的深入学习"></a>HandlerThread 的深入学习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原来 HandlerThread 继承了 Thread，所以一定不要忘了调用 start() 方法，那么既然本质上是个线程，那么下面我们去看看它的 run 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到在 run 方法中，在代码 4 行处，它调用 Looper.prepare() 创建一个 Looper 对象，然后又调用了 Looper.loop 方法开启消息循环并从队列中取消息，看到这里我们明白原来它把脏活累活都帮我们干了，如此一来，在 HandlerThread 中我们可以创建 Handler 了。</p><p>&emsp;&emsp;那么在代码 10 行处，有同学眼尖可能已经发现，这个 onLooperPrepared() 又是个什么东东呢？我们接着跟进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call back method that can be explicitly overridden if needed to execute some</span></span><br><span class="line"><span class="comment"> * setup before Looper loops.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们发现它是个空方法，通过注释也可以看到，我们可以在 Looper.prepare()创建完后做些初始化的工作，那么我们只需要重写这个方法。</p><p>&emsp;&emsp;下面我们来看看 getLooper 这个方法，还记得上面我们例子中使用的这个方法吗，我们在构造 Handler 时传入 Looper 是通过这个方法的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgHandler = new Handler(mThread.getLooper())</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么我们来看看它在源码中的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment"> * or for any reason isAlive() returns false, this method will return null. If this thread</span></span><br><span class="line"><span class="comment"> * has been started, this method will block until the looper has been initialized.  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此方法返回与此线程关联的 Looper。如果此线程未启动或由于任何原因 isAlive() 返回 false，则此方法将返回null。如果此线程已启动，则此方法将阻塞，直到looper已初始化为止。也就是说它返回的是在 run 方法中创建的 mLooper。</p><p>&emsp;&emsp;此外我们再看看 quit 和 quitSafely 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们知道由于 HandlerThread 的 run 方法是会一直循环的，所以当我们不再需要 HandlerThread 的时候，我们可以通过 quit 或 quitSafely 方法来结束线程的执行，在前面的例子中我们也要使用，同学们可以滑到前面看看。<br><br></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>&emsp;&emsp;看到这里，关于 HandlerThread 的学习记录就差不多到了尾声，相信有了前篇 Handler 学习记录的基础上，再看 HandlerThread 会显得比较轻松，HandlerThread 它是一个帮我们创建了 Looper 的线程，并且我们可以在线程中使用 Handler 处理后台任务。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，最近新出了一种以老师名字命名的语言——Julia，看到 Julia 相信懂的人自然就懂，嘿嘿，今晚秋名山见…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrso0svzj30j60cs404.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;在上篇学习记录中我们提到 Android 消息机制 Handler，并且我们也把它整个工作流程大概走了一篇，不知道十三就在说啥的同学请到这边的传送门接受安检：&lt;a href=&quot;https://binshao.site/2018/08/12/Handler/&quot;&gt;Handler 的深入理解&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://Binshao.site/categories/Android/"/>
    
    
      <category term="HandlerThread" scheme="http://Binshao.site/tags/HandlerThread/"/>
    
  </entry>
  
  <entry>
    <title>Handler 的深入理解</title>
    <link href="http://Binshao.site/2018/08/12/Handler/"/>
    <id>http://Binshao.site/2018/08/12/Handler/</id>
    <published>2018-08-12T12:39:58.000Z</published>
    <updated>2019-01-24T08:47:32.411Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，感觉最近肉欲好强，好想吃烤肉、各种肉肉…</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrrgva5qj30j60crgot.jpg" alt=""></div></p><p>&emsp;&emsp;在上些篇学习记录里我们提到了 AsyncTask 并且算是把它的大体源码流程走了一遍，实际上 AsyncTask 封装了 Thread 和 Handler，正是它完好的封装使得我们无需关心太多。这里来个传送门：<a href="https://binshao.site/2018/08/10/AsyncTask/">AsyncTask 的深入理解</a> 。</p><a id="more"></a><p>&emsp;&emsp;说到了 Handler，想必大家也是很熟悉了，还记得十三刚学习 Android 那会儿要在主线程更新 UI，第一个先接触的就是它。<br><br></p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>&emsp;&emsp;通常我们所说的异步消息处理机制主要是指 Handler 的运行机制，它主要由 Message、Handler、MessageQueue 和 Looper 所组成，老规矩，我们先来看看它们的概念介绍：</p><ul><li><p>Message：顾名思义，它是在线程之间传递的信息，可携带少量的信息在不同线程间交换数据.</p></li><li><p>Handler：主要用于发送和处理消息的，一般我们通过调用它的 sendMessage() 方法发送消息，最终消息又传递到 HandlerMessage() 方法中.</p></li><li><p>MessageQueue：消息队列，主要用于存放所有通过 Handler 发送的消息，<code>每个线程中只会有一个 MessageQueue 对象.</code></p></li><li><p>Looper：在这里我们可以理解为消息循环，前面我们提到了 MessageQueue 会对消息进行存储，那么 Looper 就会去查找并处理消息，<code>注意：它可是已无限循环的形式存在，没有消息则会一直等待着.</code></p></li></ul><p>&emsp;&emsp;概念介绍完后，我们把 Handler 的整个工作流程大致捋一遍：</p><p>&emsp;&emsp;首先我们需要在主线程中创建 Handler 对象并重写 handlerMessage() 方法，接着当我们在子线程中需要对 UI 进行访问时，我们就会创建一个 Message 对象，并通过 Handler 把这条信息发送出去，之后这条信息就会被添加到 MessageQueue 队列中等待处理，而我们的 Looper 则会很勤劳，它会从 MessageQueue 队列中取出消息，并把消息发回到 Handler 的 handlerMessage() 方法里，这样一来执行环境便切换到主线程当中了，我们便也能对 UI 进行操作。</p><p>&emsp;&emsp;下面我们就快速来写个小例子，演示下效果，相信各位老司机都是信手捏来了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main3Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANGE_TEXT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Button mButton;</span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> CHANGE_TEXT:</span><br><span class="line">                   mTextView.setText(<span class="string">"十三"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main3);</span><br><span class="line">        mTextView = findViewById(R.id.text);</span><br><span class="line">        mButton = findViewById(R.id.button);</span><br><span class="line">        mButton.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.button) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Message message = <span class="keyword">new</span> Message();</span><br><span class="line">                    message.what = CHANGE_TEXT;</span><br><span class="line">                    handler.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrqyersbg30au073t9g.gif" alt=""><br><br></div></p><h2 id="Handler-的深入学习"><a href="#Handler-的深入学习" class="headerlink" title="Handler 的深入学习"></a>Handler 的深入学习</h2><p>&emsp;&emsp;我们仅仅会调用 Api 还是不够的，我们得透过现象看本质，去学习它的原理。我们知道线程本来是没有 Looper 的，而 Handler 创建的时候会采用当前线程的 Looper 构造消息循环系统，所以这就要求我们使用 Handler 的时候就要为线程创建了 Looper ，这里可能有同学会有疑问了，没有吧，我平时为什么直接创建 Handler 就可以愉快地使用了？——实际上，我们平时可以直接在主线程中创建 Handler ，是因为主线程已经帮我们初始化好了 Looper，我们通过源码就可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">        <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">        <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">        EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">        <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在 21 行代码处，我们可以看到调用 Looper.prepareMainLooper() 方法，而我们进一步跟进去，源码声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;prepareMainLooper() 方法中又调用 prepare 方法，ThreadLocal 是一个线程内部的数据存储类，而我们的 Looper 显然则是通过它存取在线程中。在 prepare 方法中先对 sThreadLocal 进行判断是否存在 Looper 对象，没有则创建 Looper 对象，这样一来主线程中便有了 Looper 对象，这也是我们默认能够直接使用 Handler 的原因。</p><p>&emsp;&emsp;可能到这里，有同学和十三一样有个疑问了，那我要在子线程中创建 Handler 而不是主线程中创建，会怎么样？那么我会告诉你，你可能连第一关都过不了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先在 11 行代码处，先通过 Looper.myLooper() 方法获得 Looper，这个方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果这时候没有 Looper 那么就会抛出异常，这也就是在没有 Looper 的子线程中创建 Handler 会引发程序异常的原因。那么我们应该怎么解决呢，其实办法从我们上面的分析也能想到，那就是调用 Looper.prepare 方法就可以了。</p><p>&emsp;&emsp;创建 Handler 后我们接下来当然就是发送消息了，通常我们都是 sendMessage 方法进行消息的发送，那我们下面就一起来看看这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从 sendMessage 方法一直调用到 sendMessageAtTime 这个方法里来，其实 Handler 发送消息的过程就是向 MessageQueue 消息队列中插入消息，在代码 22 行处我们可以看到调用这个 enqueueMessage 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先把 msg.target = this，也就是指当前发送消息的这个 Handler，然后把当前这个消息插入到消息队列中去。<br><br></p><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>&emsp;&emsp;前面说到 Handler 发送消息后就是把消息插入到消息队列中，下面我们来看看插入消息的 enqueueMessage 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">                <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">                <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;MessageQueue 实际上就是通过单链表来维护消息列表的，从上面的操作主要也还是对单链表进行插入操作，在代码 43 行处，调用 next 方法，它会从消息列表中取出消息并把消息从列表移除，我们去看它的源码时可以看到它是个无限循环的方法，如果消息队列中有新插入的消息，next 方法就会返回这条消息并把这条消息从单链表中移除，总不可能一直占着茅坑吧！而如果消息队列中没有消息，那么 next 方法就会一直阻塞，直到等待新插入消息到来，至于 next 方法的源码就不贴了，有点长…<br><br></p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>&emsp;&emsp;MessageQueue 消息队列存储着消息，而负责处理我们的消息便是 Looper，它非常勤奋，一直不停地从 MessageQueue 中查看是否有新消息，如果有就立即处理否则一直等待新消息。不知道大家有没有感觉到它怎么和上边的 next 方法有点相似啊，这样一说还真的是，我们耐着心思继续往下看，Looper 有个 loop 方法，当调用 loop 方法后消息循环系统才会工作起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> start = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> time = end - start;</span><br><span class="line">                <span class="keyword">if</span> (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Dispatch took "</span> + time + <span class="string">"ms on "</span></span><br><span class="line">                            + Thread.currentThread().getName() + <span class="string">", h="</span> +</span><br><span class="line">                            msg.target + <span class="string">" cb="</span> + msg.callback + <span class="string">" msg="</span> + msg.what);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们看到 loop 方法同样也是一个死循环，在代码 14 行处我们能看到它调用了 MessageQueue 的 next 方法，并在下一行对它进行是否为空的判断，跳出这个死循环就看这个 MessageQueue 的 next 为 null，否则 loop 方法就会一直循环下去。</p><p>&emsp;&emsp;也就是说，loop 方法会调用 MessageQueue 的 next 方法来获取最新的消息，前面我们分析到 next 方法是一个阻塞操作，当没有消息的时候它会一直阻塞着，而这样也会导致我们的 loop 方法同样也会一直阻塞着；而假如这时候有了新消息，那么 loop 也会处理这条消息，真的是难兄难弟阿！</p><p>&emsp;&emsp;那么 Looper 怎么来处理消息呢？在 36 行处 msg.target.dispatchMessage(msg)，这里的 msg.target 就是我们前面说过的发送这条消息的 Handler 对象，然后发送的消息又交给这个 Handler 对象的 dispatchMessage 方法来进行处理，那我们就来看看这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先对 msg.callback 进行非空的判断，不为空就调用 handleCallback 方法进行对消息的处理，否则就调用 handleMessage 方法处理消息，那我们首先来看看这个 handleMessage 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到注释，其实这个 handleMessage 也就是我们平时重写的方法，通常我们在里面进行对消息的判断并执行 UI 操作。</p><p>&emsp;&emsp;而这个 handleCallback 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Message 的 callback 其实是一个 Runnable 对象，我们知道通过 Handler 的 post 方法也可以在子线程中对 UI 进行访问，看看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line"><span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;它调用了 sendMessageDelayed 方法发送消息，那么参数里的这个 getPostMessage 又是什么呢？我们接着往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看到代码 3 行处，它把 Runnable 对象转换成了转换成了消息，然后我们再看回 handleCallback 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原来这里的 message.callback 就是 Handler 的 post 方法所传递的 Runnable 参数，然后调用了一开始传入的 Runnable 对象的 run() 方法。这样和我们在 handleMessage 方法中操作 UI 的原理是一样的。<br><br></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>&emsp;&emsp;到这里，这篇 Handler 的学习记录就到尾声了，说实话是真的累，有同学说十三你瞎忙什么呀，网上大把这些文章。我想说看别人文章那只是看，要想把知识变成自己的，还是需要自己手把手把完整流程走一遍，不信你看看，走一遍你就发现自己会遇到很多问题。</p><p>技术参考文献：<br>【郭霖大神的博客】<a href="http://blog.csdn.net/guolin_blog/article/details/9991569" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/9991569</a><br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，感觉最近肉欲好强，好想吃烤肉、各种肉肉…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrrgva5qj30j60crgot.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在上些篇学习记录里我们提到了 AsyncTask 并且算是把它的大体源码流程走了一遍，实际上 AsyncTask 封装了 Thread 和 Handler，正是它完好的封装使得我们无需关心太多。这里来个传送门：&lt;a href=&quot;https://binshao.site/2018/08/10/AsyncTask/&quot;&gt;AsyncTask 的深入理解&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://Binshao.site/categories/Android/"/>
    
    
      <category term="Handler" scheme="http://Binshao.site/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之命令模式</title>
    <link href="http://Binshao.site/2018/08/11/Command/"/>
    <id>http://Binshao.site/2018/08/11/Command/</id>
    <published>2018-08-11T12:26:58.000Z</published>
    <updated>2019-01-24T08:31:58.491Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，看来真的要开始关注养生这方面了，感觉视力蹭蹭地往下掉阿，我还年轻阿…</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve188862tj30u00k0ace.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;不知道大家是否和十三一样是个 FPS 游戏爱好者，还记得《使命召唤4》里有一关普莱斯和麦克米兰一起狙击扎卡耶夫的情景吗？十三最喜欢这种潜入剧情的关卡了，个人感觉使命召唤现代战争(4，6和8代)剧情是最经典，最好看的。大家感兴趣的话可以去看看，这里推荐一个 B 站的 Up 主叫做哲学的石头，他的打法真的是一路凶残到底，喜欢这种这么凶猛的玩家，希望各位读者不嫌十三罗嗦老谈使命召唤，嘿嘿！</p><p>&emsp;&emsp;好了，废话就不多说了，其实那个狙击的场景可以用到我们设计模式中的命令模式，那么下面我们就来看看什么是命令模式。<br><br></p><h2 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式(Command)"></a>命令模式(Command)</h2><p>&emsp;&emsp;命令模式将一个请求封装为一个对象，从而使得我们可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p><p>命令模式中的角色和职责：</p><ul><li><p>Command：抽象命令类，用来声明执行操作的接口.</p></li><li><p>ConcreteCommand：将一个接收者对象绑定于一个动作，调用接收者相应的操作以实现 Execute.</p></li><li><p>Receiver：接收者，用来实施执行一个请求相关的操作.</p></li><li><p>Invoker：请求者，要求该命令执行这个请求.</p></li></ul><p>&emsp;&emsp;理论概念一大堆，大家是不是都一脸懵逼，下面我们一起来写个小例子看看命令模式的简单应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先是 Command 类，用来声明执行操作的接口并且里面提供了 execute 的方法，执行的意思。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着就是 ConcreteCommand 类，它实现了 Command 接口并重写方法，它还持有了 Receiver 类的引用，也就是持有接受者这个类的引用，然后在重写的方法里调用 receiver 的 action 方法，那么这个 Receiver 类是什么，下面我们来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狙击手：收到，目标已击毙.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Receiver 好比于是命令的执行者，它知道如何去执行命令相关的操作。这里回到使命召唤里的剧情，当我们收到上级的命令，我们作为战士肯定要去执行这个任务，那么有命令的执行者，就有命令的发起者，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoke</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoke</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"指挥部：目标对象已出现，立即击毙.."</span>);</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个命令的发起者也就是我们的 Invoke 这个类，它发起了请求并命令执行这个请求。就好比于上级指挥部下达命令，下级战士收到命令并去执行命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Command c = <span class="keyword">new</span> ConcreteCommand(<span class="keyword">new</span> Receiver());</span><br><span class="line">        Invoke i = <span class="keyword">new</span> Invoke(c);</span><br><span class="line">        i.call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们来完成客户端代码，首先我们创建一个具体命令对象并设定它的接收者，接着我们再创建一个请求者并要求执行请求，同样由于它持有我们的 Command 类的引用，所以下达的命令是能够到达命令执行者那里去的，这样执行者收到命令就可以去执行命令了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果:</span><br><span class="line">指挥部：目标对象已出现，立即击毙..</span><br><span class="line">狙击手：收到，目标已击毙..</span><br></pre></td></tr></table></figure><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面我们同样还是来总结下：</p><p>常见场景：</p><ul><li><p>数据库事务机制的底层实现.</p></li><li><p>命令的撤销和恢复.</p></li><li><p>Struts 2 中 action 的调用过程.</p></li></ul><p>&emsp;&emsp;命令模式能比较容易地设计一个命令队列，这里我们的例子其实还是可以用一个容器来装载我们的一系列命令。其实命令模式还可以实现对请求的撤销和恢复，并且每添加新的具体命令类是不会影响其他的类。</p><p>&emsp;&emsp;不过平时在我们开发中，感觉命令模式我们不太用得到，这里的学习记录就偷个懒吧，好了，养生去了……<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，看来真的要开始关注养生这方面了，感觉视力蹭蹭地往下掉阿，我还年轻阿…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fve188862tj30u00k0ace.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://Binshao.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="命令模式" scheme="http://Binshao.site/tags/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>AsyncTask 的深入理解</title>
    <link href="http://Binshao.site/2018/08/10/AsyncTask/"/>
    <id>http://Binshao.site/2018/08/10/AsyncTask/</id>
    <published>2018-08-10T12:26:33.000Z</published>
    <updated>2019-01-24T08:24:57.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，眨眼间人生中最后一个暑假期已经过去了一大半了，最是时间留不住…我想老朋友了、我想出去玩、我还想去见见那个谁。</p></blockquote><p>&emsp;&emsp;上篇学习记录中我们记录了 Android 中线程及线程池 的应用，一脸懵逼不知道什么情况的同学请到传送门接受安检： <a href="https://binshao.site/2018/08/08/ThreadPool/">Android 中的线程池</a> 。</p><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve0njtkorj30zk0jz78c.jpg" alt=""></div></p><p>&emsp;&emsp;主线程更新是个老生常谈的话题，当我们通过线程去执行耗时的任务，并在操作完成后可能还要更新 UI，为了方便开发者在子线程对 UI 进行操作， Google 则提供如 Handler、AsyncTask 等工具帮助我们解决这个问题。那么今天我们下面我们来看看 AsyncTask。<br><br></p><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>&emsp;&emsp;对于 AsyncTask，各位老司机肯定都用烂了…它是一种轻量级的异步任务类，借助 AsyncTask 我们可以很轻松地从子线程切换到主线程，更加方便地执行后台耗时任务和切换到主线程中去访问 UI，但是不太建议在 AsyncTask 中进行太过耗时的后台任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的源码中我们可以看到 AsyncTask 是一个抽象类，并且它提供了 三 个泛型参数，所以我们要使用它都是创建个子类去继承它，并指定 三个泛型参数，它们的含义分别如下：</p><ul><li><p>Params：在执行时 AsyncTask 需要传入的参数，用于在后台任务中使用.</p></li><li><p>Progress：表示后台任务执行进度的类型.</p></li><li><p>Result：当任务执行完成后，返回结果的类型.</p></li></ul><p>这些参数在平时开发中，我们可以根据自己的实际需要去定义类型，假设我们都不需要可以用 Void 代替。</p><p>接下来我们来看看 AsyncTask 提供的一些重要方法，如下：</p><ul><li><p>onPreExecute()：这个方法在主线程中执行，它会在后台任务执行之前调用，用于在界面进行一些初始化的操作.</p></li><li><p>doInBackground(Params…params)：这个方法会在子线程中运行，它会在 onPreExecute()<br>方法执行后运行，通常我们会在这里进行耗时任务的执行，任务执行完成后通过 return 把结果返回。<code>注意，我们不能在此进行 UI 操作，我们可以通过调用 PublishProgress 方法更新任务的进度.</code></p></li><li><p>onProgressUpdate(Progress..values)：这个方法在主线程中执行，在上一步中我们通过调用 PublishProgress 方法后，它就会被调用，也就是说当后台任务的执行进度发生改变的时候它就会被调用，我们可以在这里进行 UI 更新操作.</p></li><li><p>onPostExecute(Result result)：当后台任务执行完成后并且通过 return 返回结果时，这个方法就会被调用，我们可以利用返回结果进行 UI 更新操作.</p></li></ul><p>&emsp;&emsp;理论概念说了一大堆，还是要动手实践下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line">    <span class="keyword">private</span> SeekBar seekBar;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main2);</span><br><span class="line">        button = findViewById(R.id.button);</span><br><span class="line">        textView = findViewById(R.id.textView);</span><br><span class="line">        seekBar = findViewById(R.id.seekBar);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                MyAsyncTask myTask = <span class="keyword">new</span> MyAsyncTask(textView, seekBar);</span><br><span class="line">                Toast.makeText(Main2Activity.<span class="keyword">this</span>, <span class="string">"开始下载"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                myTask.execute(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView txt;</span><br><span class="line">    <span class="keyword">private</span> SeekBar seekBar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAsyncTask</span><span class="params">(TextView txt, SeekBar seekBar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.txt = txt;</span><br><span class="line">        <span class="keyword">this</span>.seekBar = seekBar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DelayOperator dop = <span class="keyword">new</span> DelayOperator();</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">10</span>; i &lt;= <span class="number">1000</span>; i += <span class="number">10</span>) &#123;</span><br><span class="line">                dop.delay();</span><br><span class="line">                publishProgress(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + params[<span class="number">0</span>].intValue() + <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            txt.setText(<span class="string">"拼命下载ing..."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = values[<span class="number">0</span>];</span><br><span class="line">        seekBar.setProgress(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayOperator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的布局很简单，十三就不贴布局代码了。下面我们来看看效果演示：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve0vaclzug30b807fwfk.gif" alt=""></div></p><p>&emsp;&emsp;好了，到这里我们的 AsyncTask 的基本使用就介绍完了，AsyncTask 除了上面十三列举这些方法外，还提供了 onCancelled() 方法，当我们取消后台任务的时候就会被调用，既然任务被取消了，那么 onPostExecute() 最后也是不会被调用的了。</p><p>&emsp;&emsp;会使用 Api 还不满足的，我们得要深入去理解它的内在，不要浮于表面。阅读源码过程很痛苦，如同盲人摸象，摸不着底细。我们可以借助大神老司机的力量，自己拿好纸笔一遍遍去撸，去梳理，别无他法。<br><br></p><h2 id="深入理解-AsyncTask"><a href="#深入理解-AsyncTask" class="headerlink" title="深入理解 AsyncTask"></a>深入理解 AsyncTask</h2><p>&emsp;&emsp;在上面的例子中我们调用 AsyncTask 的 execute 方法，它便开始执行。那么我们就从 execute 这个方法入手，我们来看看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当我们平时调用 execute 方法执行 AsyncTask 时，它又去调用了 executeOnExecutor，那我们接着往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">            Params... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">                <span class="keyword">case</span> RUNNING:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                            + <span class="string">" the task is already running."</span>);</span><br><span class="line">                <span class="keyword">case</span> FINISHED:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                            + <span class="string">" the task has already been executed "</span></span><br><span class="line">                            + <span class="string">"(a task can be executed only once)"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">        onPreExecute();</span><br><span class="line"></span><br><span class="line">        mWorker.mParams = params;</span><br><span class="line">        exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在第 15 行中，先对 AsyncTask 的状态设置为 RUNNING，我们从上面的 switch 语句对状态进行判断可以看出，一个 AsyncTask 对象只能运行一次，否则就会报异常。接着我们又可以看到熟悉的 onPreExecute() 方法被调用了，而我们知道这个方法是在主线程中执行的，可以做些初始化操作。往下从第 19 行开始，我们可能又有疑问了，这又是什么，没见过？我们不妨拿出纸笔，做下个小标记，然后我们接着跟进去这个 mWorker：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">        Params[] mParams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们一路追踪找到这个 WorkerRunnable 这个类，我们可以看到它实现了 Callable 接口，我们知道实现 Callable 并且重写 call 方法可以用来实现多线程，那么看到这里好像没下文了？似乎我们的线索断了，别急，我们继续往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">        mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">            ? getMainHandler()</span><br><span class="line">            : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line"></span><br><span class="line">        mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">                Result result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                    <span class="comment">//noinspection unchecked</span></span><br><span class="line">                    result = doInBackground(mParams);</span><br><span class="line">                    Binder.flushPendingCommands();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                    mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">throw</span> tr;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    postResult(result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    postResultIfNotInvoked(get());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                    postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原来在我们的 AsyncTask 的构造方法里，mWorker 在这里进行的初始化，我们从上面知道 WorkerRunnable 它实现了 Callable 接口，并且在这里实现了 call 方法。在 call 方法中首先将 mTaskInvoked 设为 true，它表示的是当前任务被调用过了，接着在 13 行中又调用了 doInBackground(mParams) 方法执行任务，任务完成后在 19 行调用了 postResult(result) 把结果投送出去，这里先不贴它的源码，因为下面我们还要用到。</p><p>&emsp;&emsp;然后我们往 25 行看到 mFuture 并且看到 FutureTask 这个类，那我们跟进去看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的源码我们可以看到，FutureTask 它实现了 Runnable 和 Future 这两个接口，回到上面的源码中，我们发现 mWorker(WorkerRunnable) 作为参数传进了 FutureTask 中，到这里我们对于前面莫名出现的变量应该有个印象了，拿出纸笔记录下后，回到我们最开始的起点，这里我们再贴出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">            Params... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">                <span class="keyword">case</span> RUNNING:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                            + <span class="string">" the task is already running."</span>);</span><br><span class="line">                <span class="keyword">case</span> FINISHED:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                            + <span class="string">" the task has already been executed "</span></span><br><span class="line">                            + <span class="string">"(a task can be executed only once)"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">        onPreExecute();</span><br><span class="line"></span><br><span class="line">        mWorker.mParams = params;</span><br><span class="line">        exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们继续看到上次我们看到的 19 行，这里把 AsyncTask 的 params 参数传给 mWorker，通过前面的构造方法中我们已经分析到 mWorker 也就是 WorkerRunnable 又作为参数传给 FutrueTask 里面，我们拿出纸看看前面做下的记录，果然没错。接着往下，在 20 行中调用了 exec 的 execute 方法，并把我们的 mFuture(FutureTask) 作为参数传了进去，到这里我们就看完了这个方法，可这里有个疑问，这个 exec 是干什么的，这里我们做个记号后，回到我们最开始的源头 execute，我们再贴出源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们看到它调用了 executeOnExecutor 这个方法，<code>注意看第一个参数 sDefaultExecutor</code>原来上面我们疑惑的 exec 是这里传进来的参数 sDefaultExecutor，那我们就继续往下顺藤摸瓜看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">        Runnable mActive;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">            mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        r.run();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        scheduleNext();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduleNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们一路追踪找到这个静态类 SerialExecutor，实际上它是一个串行的线程池，内部维护着一个任务队列，在 9 行中我们看到之前调用的 execute 这个方法，我们之前的调用源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec.execute(mFuture);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们回过头来看看 mFuture(FutureTask) 它作为参数传入，也就是说 FutureTask 对象在这里充当了 Runnable 的作用，并把它加入到这里的 mTasks 中排队，最后不管是否有无任务，在 15 行中都会去调用 scheduleNext() 这个方法，而它的源码声明在 24 行，它会从 mTasks 中去取出任务并交给 THREAD_POOL_EXECUTOR 去执行任务。从这里我们知道原来，SerialExecutor 这个线程池是用来给任务排队的，而去执行任务的是 THREAD_POOL_EXECUTOR 这个线程池，并且默认情况下，AsyncTask 是串行执行的。</p><p>&emsp;&emsp;接着我们看 13 行中，前面我们说到 FutureTask 充当了 Runnable 的作用，所以这里实际上就是调用了它的 run 方法，这里我们来说下 FutureTask 因为实现了 Runnable 和 Future 这两个接口(前面的源码也能看到)，所以它可以包装 Runnale 和 Callable，可以直接调用线程执行(.run 方法)。</p><p>&emsp;&emsp;而我们在分析前面的构造方法的时候，mWorker(WorkerRunnable) 作为了参数传给 mFuture(FutureTask)，所以这里最终调用的是 mWorker(WorkerRunnable) 中的 call 方法，这里我们把之前的源码再贴出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">                Result result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                    <span class="comment">//noinspection unchecked</span></span><br><span class="line">                    result = doInBackground(mParams);</span><br><span class="line">                    Binder.flushPendingCommands();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                    mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">throw</span> tr;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    postResult(result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们就来看看这个 postResult(result) 这个方法，它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</span><br><span class="line">        message.sendToTarget();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的源码我们可以看到，它在方法里通过创建 Message 并通过这里的 Handler 发送消息，它这个 Handler 是通过 getHandler() 这个方法来获得，而在 getHandler() 它又去创建了 InternalHandler 我们接下来去看看这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                    <span class="comment">// There is only one result</span></span><br><span class="line">                    result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                    result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在 switch 语句中在接收到 MESSAGE_POST_RESULT 消息后就会调用 finish 方法，来看看这个方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">            onCancelled(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onPostExecute(result);</span><br><span class="line">        &#125;</span><br><span class="line">        mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假如当前我们取消任务，那么就会调用 onCancelled(result)，看到这里是不是感觉很熟悉，没错，我们通过这个方法得到了任务执行后的结果，而如果我们取消任务就不会调用这个方法了，这也验证了我们前面所说的。</p><p>&emsp;&emsp;那么再回过头来，我们去看看如果接受到的是 MESSAGE_POST_PROGRESS 这个消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                    <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说当我们调用的是 publishProgress(Progress… values) 这个方法对任务进度进行更新，那么它就会发送这个 MESSAGE_POST_PROGRESS 消息，当接受到消息后又去调用 onProgressUpdate 这个方法，这也就是我们平时在使用 AsyncTask 的时候，当我们去调用 publishProgress 方法后，onProgressUpdate 方法就会被调用的原因。<br><br></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>&emsp;&emsp;到这里，我们的 AsyncTask 的源码流程就学习到这里了，说实话，十三在看这块源码的时候不知道来来回回看了多少遍，写这篇记录的时候更是写了好几天，也许是十三太菜了…</p><p>&emsp;&emsp;真的还是感谢大神老司机的博客文章，有着老司机的带路也不至于像无头苍蝇到处乱窜，所以我们也要借助好老司机前辈的力量，拿出纸笔该记的记，该写的写。</p><p>技术参考文献：<br>【鸿洋大神的博客文章：Android AsyncTask 源码解析】<br>【Android进阶之光 刘望舒】PS：听说皇叔 9 月份又出新书了！<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，眨眼间人生中最后一个暑假期已经过去了一大半了，最是时间留不住…我想老朋友了、我想出去玩、我还想去见见那个谁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;上篇学习记录中我们记录了 Android 中线程及线程池 的应用，一脸懵逼不知道什么情况的同学请到传送门接受安检： &lt;a href=&quot;https://binshao.site/2018/08/08/ThreadPool/&quot;&gt;Android 中的线程池&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://Binshao.site/categories/Android/"/>
    
    
      <category term="AsyncTask" scheme="http://Binshao.site/tags/AsyncTask/"/>
    
  </entry>
  
  <entry>
    <title>从富豪财产身家中学习状态模式</title>
    <link href="http://Binshao.site/2018/08/09/State/"/>
    <id>http://Binshao.site/2018/08/09/State/</id>
    <published>2018-08-09T12:26:21.000Z</published>
    <updated>2019-01-24T09:17:42.714Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，准是假期这段时间以来，十三疯狂修炼，以至于走火入魔……</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve0denhl5j30zk0nndkl.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;十三，你瞎嚷嚷着什么阿，说人话！好吧，其实是身体不太舒服，人有点伤风感冒是正常，可十三自认为生活十分规律，也没有经常去浪，这好端端地怎么会头晕脑重呢？直到后来，十三才明白了，原来这是一段奇遇！</p><p>&emsp;&emsp;其实事情是这样的，话说那天十三去找大夫，给大夫说了病情后，便替十三把脉等一套流程走了下来，过后大夫意味深长地对十三说：“小伙子怕是没少撸？”，十三第一反应便是，哎呀，我去！怕不是遇见道友了？便回话：“大夫，好眼力！”，许是这句话打开了他的话匣子，一下子便和十三说起他辉煌的过去，也是挺能唠叨的一个人。后来，十三通过聊天才知道，原来人家之前还是个亿万富翁。出身医学世家又精通医术，可偏偏又对商业感兴趣，从赚的第一桶金 100 万开始，再到 1000 万，再到成为后来的亿万富翁。</p><p>&emsp;&emsp;“做的啥生意，这么牛？”，十三心想。生意人眼睛就是毒辣，一下子就能看到十三在想些啥，做的是房地产这方面的，原来是房地产，怪不得。这时，十三又忍不住地说：等下，咱们用代码演示下这个过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setage</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age == <span class="number">23</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"23岁成为百万富翁.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age == <span class="number">26</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"26岁成为千万富翁.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age == <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"30岁成为亿万富翁.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"年龄段："</span> + <span class="keyword">this</span>.getage() + <span class="string">"岁是异次元.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码非常简单，我们在 doSomething() 这个方法里就能看到大夫他的成名发家史。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line"></span><br><span class="line">        person.setage(23);</span><br><span class="line">        person.doSomething();</span><br><span class="line"></span><br><span class="line">        person.setage(26);</span><br><span class="line">        person.doSomething();</span><br><span class="line"></span><br><span class="line">        person.setage(30);</span><br><span class="line">        person.doSomething();</span><br><span class="line"></span><br><span class="line">        person.setage(8);</span><br><span class="line">        person.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果:</span><br><span class="line">23岁成为百万富翁..</span><br><span class="line">26岁成为千万富翁..</span><br><span class="line">30岁成为亿万富翁..</span><br><span class="line">年龄段8岁是异次元..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们在 main 方法里实例化 Person 类对象，然后传入 age 参数并调用 doSomething() 方法，接着我们传入的 age 参数便会在方法里面进行判断，然后根据不同的年龄段输出不同的语句，这个我们从运行结果中也能看到。可是我们回过头来想想，我们的这个方法似乎有点长，它有很多的判断分支，且不说它十分臃肿，单单是它承担的责任太大了，每个年龄阶段的财富状态都需要通过它来改变这实际上是非常糟糕的，这显然违背了<code>单一职责原则。</code>而且假如我们想要想要更改它的财富状态，那么就要在这个方法里面进行修改，这又违背了<code>开放-封闭原则，</code>那么我们还有没有其他办法呢？<br><br></p><h2 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式(State)"></a>状态模式(State)</h2><p>&emsp;&emsp;状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况，把状态的判断逻辑转移到表示不同状态的一系列类当中，这样可以把复杂的判断逻辑简化。当然了，假如我们的状态判断很简单，就没有必要使用状态模式了。</p><p>状态模式中的角色和职责：</p><ul><li><p>Context(环境类)：环境类中维护一个 State 对象，它定义了当前的状态.</p></li><li><p>State(抽象状态类)：它定义一个接口以封装和 Context 的特定状态相关行为.</p></li><li><p>ConcreteState(具体状态类)：每一个子类封装了一个状态对应的行为.</p></li></ul><p>&emsp;&emsp;好，那么下面我们就用状态模式改写上面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们先定义了个抽象状态类，并且里面提供了抽象方法 doSomething() 方法，这个方法是交给每个不同状态的子类来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MState</span> <span class="keyword">extends</span> <span class="title">State</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"23岁成为百万富翁.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KState</span> <span class="keyword">extends</span> <span class="title">State</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"26岁成为亿万富翁.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NState</span> <span class="keyword">extends</span> <span class="title">State</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"30岁成为亿万富翁.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoState</span> <span class="keyword">extends</span> <span class="title">State</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"所在年龄段为异次元.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的四个具体状态类分别实现了 四 种不同的状态，这样一来，每个类承担了相关的责任，做到了代码责任的分解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age == <span class="number">23</span>) &#123;</span><br><span class="line">            state = <span class="keyword">new</span> MState();</span><br><span class="line">            state.doSomething();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age == <span class="number">26</span>) &#123;</span><br><span class="line">            state = <span class="keyword">new</span> KState();</span><br><span class="line">            state.doSomething();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age == <span class="number">30</span>) &#123;</span><br><span class="line">            state = <span class="keyword">new</span> NState();</span><br><span class="line">            state.doSomething();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state = <span class="keyword">new</span> NoState();</span><br><span class="line">            state.doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们的 Person 类就要进行改写了，首先它先持有 State 类对象的引用，在 doSomething() 方法里才能根据传入不同的参数实例化不同的状态类，并调用不同状态类的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">23岁成为百万富翁..</span><br><span class="line">26岁成为千万富翁..</span><br><span class="line">30岁成为亿万富翁..</span><br><span class="line">年龄段8岁是异次元..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;客户端代码和之前是一样的，这里就不重复贴出来了，可以看到我们程序运行起来结果还是和之前一样，不同的状态由不同的状态类负责，这样即使我们想要添加状态只需要添加状态类就可以了，符合开放-封闭原则。可是这里我们的判断分支依旧还是存在，这玩意看着有点烦，我们想点法子把它去掉？走你！<br><br></p><h2 id="最终版"><a href="#最终版" class="headerlink" title="最终版"></a>最终版</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state = <span class="keyword">new</span> MState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.doSomething(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 复位</span></span><br><span class="line">        state = <span class="keyword">new</span> MState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先对 Person 类进行改写，首先我们先对 Person 类添加构造方法，并把我们的财富状态设置为”百万富翁”，然后再调用状态类的 doSomething 方法，注意这里我们传参是 this，也就是 Person 类对象参数，这里这样做是因为，我们可以根据传入参数对象的状态调用不同的状态对象方法。接着又把状态再一次初始化为”百万富翁”这个状态，这里为什么要怎么做呢？这个我们待会后面再讲。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Person person)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们先定义个抽象状态类，并且提供了抽象 doSomething 方法，当然了，这个方法它是交给我们不同状态的子类去实现，同时这个方法还需要传入 Person 类的参数，这个我们上面也说了，到时候我们可以根据它的 person 参数，调用它的 getAge() 函数，得到年龄段状态并去调用不同状态的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person.getAge() == <span class="number">23</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"23岁成为百万富翁.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            person.setState(<span class="keyword">new</span> KState());</span><br><span class="line">            person.doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person.getAge() == <span class="number">26</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"26岁成为千万富翁.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            person.setState(<span class="keyword">new</span> NState());</span><br><span class="line">            person.doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person.getAge() == <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"30岁成为亿万富翁.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            person.setState(<span class="keyword">new</span> NoState());</span><br><span class="line">            person.doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"所在时间段:"</span> + person.getHour() + <span class="string">"为异次元.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里 四 个状态类分别对应不同状态，重要的是之前我们的逻辑判断也放在了这些具体状态类里，它的判断工作流程大致如下：首先会先对传入的 person 参数调用它的年龄方法，看看这个年龄是否符合要求，不符合则把它交给下一个状态类去处理。由于我们的 Person 类(Context 角色)中持有抽象状态(State 角色)的引用，所以每次它都能找到具体的状态类并交给它处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        person.setage(<span class="number">23</span>);</span><br><span class="line">        person.doSomething();</span><br><span class="line"></span><br><span class="line">        person.setage(<span class="number">26</span>);</span><br><span class="line">        person.doSomething();</span><br><span class="line"></span><br><span class="line">        person.setage(<span class="number">30</span>);</span><br><span class="line">        person.doSomething();</span><br><span class="line"></span><br><span class="line">        person.setage(<span class="number">8</span>);</span><br><span class="line">        person.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果:</span><br><span class="line">23岁成为百万富翁..</span><br><span class="line">26岁成为千万富翁..</span><br><span class="line">30岁成为亿万富翁..</span><br><span class="line">年龄段8岁是异次元..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过运行程序我们可以看到结果和我们之前是一样的，而我们这一次的写法相比于前两次的写法无疑是好了不少，这里还有个小细节要注意下的是，还记得前面的 Person 类里的 doSomething() 方法吗？为什么还要又一次初始化状态为百万富翁，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.doSomething(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 复位</span></span><br><span class="line">        state = <span class="keyword">new</span> MState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其实是这样的，当我们的状态从百万富翁到亿万富翁，那么这最后一次的状态就是为亿万富翁的状态，假如这时候我们输入年龄段为 23 ，那么它对应的财富状态是百万富翁，可当前这个财富状态已经是指向了亿万富翁这个状态，而它就会从亿万富翁开始判断，不符合条件就交给下一个状态类处理，而下个状态类是异次元，所以也不符合，而这个状态就会一直处于这个状态，所以我们每次调用这个方法，都需要将状态进行复位，每次都从头开始，这也就是我们之前初始化状态为百万富翁这个状态的原因。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;到这里我们的学习记录也接近尾声了，那么国际惯例，我们来简单地总结一下：</p><p>&emsp;&emsp;状态模式的好处在于它将不同状态的行为分割开来，将特定的状态相关的行为都放入一个对象中，不同状态的代码都放入在每个不同的状态子类中，所以我们可以直接通过定义新的状态子类就可以很容易增加新的状态，这样不仅容易扩展和维护，还减少了相互之间的耦合。当一个对象的行为取决于它的状态，并且它需要在运行时根据不同的状态改变不同的行为时，我们应该考虑使用状态模式。<br><br></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>&emsp;&emsp;没想到这次出来真是涨见识了，不仅学到知识还能听到牛逼故事，可是问题就来了，你个亿万富翁那么有雅致来替人看病，体验生活？原来，后来他娶了个貌美如花的老婆，成功地从亿万富翁变成了百万富翁……现在也只能收点诊费，过过小康生活这样子。可十三转而一想，我连一百万都没有，那岂不是…<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，准是假期这段时间以来，十三疯狂修炼，以至于走火入魔……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fve0denhl5j30zk0nndkl.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://Binshao.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="状态模式" scheme="http://Binshao.site/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android 中的线程池</title>
    <link href="http://Binshao.site/2018/08/08/ThreadPool/"/>
    <id>http://Binshao.site/2018/08/08/ThreadPool/</id>
    <published>2018-08-08T12:26:02.000Z</published>
    <updated>2019-01-24T09:21:14.039Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如今这个时代，没有网络真的是难受，这不，十三今天家里就给停网了，后来才知道电信那边在搞事…说到网络，从 Android 3.0 开始，系统就要求网络等耗时操作必须在子线程中进行，否则就会抛出异常。这么做的原因是为了避免把耗时操作放在主线程中引起阻塞从而造成 ANR，给用户第一的感觉就是：卡出了翔…从这里可以看到多线程在我们应用开发中占据着十分重要的位置，今天十三也来总结下自己学习多线程这方面的内容，当然了都是些基础内容（勿喷），输入倒逼内容输出，做个学习记录。</p></blockquote><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvdzrdexgej30zj0ki786.jpg" alt=""><br><br></div></p><h2 id="线程的几种写法"><a href="#线程的几种写法" class="headerlink" title="线程的几种写法"></a>线程的几种写法</h2><p>&emsp;&emsp;还记得刚入门 Java 语法的那时候吗，嘿嘿。下面我们快速来回顾下线程的编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, I am thread!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread mThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一种写法是继承 Thread 类，并重写 run() 方法，这个 run() 方法就是线程要去执行的任务，最后可别忘了要调用线程对象的 start() 方法来开启线程，十三还记得在初学 Java 的时候，没有调用这个 start() 方法，后来就一直在找问题究竟是出在哪里，哈哈！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, I am runnable!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mainclass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable mRunnable = <span class="keyword">new</span> Runnable();</span><br><span class="line">        Thread mThread = <span class="keyword">new</span> Thread(mRunnable);</span><br><span class="line">        mThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是第二种写法实现 Runnable 接口并实现 run 方法，再把该实现接口的实例对象传给 Thread 对象并调用 start 方法。<br>以上这两种写法是我们平时最常用的写法，当然还有其他的实现方式，这里十三就不写出来了。</p><p>&emsp;&emsp;我们都知道在操作系统中，线程是操作系统调度的最小单元，在我们平时编程中会使用线程异步来处理任务，但是每个线程的创建和销毁都是要一定的开销，假如我们频繁地创建和销毁线程，显然会消耗大量的资源，这时候正确的做法是采用线程池，但是在了解线程池前首先我们得要先知道阻塞队列的相关内容。<br><br></p><h2 id="阻塞队列-BlockingQueue"><a href="#阻塞队列-BlockingQueue" class="headerlink" title="阻塞队列(BlockingQueue)"></a>阻塞队列(BlockingQueue)</h2><p>&emsp;&emsp;阻塞队列经常用于生产者消费者的场景，生产者是往队列里添加元素的线程，而消费者是从队列里取元素的线程，阻塞队列就是生产者添加元素的容器，消费者则从容器里取元素。</p><p>Java 中提供 7 个阻塞队列：</p><ol><li><p>ArrayBlockingQueue：由数组结构组成的有界阻塞队列.</p></li><li><p>LinkedBlockingQueue：由链表结构组成的有界阻塞队列.</p></li><li><p>PriorityBlockingQueue：支持优先级排序的无界阻塞队列.</p></li><li><p>DelayQueue：使用优先级队列实现的无界阻塞队列.</p></li><li><p>SynchronousQueue：不存储元素的阻塞队列.</p></li><li><p>LinkedTransferQueue：由链表结构组成的无界阻塞队列.</p></li><li><p>LinkedBlockingDeque：由链表结构组成的双向阻塞队列.</p></li></ol><p>&emsp;&emsp;这里十三也只是简单介绍下阻塞队列，关于这方面的具体内容大家还是去看看更详细的介绍，如《Java编程思想》、《Java并发编程实战》等书籍。<br><br></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>&emsp;&emsp;Android 中的线程池源自于 Java 中的 Executor，Executor 是一个接口，而线程池的真正实现是由 ThreadPoolExecutor 来实现的，它是线程池的核心实现类，它提供了一系列参数来配置线程池，我们可以通过不同的参数创建不同的线程池，下面我们通过它的构造方法来看看所需参数的含义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><ul><li><p>corePoolSize：线程池的核心线程数，默认情况核心线程会在线程池中一直存活，如果当前运行的线程数少于核心线程数，就会创建新线程处理任务；如果等于或多于核心线程数，则不会再创建线程.</p></li><li><p>maximumPoolSize：线程池所能容纳的最大线程数，当活动线程数等于这个数值，后续的新任务将会被阻塞，就好比于我们买车票，一辆车满人就是没座位了，只等等下一班车，这个很好理解.</p></li><li><p>keepAliveTime：非核心线程闲置的超时时间，超过这个时长，非核心线程就会被回收。我们也可以通过设置 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设置为 true，那么核心线程超过时长同样被回收.</p></li><li><p>TimeUnit：用于指定 keepAliveTime 参数的时间单位，这是一个枚举，常用的有 TimeUnit.MILLISECONDS、TimeUnit.SECONDS 以及 TimeUnit.MINUTES 等，分别对应毫秒、秒、分钟.</p></li><li><p>workQueue：任务队列，通过线程池的 execute 方法提交的 Runnable 对象会存储在这个参数中.</p></li><li><p>threadFactory：线程工厂，为线程池提供创建新线程的功能.</p></li><li><p>RejectedExecutionHandler：饱和策略，这是当任务队列和线程池都满了所采取的应对策略，默认是 AbordPolicy，表示无法处理新任务，并抛出异常.</p></li></ul><p>接下来我们来看看线程池工作的大致流程：</p><ol><li><p>如果线程池中的线程数量少于核心线程数量，那就创建核心线程并执行任务.</p></li><li><p>如果线程池中的线程数量多于核心线程数量，那么任务就会被插入到任务队列中排队并等待执行.</p></li><li><p>假如在上一步中，我们的任务无法插入到任务队列中，则说明任务队列满人啦，如果这个时候线程数量没有超过线程池容纳的最大值，那么这时候会启动非核心线程来执行任务；如果线程数量已经达到容纳最大值，那么无法处理任务并会抛出异常通知调用者.<br><br></p></li></ol><h2 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h2><p>&emsp;&emsp;上面我们说过了<code>可以通过不同的参数创建不同的线程池，</code>在 Android 中通常有四种线程池比较常用，它们分别是 FixedThreadPool、CachedThreadPool、SingleThreadExecutor 和 ScheduledThreadPool，实际上它们都直接或间接地通过配置 ThreadPoolExecutor 来实现的，下面我们分别来介绍它们，这里我们还以下面这个界面为例子，界面上分别有四个按钮相对应我们四个线程池，按下按钮线程池便会创建线程执行任务。</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvdzx1wlvrj308w08zt8o.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">简单UI界面<br><br></div></p><h2 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h2><p>&emsp;&emsp;它是一个线程数量固定的线程池，我们可以通过 Executors 类提供的 newFixedThreadPool 方法创建，我们可以跟进去看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到它的核心线程数和最大线程数都被设置为创建 FixedThreadPool 的参数 nThreads，也就是说它只有核心线程并且数量还是固定的，并且没有非核心线程。keepAliveTime 设置为 0L 表示它并没有超时机制，接着我们还看到它的任务队列采用了 LinkedBlockingQueue，这也是前面我们简单介绍阻塞队列的原因，它是没有大小限制的。我们来看看怎么用，放码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">        mTextView = findViewById(R.id.content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            service.execute(command());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">command</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                sb.append(Thread.currentThread().getName()).append(<span class="string">"\n"</span>);</span><br><span class="line">                show();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mTextView.setText(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;来看下运行效果演示：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvdzzmpaaig30d90gp4ax.gif" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">FixedThreadPool</div></p><p>&emsp;&emsp;为了方便我们观察，我在 command 方法中故意让线程睡个 1 秒钟，从演示效果中我们可以看到每次执行任务都是三个线程在工作，因为我们在创建就指定它的 nThreads 参数为 3。<br>我们再来梳理一遍工作流程：首先当我们执行 execute 方法时，如果当前活动线程数量少于核心线程数就创建核心线程并执行任务；如果大于核心线程数，那么不好意思，则把这些任务添加到任务队列中，而它的任务队列是 LinkedBlockingQueue ，当线程池中有空闲线程就会从任务队列中取出任务并执行。</p><p>&emsp;&emsp;由于 FixedThreadPool 中只有核心线程并且这些核心线程并不会被回收，所以它能够快速响应外界的请求，另外它的任务队列是没有大小限制的。<br><br></p><h2 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h2><p>&emsp;&emsp;CachedThreadPool 同样也是通过 Executors 类提供的 newFixedThreadPool 方法创建，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到它的核心线程数为 0，但是非核心线程却是任意大，它是一种线程数量不定的线程池。此外，它的空闲线程的超时时长为 60 秒，超过便要回收闲置线程。而它的任务队列是 SynchronousQueue 阻塞队列，上面我们提到这种队列是不存储元素的，换句话来说我们是没有办法把任务添加到队列里的，而又因为线程池的线程可以是无限制，所以每次提交任务都会有线程去执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            service.execute(command());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样来个演示：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve01huhg2g30d90gpdls.gif" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">CachedThreadPool</div></p><p>&emsp;&emsp;由于这种线程池的任务队列 SynchronousQueue 相当于空集合，因为它不存储任何元素，所以一有任务就立即执行任务，这个从演示结果中我们可以看到，几乎是我们一点击按钮，它的工作就已经完成了。<br><br></p><h2 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h2><p>&emsp;&emsp;Single，Single 一看就是单身的，事实上这是一个只有单个工作线程的线程池，它的创建源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到它的核心线程数和非核心线程数都为 1，所以它相比于其他线程池还是很孤独的，此外它的任务队列也是采用 LinkedBlockingQueue 这个阻塞队列。由于只有一个核心线程，所有的任务都在同一个线程中按顺序执行，放码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">singleThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            service.execute(command());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve06o3b8og30d90gp18v.gif" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">SingleThreadExecutor</div></p><p>&emsp;&emsp;从演示结果中我们看到，线程在执行任务的时候是一个个执行的，散发着单身狗的清香有木有…<br><br></p><h2 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h2><p>&emsp;&emsp;这个线程池则是用来实现定时或周期性任务的线程池，类似于定时器，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">             DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里咱就不具体说了，累了…..来看看演示效果吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduledThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 每隔 1 秒执行</span></span><br><span class="line"><span class="comment">//        service.scheduleWithFixedDelay(getRunnable(), 1, 1, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="comment">// 1 秒后执行一次</span></span><br><span class="line"><span class="comment">//        service.schedule(getRunnable(), 1, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="comment">// 延迟 1 秒后，每隔 1 秒执行一次</span></span><br><span class="line">        service.scheduleAtFixedRate(command(), <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve095czdkg30d90gph10.gif" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">ScheduledThreadPool</div></p><p>&emsp;&emsp;好了，到这里我们这篇线程池的学习记录就到尾声了，由于篇幅所限，一些如队列等详细的细节可以去查阅其他资料。走了走了，最后问下有没有女孩子愿意和十三出去玩呀！<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如今这个时代，没有网络真的是难受，这不，十三今天家里就给停网了，后来才知道电信那边在搞事…说到网络，从 Android 3.0 开始，系统就要求网络等耗时操作必须在子线程中进行，否则就会抛出异常。这么做的原因是为了避免把耗时操作放在主线程中引起阻塞从而造成 ANR，给用户第一的感觉就是：卡出了翔…从这里可以看到多线程在我们应用开发中占据着十分重要的位置，今天十三也来总结下自己学习多线程这方面的内容，当然了都是些基础内容（勿喷），输入倒逼内容输出，做个学习记录。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://Binshao.site/categories/Android/"/>
    
    
      <category term="线程池" scheme="http://Binshao.site/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>从组装枪械中学习模板方法模式</title>
    <link href="http://Binshao.site/2018/08/07/TemplateMethob/"/>
    <id>http://Binshao.site/2018/08/07/TemplateMethob/</id>
    <published>2018-08-07T12:25:41.000Z</published>
    <updated>2019-01-24T09:20:00.759Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，依旧三伏天（热）中渡劫，我给自己算过一卦：还是要好好修炼，否则在劫难逃…</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvdzm6hfa6j30zk0jn43s.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;今天还是我们设计模式系列的学习记录，十三记得之前说过自己是个枪械迷，不知道大家是否也是和十三一样有这个爱好呢？那么今天我们自己就来体验下造枪，废话不多说，放码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Gun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeBarrel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeBody</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeMagazine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们定义了个抽象类，我们都知道枪可不止一种型号，有 M4 和 AK 等等，所以具体的制造方法我们交给具体的子类去完成制造，定义的三个抽象方法也分别交给子类去实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M4</span> <span class="keyword">extends</span> <span class="title">Gun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBarrel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4：组装枪管.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4：组装枪身.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMagazine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4：组装弹夹.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AK</span> <span class="keyword">extends</span> <span class="title">Gun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBarrel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AK：组装枪管.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AK：组装枪身.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMagazine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AK：组装弹夹.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里两个类代码非常简单，我也就不再罗嗦了，也就是继承刚刚定义的抽象类并实现抽象方法。那我们接下来就来开始制造枪械：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Gun M4 = <span class="keyword">new</span> M4();</span><br><span class="line">        M4.makeBarrel();</span><br><span class="line">        M4.makeBody();</span><br><span class="line">        M4.makeMagazine();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------军火库--------"</span>);</span><br><span class="line"></span><br><span class="line">        Gun AK = <span class="keyword">new</span> AK();</span><br><span class="line">        AK.makeBarrel();</span><br><span class="line">        AK.makeBody();</span><br><span class="line">        AK.makeMagazine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">M4：组装枪管..</span><br><span class="line">M4：组装枪身..</span><br><span class="line">M4：组装弹夹..</span><br><span class="line">--------军火库--------</span><br><span class="line">AK：组装枪管..</span><br><span class="line">AK：组装枪身..</span><br><span class="line">AK：组装弹夹..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样我们就完成了两支经典名枪的制造，但是不知道大家发现了没有，不管我们制造哪种型号的枪械，它的制造过程大体上是相似的，比如枪械有枪管、枪身和弹夹组成，假如我现在还想再制造其他型号的枪械，岂不是又要写多这些重复语句，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M911.makeBarrel();</span><br><span class="line">M911.makeBody();</span><br><span class="line">M911.makeMagazine();</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这样一写下来，我们将会写出大量的重复语句，而且既然我们前面使用了继承，并且这个继承是有意义的，那所有的重复的代码都应该要写到父类里去，让父类称为子类的模板，这时候就该猪脚上场了。<br><br></p><h2 id="模板方法模式-TemplateMethob"><a href="#模板方法模式-TemplateMethob" class="headerlink" title="模板方法模式 (TemplateMethob)"></a>模板方法模式 (TemplateMethob)</h2><p>&emsp;&emsp;模板方法模式是行为模式之一，它把具有特定步骤算法中的某些必要的处理委让给抽象方法，通过子类继承对抽象方法的不同实现改变整个算法的行为。</p><p>&emsp;&emsp;那我们来使用模板方法模式对我们刚刚的例子进行改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Gun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeBarrel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeBody</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeMagazine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.makeBarrel();</span><br><span class="line">        <span class="keyword">this</span>.makeBody();</span><br><span class="line">        <span class="keyword">this</span>.makeMagazine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改我们的抽象类，抽象方法依旧还是交给子类去实现，因为每种不同型号的枪械外观等属性都不相同，只能由具体子类去实现制造，除此之外，我们添加了个 make() 方法，而这个方法里则调用的是我们定义的抽象方法，这个方法就是模板方法了，它给出我们造枪的逻辑骨架，而逻辑的组成则是由相应的抽象去操作，也就是上面那三个抽象方法，在这里它推迟到子类去实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Gun M4 = <span class="keyword">new</span> M4();</span><br><span class="line">        M4.make();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------军火库--------"</span>);</span><br><span class="line"></span><br><span class="line">        Gun AK = <span class="keyword">new</span> AK();</span><br><span class="line">        AK.make();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">M4：组装枪管..</span><br><span class="line">M4：组装枪身..</span><br><span class="line">M4：组装弹夹..</span><br><span class="line">--------军火库--------</span><br><span class="line">AK：组装枪管..</span><br><span class="line">AK：组装枪身..</span><br><span class="line">AK：组装弹夹..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样我们来运行，也能得到相同的结果，相比于之前的写法，我们不再需要写大量的重复语句了，而这里事实上，它调用的 make 方法还是由它自身完成的。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;例行惯例，在最后我们来做个简单总结：</p><p>&emsp;&emsp;当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。模板方法模式是通过把不变行为写到父类中，避免了子类再去编写重复代码。</p><p>应用场景：</p><ul><li><p>具有统一的操作步骤或操作过程.</p></li><li><p>具有不同操作细节.</p></li><li><p>存在多个具有同样操作步骤的应用场景，但某些具体的操作细节却不相同.</p></li></ul><p>&emsp;&emsp;好了，今天设计模式的学习就记录到这了，说实话这个模板方法模式还是挺简单的，不过也可能是我比较菜吧，只看到短浅的层次…避暑去了。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，依旧三伏天（热）中渡劫，我给自己算过一卦：还是要好好修炼，否则在劫难逃…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fvdzm6hfa6j30zk0jn43s.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://Binshao.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="模板方法模式" scheme="http://Binshao.site/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之迭代模式</title>
    <link href="http://Binshao.site/2018/07/31/Iterator/"/>
    <id>http://Binshao.site/2018/07/31/Iterator/</id>
    <published>2018-07-31T12:25:23.000Z</published>
    <updated>2019-01-24T08:52:40.751Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，今天工地上的砖格外烫手，天气依旧还是那么炎热，我不想努力了……</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvdzdi4zj8j30zk0nqdkl.jpg" alt=""></div></p><a id="more"></a><p><br>    </p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;热热热，热到爆炸，热到融化，这天气真的一年比一年还热，受不了啊！好吧，咱还是要学习的，今天我们学习迭代器模式，废话不多说，开搞！</p><p>&emsp;&emsp;首先我们先以一个小例子开头，十三喜欢看书，平时没事会去淘书找好书来读，会把要找的书写成个书单，书单上有书籍的详细信息等，那么就用代码演示下这个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String ISBN;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String iSBN, String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        ISBN = iSBN;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getISBN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ISBN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setISBN</span><span class="params">(String iSBN)</span> </span>&#123;</span><br><span class="line">        ISBN = iSBN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ISBN:"</span> + ISBN + <span class="string">" BookName:"</span> + name + <span class="string">"  price:"</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里是对应书籍这个类，它的代码非常简单，都是些字段属性及构造函数，以及还有个打印书籍详细的方法，这个待会我们要用到，接着继续往下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; bookList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bookList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        bookList.add(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bookIndex = bookList.indexOf(book);</span><br><span class="line">        bookList.remove(bookIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= bookList.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookList.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来的这个类就相当于是个书单类，因为书单肯定不止一本书，所以这里为了方便我们就用容器来装载我们的书籍，可以看到它分别有添加和删除两个方法，那么我们怎么知道书单共有多少本书籍呢？没错，第一反应就是遍历就可以了，所以这里最后我们在容器类里添加了可访问的遍历方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BookList list = <span class="keyword">new</span> BookList();</span><br><span class="line"></span><br><span class="line">        Book bookA = <span class="keyword">new</span> Book(<span class="string">"01013"</span>, <span class="string">"Java从入门到放弃"</span>, <span class="number">90</span>);</span><br><span class="line">        Book bookB = <span class="keyword">new</span> Book(<span class="string">"01039"</span>, <span class="string">"颈椎病康复指南"</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        list.addBook(bookA);</span><br><span class="line">        list.addBook(bookB);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(list.hasNext()) &#123;</span><br><span class="line">            Book book = list.getNext();</span><br><span class="line">            book.display();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们就可以来看看我们书单，首先实例化两本书籍对象，并把它们添加到容器中，接着我们进行遍历得到书单信息，在我们的书单容器中都已经提供可访问的遍历方法，所以我们可以直接调用就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 输出结果：</span><br><span class="line">ISBN:01013 BookName:Java从入门到放弃  price:90.0</span><br><span class="line">ISBN:01039 BookName:颈椎病康复指南    price:60.0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过打印信息，我们可以看到书单上详细情况，但是我们回过头来想想，在我们的容器类中，我们提供了书籍的添加和删除等本身具有的方法，不仅如此，我们还在容器类中提供遍历访问的功能，容器类承担了太多的功能，不太符合我们的单一职责原则，那我们就来改写看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; bookList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bookList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        bookList.add(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bookIndex = bookList.indexOf(book);</span><br><span class="line">        bookList.remove(bookIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然你说我书单类太多功能，那我就不提供遍历方法了，我直接返回我整个书单容器给你，你自己遍历去吧！书单类怒了…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BookList list = <span class="keyword">new</span> BookList();</span><br><span class="line"></span><br><span class="line">        Book bookA = <span class="keyword">new</span> Book(<span class="string">"01013"</span>, <span class="string">"Java从入门到放弃"</span>, <span class="number">90</span>);</span><br><span class="line">        Book bookB = <span class="keyword">new</span> Book(<span class="string">"01039"</span>, <span class="string">"颈椎病康复指南"</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        list.addBook(bookA);</span><br><span class="line">        list.addBook(bookB);</span><br><span class="line"></span><br><span class="line">        List&lt;Book&gt; bookData = list.getBookList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookData.size(); i++) &#123;</span><br><span class="line">            Book book = bookData.get(i);</span><br><span class="line">            book.display();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样一来，不再提供遍历方法我们只好自己实现遍历，虽说这样书单类减少了不少功能，但是这样做的话则直接暴露数据细节给外部。是时候了，该出大招了。<br><br></p><h2 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式 (Iterator)"></a>迭代器模式 (Iterator)</h2><p>&emsp;&emsp;<code>迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</code>简单来说，迭代器模式提供一种有效的方法，可以屏蔽聚集对象集合的容器类的实现细节，还能对容器内包含的对象元素按顺序进行有效的遍历访问。</p><p>迭代器模式的角色和职责 ：</p><ul><li><p>Iterator (迭代器接口)：该接口必须定义实现迭代功能的最小定义方法集.</p></li><li><p>ConcreteIterator (迭代器实现类)：迭代器接口的实现类，可以根据具体情况加以实现.</p></li><li><p>Aggregate (容器接口)：抽象聚集类.</p></li><li><p>ConcreteAggregate (容器实现类)：具体聚集类，继承 Aggregate.</p></li></ul><p>&emsp;&emsp;那我们来使用迭代器模式对我们刚刚的例子进行改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; bookList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bookList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        bookList.add(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bookIndex = bookList.indexOf(book);</span><br><span class="line">        bookList.remove(bookIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= bookList.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> bookList.get(index++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里为了方便，我们直接使用 JDK 提供的类库 Iterator，你没看错，事实上 Java 已经把这个模式做在语言里了。这里我们定义了个匿名类 Itr 它实现了 Iterator 这个接口，之所以为匿名内部类是因为我们要实现遍历得需要容器的详细信息，也就是我们书单容器的大小等，不然我们从何做起？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BookList list = <span class="keyword">new</span> BookList();</span><br><span class="line"></span><br><span class="line">        Book bookA = <span class="keyword">new</span> Book(<span class="string">"01013"</span>, <span class="string">"Java从入门到放弃"</span>, <span class="number">90</span>);</span><br><span class="line">        Book bookB = <span class="keyword">new</span> Book(<span class="string">"01039"</span>, <span class="string">"颈椎病康复指南"</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        list.addBook(bookA);</span><br><span class="line">        list.addBook(bookB);</span><br><span class="line"></span><br><span class="line">        Iterator iter = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            Book book = (Book) iter.next();</span><br><span class="line">            book.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 输出结果：</span><br><span class="line">ISBN:01013 BookName:Java从入门到放弃  price:90.0</span><br><span class="line">ISBN:01039 BookName:颈椎病康复指南    price:60.0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样我们来运行，也能得到相同的结果，相比于之前的写法，我们让容器只需实现本身的基本功能，把迭代功能委让给外部类实现，符合类的设计原则，隐藏容器的实现细节。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;最后我们来简单总结下。</p><p>&emsp;&emsp;当需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，就应该考虑用迭代器模式，总地来说，迭代器模式模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。平时我们访问数组、集合等数据时，事实上，许多语言都对它进行过封装，这使得迭代器模式不太经常使用，但是我们却可能天天都在用。</p><p>&emsp;&emsp;来一个以前刚学 Java 时学到 Iterator 的 Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">"One"</span>);</span><br><span class="line">        list.add(<span class="string">"#"</span>);</span><br><span class="line">        list.add(<span class="string">"Two"</span>);</span><br><span class="line">        list.add(<span class="string">"#"</span>);</span><br><span class="line">        list.add(<span class="string">"Three"</span>);</span><br><span class="line">        list.add(<span class="string">"#"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * iterator()方法</span></span><br><span class="line"><span class="comment">         * 该方法会返回一个Iterator的实现类实例，用于遍历当前集合</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * Iterator在java.util包下</span></span><br><span class="line"><span class="comment">         * 其是一个接口，定义了遍历器应有的方法</span></span><br><span class="line"><span class="comment">         * 不同的集合返回的Iterator不都是一个子类实现</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 迭代器的使用方式:先问后拿</span></span><br><span class="line"><span class="comment">         * 问:boolean hashNext()</span></span><br><span class="line"><span class="comment">         *   该方法询问迭代器当前集合是否还有元素</span></span><br><span class="line"><span class="comment">         * 拿:Object next()</span></span><br><span class="line"><span class="comment">         *   该方法会获取当前元素</span></span><br><span class="line"><span class="comment">         * 迭代器的迭代方法是为while循环量身定制的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Iterator it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())<span class="comment">//集合中是否还有下一个元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            String element = (String)it.next();<span class="comment">//有就将其取出</span></span><br><span class="line">            <span class="comment">//需要造型，因为当前集合没有添加泛型，只要有泛型，此处迭代不需加String</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在迭代器迭代的过程中，我们不能通过集合的增删等操作来改变该集合的元素数量！</span></span><br><span class="line"><span class="comment">             * 否则会引发迭代异常！若想删除迭代出来的元素，只能通过Iterator</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(element);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"#"</span>.equals(element))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//list.remove(element);//不可以</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 迭代器的remove()方法可以将刚刚获取的元素1从集合中删除，但是不能</span></span><br><span class="line"><span class="comment">                 * 重复调用两次!</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                it.remove();<span class="comment">//删除当前位置的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">One</span><br><span class="line">#</span><br><span class="line">Two</span><br><span class="line">#</span><br><span class="line">Three</span><br><span class="line">#</span><br><span class="line">[One, Two, Three]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;哈哈，怀恋。想起当初啃 Java 语法的时候，有时候想过为什么会这样，怎么搞的呢？到后来随着学习的深入，或许之前的疑惑也慢慢拨开了，同时也发现自己不懂的也就越多……<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，今天工地上的砖格外烫手，天气依旧还是那么炎热，我不想努力了……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fvdzdi4zj8j30zk0nqdkl.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://Binshao.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="迭代模式" scheme="http://Binshao.site/tags/%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>从请假流程来学习责任链模式</title>
    <link href="http://Binshao.site/2018/07/29/Responsibility/"/>
    <id>http://Binshao.site/2018/07/29/Responsibility/</id>
    <published>2018-07-29T06:45:14.000Z</published>
    <updated>2019-01-24T09:07:55.146Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，越来越感觉自身知识技能缺乏性了，真的是学的越多发现自己不懂的也就也多，稍不注意就在原地踏步，不管怎样还是要酷，Skr ~</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhscoll3lj30j60cs0ug.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;不知道大家都有请过假吗？不管是在校园还是职场上，请假似乎很常见，我们都知道请假可不是你想请就能请的，还得经过上司同意才能请假，要是请假天数太长，上司还得上报他的上司进行审批，可见这假不是想请就请的。</p><p>&emsp;&emsp;实际上，这请假流程类似于我们设计模式中的责任链模式，那么什么是责任链模式呢？今天就来学习记录一下。<br><br></p><h2 id="责任链模式-Chain-of-Responsibility"><a href="#责任链模式-Chain-of-Responsibility" class="headerlink" title="责任链模式 (Chain of Responsibility)"></a>责任链模式 (Chain of Responsibility)</h2><p>&emsp;&emsp;使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为之。</p><p>&emsp;&emsp;那么下面我们就以请假为例演示下责任链模式的简单应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaveRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leaveDays;</span><br><span class="line">    <span class="keyword">private</span> String reason;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeaveRequest</span><span class="params">(String name, <span class="keyword">int</span> leaveDays, String reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.leaveDays = leaveDays;</span><br><span class="line">        <span class="keyword">this</span>.reason = reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeaveDays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leaveDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeaveDays</span><span class="params">(<span class="keyword">int</span> leaveDays)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leaveDays = leaveDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReason</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReason</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.reason = reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们定义了请假请求类，它分别有请假人姓名、天数以及理由三个字段属性，还有构造方法和对应的 get/set 方法，代码非常简单，我们继续往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="comment">// 责任链上的后继对象</span></span><br><span class="line">    <span class="keyword">protected</span> Leader nextLeader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leader</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设定责任链上的后继对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLeader</span><span class="params">(Leader nextLeader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextLeader = nextLeader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求的核心业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(LeaveRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着我们定义了个抽象领导类，之所以是抽象类是因为公司不止一个领导，小领导没权处理的就交给上一级的领导来处理，所以这里我们定义了指定上一级领导的方法 setNextLeader，而每个领导的权力范围都不相同，就交给我们子类来做，就有了抽象方法 handleRequest。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(LeaveRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getLeaveDays() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"员工："</span> + request.getName() + <span class="string">"请假, 天数"</span> + </span><br><span class="line">        request.getLeaveDays() + <span class="string">", 请假理由："</span> + request.getReason());</span><br><span class="line">            System.out.println(<span class="string">"主任："</span> + <span class="keyword">this</span>.name + <span class="string">"，批准！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.nextLeader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.nextLeader.handleRequest(request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们底层的小领导上线了，它继承了 Leader 这个抽象类并重写了抽象方法，在抽象方法里处理请假这个流程，我们可以看到，只要请假天数不超过 3 天，他有权可以审批我们请假要求，如果是超过 3 天，那他就无权处理，只能交给上一级领导来审批，那么来看看他的上一级领导：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(LeaveRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getLeaveDays() &lt; <span class="number">7</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"员工："</span> + request.getName() + <span class="string">"请假, 天数"</span> + </span><br><span class="line">        request.getLeaveDays() + <span class="string">", 请假理由："</span> + request.getReason());</span><br><span class="line">            System.out.println(<span class="string">"经理："</span> + <span class="keyword">this</span>.name + <span class="string">"，批准！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.nextLeader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.nextLeader.handleRequest(request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到这个类与上面的类几乎是相同的，没什么区别，区别在于他能审批不超过 7 天的请假要求，否则他也只能上报上一级领导。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneraManager</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GeneraManager</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(LeaveRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getLeaveDays() &lt; <span class="number">14</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"员工："</span> + request.getName() + <span class="string">"请假, 天数"</span> + </span><br><span class="line">        request.getLeaveDays() + <span class="string">", 请假理由："</span> + request.getReason());</span><br><span class="line">            System.out.println(<span class="string">"总经理："</span> + <span class="keyword">this</span>.name + <span class="string">"，批准！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"员工："</span> + request.getName() + <span class="string">"请假, 天数"</span> + </span><br><span class="line">                    request.getLeaveDays() + <span class="string">", 请假理由："</span> + request.getReason());</span><br><span class="line">            System.out.println(<span class="string">"总经理：没钱哪都去不了，给我好好写代码去！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后一级大 Boss…下面立即开始我们的请假流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Leader director = <span class="keyword">new</span> Director(<span class="string">"张三"</span>);</span><br><span class="line">        Leader manager = <span class="keyword">new</span> Manager(<span class="string">"李四"</span>);</span><br><span class="line">        Leader generaManager = <span class="keyword">new</span> GeneraManager(<span class="string">"王五"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组织责任链关系</span></span><br><span class="line">        director.setNextLeader(manager);</span><br><span class="line">        manager.setNextLeader(generaManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始请假</span></span><br><span class="line">        LeaveRequest request = <span class="keyword">new</span> LeaveRequest(<span class="string">"十三"</span>, <span class="number">14</span>, <span class="string">"世界那么大，我想去看看..."</span>);</span><br><span class="line">        director.handleRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">员工：十三请假, 天数14, 请假理由：世界那么大，我想去看看...</span><br><span class="line">总经理：没钱哪都去不了，给我好好写代码去！</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们先把相关领导类实例化后再指定责任链关系，然后我们再进行请求，这样我们请求的客户端并不知道是哪一个对象处理这个请求，但是我们能得到相关的处理结果，这样系统的更改可以在不影响客户端的情况下动态分配责任。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;最后我们来简单总结下。</p><p>&emsp;&emsp;责任链模式中最关键的是客户提交请求时，请求是沿着链进行传递直到有一个具体处理对象负责处理它，这样一来，请求者不需要关心是哪个处理对象在处理，我只要等请求被处理即可。责任链还简化了对象之间的连接，它们只需要<code>保持一个指向其后继者的引用，</code>这和数据结构的链表是非常相似的，无需保持后继者的引用，这就大大<code>降低耦合度。</code>不仅如此，我们可以<code>随时随地增加或修改请求的结构，</code>当然了，假如我们没有正确配置责任链，可能请求到了链尾都没有被处理。</p><p>常见场景：</p><ul><li><p>Java 中的异常机制就是一种责任链模式，一个 try 可以对应多个 catch，当一个 catch 不匹配类型，则自动跳转到下一个 catch.</p></li><li><p>JS 中事件的冒泡和捕获机制.</p></li></ul><p><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，越来越感觉自身知识技能缺乏性了，真的是学的越多发现自己不懂的也就也多，稍不注意就在原地踏步，不管怎样还是要酷，Skr ~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fzhscoll3lj30j60cs0ug.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://Binshao.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="责任链模式" scheme="http://Binshao.site/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>程序猿相亲记</title>
    <link href="http://Binshao.site/2018/07/27/Mediator/"/>
    <id>http://Binshao.site/2018/07/27/Mediator/</id>
    <published>2018-07-27T06:44:43.000Z</published>
    <updated>2019-01-24T08:53:22.272Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，最近又把使命召唤的现代战争系列重看了一遍，剧情是真的赞，个人认为使命召唤 4、6、8 这三部曲实在是经典阿，还有荣誉勋章这款游戏也不错，青春阿……    </p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrxikj4hj30j60ctwhw.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;不知道有小伙伴是否也是枪械迷，推荐大家去 B 站搜索 Up 主哲学的石头，他的打法真的一路凶残到底，枪法意识都很好，看了他的视频再去看其他视频，感觉其他 Up 主的视频都没劲，当然对我而言是这样的，太厉害了。</p><p>&emsp;&emsp;好了，题外话就说到这里了，今天咱们继续来学习中介者设计模式，说到中介者十三第一个想到就是房产中介了，可是老是提房也是烦，主要是穷的一笔……好，那咱就换个婚姻中介，卧槽……你这真的是猝不及防。当然了，也不是什么都一上来就是找中介什么的，什么都得自己先试试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> condition;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.condition = condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCondition</span><span class="params">(<span class="keyword">int</span> condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.condition = condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person person)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们定义了个抽象 Person 类，它有字段属性及构造方法，还提供了个抽象的找对象方法…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">(String name, <span class="keyword">int</span> condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, condition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Man) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Sorry,我不是Gay.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getCondition() == person.getCondition()) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"和"</span> + person.getName() + <span class="string">"般配"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"和"</span> + person.getName() + <span class="string">"无缘"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着这个 Man 类继承自 Person 类，它实现了 Person 类里的抽象方法，在这个抽象方法里首先判断传入的 person 参数是否是 Man 实例，因为总不可能两个大老爷们在一起吧，当然你喜欢吧…接着再往下判断两人之间是否条件相等，这就好比于对方是不是对你有好感，考虑你条件够不够好等等，太复杂了这个，就不多说了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Woman</span><span class="params">(String name, <span class="keyword">int</span> condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, condition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Woman) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Sorry,我不是Gay.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getCondition() == person.getCondition()) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"和"</span> + person.getName() + <span class="string">"般配"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"和"</span> + person.getName() + <span class="string">"无缘"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然有 Man 类，那肯定就有 Woman 类了，这里和上面是一样的，就不再多介绍了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person shisan = <span class="keyword">new</span> Man(<span class="string">"十三"</span>, <span class="number">9</span>);</span><br><span class="line">        Person p = <span class="keyword">new</span> Man(<span class="string">"路人乙"</span>, <span class="number">10</span>);</span><br><span class="line">        Person ll = <span class="keyword">new</span> Woman(<span class="string">"LL"</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        shisan.getPartner(ll);</span><br><span class="line">        p.getPartner(ll);</span><br><span class="line">        p.getPartner(shisan);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">十三和LL般配</span><br><span class="line">路人乙和LL无缘</span><br><span class="line">Sorry,我不是Gay..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;好了，通过结果我们可以看到十三真幸运，他和 LL 牵手成功，而路人乙则悲催了点，但是不论结果是怎样，它们互相之间是认识的，这就要求对象之间需要其他对象，好比于十三如果不认识 LL 他最后怎么可能牵手成功呢。</p><p>&emsp;&emsp;站在我们开发中来讲，类与类之间的联系就比较紧密，对象之间的相互连接降低其可复用性，可能会使得一个对象在没有其他对象的支持下而罢工。迪米特原则中提到：如果两个类不必互相通信，那么这两个类就不应该发生直接的相互作用。好，那我们应该要怎么来做呢？<br><br></p><h2 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式 (Mediator)"></a>中介者模式 (Mediator)</h2><p>&emsp;&emsp;中介者模式是行为模式之一，用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>&emsp;&emsp;那么许多像路人乙那样被狠心拒绝，或者平时没有什么机会接触异性，那怎么办呢？于是，可能看到这个商机，各种婚姻中介强势崛起。通过这些中介对象，每个具体对象就不再同其他对象打交道了，而是通过这些中介者对象与另外一个对象发生相互作用。那么我们在上面例子的基础上再改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> condition;</span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person2</span><span class="params">(String name, <span class="keyword">int</span> condition, Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.condition = condition;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mediator <span class="title">getMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMediator</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCondition</span><span class="params">(<span class="keyword">int</span> condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.condition = condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person2 person)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们这个抽象 Person 类，它增加对中介者 Mediator 的应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man2</span> <span class="keyword">extends</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man2</span><span class="params">(String name, <span class="keyword">int</span> condition, Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, condition, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person2 person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getMediator().setMan(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.getMediator().getPartner(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman2</span> <span class="keyword">extends</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Woman2</span><span class="params">(String name, <span class="keyword">int</span> condition, Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, condition, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person2 person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getMediator().setWoman(<span class="keyword">this</span>); </span><br><span class="line">        <span class="keyword">this</span>.getMediator().getPartner(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里就相当于两个具体的 Person 类，分别实现了抽象找对象方法，但是这里找对象可是通过中介介绍找的对象，这个过程我们可以这样理解，因为抽象父类 Person 持有中介者 Mediator 类的引用，所以我们这里的 getPartner 找对象方法，先是通过父类找到当前这个中介，然后注册相关会员信息，注册好后中介就会帮我们找对象了，当我们调用找对象的方法，实际上是中介者帮我们找的对象，那么下面我来看看这个中介者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Man2 man;</span><br><span class="line">    <span class="keyword">private</span> Woman2 woman;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMan</span><span class="params">(Man2 man)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.man = man;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWoman</span><span class="params">(Woman2 woman)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.woman = woman;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person2 person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Man2) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setMan((Man2) person);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setWoman((Woman2) person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (man.getCondition() == woman.getCondition()) &#123;</span><br><span class="line">            System.out.println(man.getName() + <span class="string">"和"</span> + woman.getName() + <span class="string">"般配"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(man.getName() + <span class="string">"和"</span> + woman.getName() + <span class="string">"无缘"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到这个中介者类它持有对具体对象的引用，这个很好理解，就相当于你要我帮你找对象，你得要把你相关信息告诉我，我好给你找对吧。再之后中介就会帮我们筛选出合适的对象，就会通知我们出来见个面？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Mediator mediator = <span class="keyword">new</span> Mediator();</span><br><span class="line"></span><br><span class="line">        Person2 man = <span class="keyword">new</span> Man2(<span class="string">"路人乙"</span>, <span class="number">3</span>, mediator);</span><br><span class="line">        Person2 woMan = <span class="keyword">new</span> Woman2(<span class="string">"小芳"</span>, <span class="number">3</span>, mediator);</span><br><span class="line">        man.getPartner(woMan);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//运行结果：</span><br><span class="line">路人乙和小芳般配</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样，路人乙就通过中介找到他的真爱，祝福他们。我们回过头来看下，相比于我们第一次的写法，路人乙和小芳它们本来之间就是不认识的，就类似于两个人类之间可以不用进行通信。但是它们都通过中介认识接触到对方，这样的话，我们的类与类之间就不需要知道其他对象了，只需要和中介者打交道就可以了。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;最后我们来简单总结下。</p><p>&emsp;&emsp;中介者的出现减少了各个类之间的耦合，明确类之间的相互关系；中介者模式将原来相互依存的多对多的类关系简化为中介者类与其他关联类一对多的关系，当其中一个类修改时也不影响其他关联类。</p><p>&emsp;&emsp;后来，据路人乙说其实那天下午他去和中介介绍的女孩见面了，等他到场时才发现对方是个男的？一问才知道，对方也是被安排出来见面的，只是没想对方竟然是个男的，没过多一会儿，原来是中介搞错了……因为生意太过于火爆，这将使得中介者会变得相当复杂繁忙。</p><p>这都不是重点，重点是路人乙发现对方竟然也是程序员，哈哈，这下可好，两人一见如故，那天他们整整聊了一下午的技术，走时，他们还互相交换了微信……<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，最近又把使命召唤的现代战争系列重看了一遍，剧情是真的赞，个人认为使命召唤 4、6、8 这三部曲实在是经典阿，还有荣誉勋章这款游戏也不错，青春阿……    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrxikj4hj30j60ctwhw.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://Binshao.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="中介者模式" scheme="http://Binshao.site/tags/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="http://Binshao.site/2018/07/25/Adapter/"/>
    <id>http://Binshao.site/2018/07/25/Adapter/</id>
    <published>2018-07-25T06:44:21.000Z</published>
    <updated>2019-01-24T08:21:48.850Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hi，我是十三，也许是我昨天求雨的诚意感动了老天还是受台风气压影响，还真是下了场雨舒服阿，哈哈…</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhr0ldb9yj30j60csn0x.jpg" alt=""></div></p><a id="more"></a>    <p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;不知道大家在日常生活中有没有发现，凡是需要用电的电子产品它总得要插头充电（废话），而有些电子产品如手机、笔记本电脑等，它们不是直接插上电源就完事，电源还得经过电源适配器转换为稳定的电压才能进行充电，我们都知道每个国家地区的电压标准都是不一样的，所以要能正常充电就得需要电源适配器为我们工作，那么我们先用代码演示下没有电源适配器的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电压</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">voltage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前电压：220V.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;咱天朝的家庭电压标准是 220 V。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Voltage current = <span class="keyword">new</span> Voltage();</span><br><span class="line">        current.voltage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">当前电压：220V..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在我们就没有电源适配器的情况下，要是我们直接插上电源，恐怕笔记本要炸…</p><p>&emsp;&emsp;事实上这个场景和设计模式中的适配器模式相似，那下面我们就来一起看看适配器模式相关的介绍。<br><br></p><h2 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 (Adapter)"></a>适配器模式 (Adapter)</h2><p>&emsp;&emsp;适配者模式是构造型模式之一，通过 Adapter 模式可以改变已有类（或外部类)的接口形式。也就是说将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>桥接模式中的角色及职责 ：</p><ul><li><p>Target ：目标接口，客户所期待的接口，目标可以是具体的或抽象的类，也可以是接口.</p></li><li><p>Adaptee : 需要适配的类或适配者类.</p></li><li><p>Adapter : 通过包装一个需要适配的对象，把原接口转换成目标接口.</p></li></ul><p>&emsp;&emsp;好，说到这里，那么我们来看看怎么使用适配器模式，废话不多说，给我放码 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类继承实现 Adapter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Voltage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage();</span><br><span class="line">        System.out.println(<span class="string">"使用电源适配器中：20V.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们先定义个适配器类，它通过继承之前的电压类得到当前电压伏特，然后提供了个适配方法，将电压降到 20 伏特，其实这个过程相当于我们把插头插进插座里，这样就有了电流输入，接着连接到适配器中，降低当前电压电流以达到电源适配的效果，这样我们就能充电了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Adapter adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        adapter.adapter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//运行结果：</span><br><span class="line">当前电压：220V..</span><br><span class="line">使用电源适配器中：20V..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过结果我们可以看到，的确使用电源适配器可以起到适配的效果。事实上，我们上面的这种写法是通过类继承来实现适配器的，我们也还可以通过另外一种方式来实现，与类继承有相似效果莫过于是组合了，没错，我们可以通过组合的方式实现适配器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过组合实现 Adapter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Voltage voltage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter2</span><span class="params">(Voltage voltage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage = voltage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        voltage.voltage();</span><br><span class="line">        System.out.println(<span class="string">"使用电源适配器中：20V.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;它持有对电压类的引用，先在构造器中传入电压类对象参数，以便我们得到当前电压信息，再提供适配的方法，同样也能实现适配的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Adapter2 adapter = <span class="keyword">new</span> Adapter2(<span class="keyword">new</span> Voltage());</span><br><span class="line">        adapter.adapter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//运行结果：</span><br><span class="line">当前电压：220V..</span><br><span class="line">使用电源适配器中：20V..</span><br></pre></td></tr></table></figure><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;当系统的数据和行为都正确时，但接口不兼容，我们应该考虑使用适配器，使得对象与接口能够匹配并一起工作，适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境不一致的情况。</p><p><code>应用场景 :</code></p><ul><li><p>双方不太容易修改的时候再使用适配器模式.</p></li><li><p>旧系统改造和升级.</p></li><li><p>Java I/O 流.</p></li></ul><p>&emsp;&emsp;最后，适配器模式不能滥用，因为适配器模式只有在无法改变原有的设计和代码的情况下，才去考虑适配，假如一开始设计我们问题考虑全面，那么不匹配的问题就不会发生，我们也就不需要考虑适配了。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hi，我是十三，也许是我昨天求雨的诚意感动了老天还是受台风气压影响，还真是下了场雨舒服阿，哈哈…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0072Lfvtly1fzhr0ldb9yj30j60csn0x.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://Binshao.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="适配器模式" scheme="http://Binshao.site/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
