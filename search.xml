<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>反射，程序员的快乐</title>
      <link href="/2019/04/03/Reflection/"/>
      <url>/2019/04/03/Reflection/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>&emsp;&emsp;运行时类型信息使得你可以在程序运行时发现和使用类型信息，反射就是指程序在运行时能够动态地获取一个类的类型信息的一种操作，反射机制允许我们动态地调用某个对象的的方法或构造方法以及对象属性等，而无需在编译时确定调用的对象类型，在很多的框架中都有反射的身影存在。</p><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0071ouepgy1g1qce124t4j30j60csgp5.jpg" alt=""></div></p><p><br></p><h2 id="反射有何用"><a href="#反射有何用" class="headerlink" title="反射有何用"></a>反射有何用</h2><p>&emsp;&emsp;在平时，如果我们要创建或使用某个类的时候，通常我们都知道这个类张什么样，都能做什么，于是就直接对这个类进行实例化，接下来再进行一系列的编码操作，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接进行初始化</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"十三"</span>);</span><br><span class="line">System.out.println(person.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面代码中因为我们对 Person 类了若指掌可以直接实例化对象，而它的类声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person name : "</span> + getName();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很简单的一个类，到最后该类会交由编译器生成字节码并会加载到 JVM 中运行，每个类在 JVM 中都有自己的一个 Class 对象，而 Class 对象是在由 JVM 加载类时构造的，Class 对象包含了与类有关的信息，实际上也就是我们常见的 .class 文件，而我们也正是使用 Class 对象来创建类的对象，这背后是因为我们掌握了类的足有信息，在类编译时已经知道关于该类的确切类型，所以可以利用这些信息进行操作。</p><p>&emsp;&emsp;那么当我们不知道初始化的类对象是什么时，也就无法和上面一样直接就能进行实例化操作，也就是说在编译时程序无法知道该对象属于具体哪个类，或者某个类在程序生成代码后才出现时，因为没有相关的信息，无法使用这些类，那么就要使用反射机制来进行反射调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 通过传入完整包名获取 Class 类型</span></span><br><span class="line">    Class clz = Class.forName(<span class="string">"Demo.Person"</span>);</span><br><span class="line">    <span class="comment">// 获取指定方法</span></span><br><span class="line">Method setNameMethod = clz.getDeclaredMethod(<span class="string">"setName"</span>, String.class);</span><br><span class="line">    <span class="comment">// 获取类构造方法</span></span><br><span class="line">Constructor personConstructor = clz.getConstructor();</span><br><span class="line">    <span class="comment">// 利用反射创建实例</span></span><br><span class="line">Object personObj = personConstructor.newInstance();</span><br><span class="line">    <span class="comment">// 利用 invoke 方法去调用方法</span></span><br><span class="line">setNameMethod.invoke(personObj, <span class="string">"LL"</span>);</span><br><span class="line">Method getNameMethod = clz.getMethod(<span class="string">"getName"</span>);</span><br><span class="line">System.out.println(getNameMethod.invoke(personObj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的代码中我们利用反射调用 setName() 方法并且传值，然后又使用反射调用 getName() 方法输出值，至于更详细的反射 API 这里也就不再进行详述了。Class 类与 java.lang.reflect 类库对反射进行支持，该类库包含 Field、Method 及 Constructor 类，这些类型的对象是由 JVM 在运行时创建的，用以表示未知类里对应的成员，接下来可以使用 Constructor 创建新的对象，用相关的的 get() 和 set() 方法读取或修改 Field 对象关联字段，用 invoke() 方法调用与 Method 对象关联的方法，这样，类信息就能在运行时完全确定下来，而在编译时不需要知道任何事情。</p><p>&emsp;&emsp;在《Thinking in Java》一书中曾说到：</p><blockquote><p>反射机制并没有什么神奇之处，当通过反射与一个未知类型的对象打交道时，JVM 只是简单地检查这个对象，看它属于哪个特定的类，再用它做其他事情之前必须先加载那个类的 Class 对象，那个类的 .class 文件对于 JVM 来说必须是可获取的：要么在本地，要么在网络。普通方式和反射调用区别在于，编译器在编译时打开和检查 .class 文件，而对于反射机制来说，.class 文件在编译时是不可获取的，所以是在运行时打开和检查 .class 文件。</p></blockquote><p><br></p><h2 id="反射调用的流程"><a href="#反射调用的流程" class="headerlink" title="反射调用的流程"></a>反射调用的流程</h2><p>&emsp;&emsp;在上面我们利用反射机制进行反射调用，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 通过传入完整包名获取 Class 类型</span></span><br><span class="line">    Class clz = Class.forName(<span class="string">"Demo.Person"</span>);</span><br><span class="line">    <span class="comment">// 获取指定方法</span></span><br><span class="line">Method setNameMethod = clz.getDeclaredMethod(<span class="string">"setName"</span>, String.class);</span><br><span class="line">    <span class="comment">// 获取类构造方法</span></span><br><span class="line">Constructor personConstructor = clz.getConstructor();</span><br><span class="line">    <span class="comment">// 利用反射创建实例</span></span><br><span class="line">Object personObj = personConstructor.newInstance();</span><br><span class="line">    <span class="comment">// 利用 invoke 方法去调用方法</span></span><br><span class="line">setNameMethod.invoke(personObj, <span class="string">"LL"</span>);</span><br><span class="line">Method getNameMethod = clz.getMethod(<span class="string">"getName"</span>);</span><br><span class="line">System.out.println(getNameMethod.invoke(personObj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先在代码 5 行处，我们调用 Class 类的 getDeclaredMethod() 方法可以获取指定的方法名和参数的方法类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">transient</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String s, Class aclass[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">checkMemberAccess(<span class="number">1</span>, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">Method method = searchMethods(privateGetDeclaredMethods(<span class="keyword">false</span>), s, aclass);</span><br><span class="line"><span class="keyword">if</span> (method == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException((<span class="keyword">new</span> StringBuilder()).append(getName()).append(<span class="string">"."</span>).append(s)</span><br><span class="line">.append(argumentTypesToString(aclass)).toString());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看到代码 4 行处，方法 privateGetDeclaredMethods() 作为参数传入 searchMethods() 方法中，而这个privateGetDeclaredMethods() 方法主要是从 JVM 缓存中查找并返回 Class 中的方法，searchMethods() 方法如名所示，则从返回的方法中查找匹配的方法的对象。</p><p>&emsp;&emsp;在最后我们通过 invoke() 方法调用与 Method 相关联的方法，那么进入 Method 中查看 invoke() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">transient</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object aobj[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!override &amp;&amp; !Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">Class class1 = Reflection.getCallerClass();</span><br><span class="line">checkAccess(class1, clazz, obj, modifiers);</span><br><span class="line">&#125;</span><br><span class="line">MethodAccessor methodaccessor = methodAccessor;</span><br><span class="line"><span class="keyword">if</span> (methodaccessor == <span class="keyword">null</span>)</span><br><span class="line">methodaccessor = acquireMethodAccessor();</span><br><span class="line"><span class="keyword">return</span> methodaccessor.invoke(obj, aobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在代码 8 行处会对 methodaccessor 进行非空判断，第一次开始前它是为空的，需要调用 acquireMethodAccessor() 方法去创建，让我们看到代码 10 行处时发现，最后是调用 methodaccessor.invoke() 方法，并不是自己去处理的，那么我看到这个 MethodAccessor 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodAccessor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object aobj[])</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实际上它是一个接口，它的 invoke() 方法与 Method.invoke() 方法是对应的，因为在上面提到，后者在最后是调用了前者，那么 methodaccessor.invoke() 究竟调用的是谁？我们需要看看 acquireMethodAccessor() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MethodAccessor <span class="title">acquireMethodAccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MethodAccessor methodaccessor = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>)</span><br><span class="line">methodaccessor = root.getMethodAccessor();</span><br><span class="line"><span class="keyword">if</span> (methodaccessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">methodAccessor = methodaccessor;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">methodaccessor = reflectionFactory.newMethodAccessor(<span class="keyword">this</span>);</span><br><span class="line">setMethodAccessor(methodaccessor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> methodaccessor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看到自代码 8 行处，创建 MethodAccessor 的实例是通过 ReflectionFactory 类的 newMethodAccessor() 方法进行创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">checkInitted();</span><br><span class="line"><span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(method.getDeclaringClass(), method.getName(),</span><br><span class="line">method.getParameterTypes(), method.getReturnType(), method.getExceptionTypes(),</span><br><span class="line">method.getModifiers());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">NativeMethodAccessorImpl nativemethodaccessorimpl = <span class="keyword">new</span> NativeMethodAccessorImpl(method);</span><br><span class="line">DelegatingMethodAccessorImpl delegatingmethodaccessorimpl = <span class="keyword">new</span> DelegatingMethodAccessorImpl(</span><br><span class="line">nativemethodaccessorimpl);</span><br><span class="line">nativemethodaccessorimpl.setParent(delegatingmethodaccessorimpl);</span><br><span class="line"><span class="keyword">return</span> delegatingmethodaccessorimpl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先看到在 newMethodAccessor() 方法中首先对 noInflation 进行判断，它的默认值为 false，此外，这里我们还需要留意多一个属性：<code>inflationThreshold</code>，这个属性后面我们需要用到，关于它们的声明如下，也是在该类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> noInflation = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> inflationThreshold = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以会跳到代码 7 行处的 else 判断，首先生成 NativeMethodAccessorImpl 类的实例对象，然后它又被作为参数传入 DelegatingMethodAccessorImpl 类对象中，而方法最后返回的也是该对象。</p><p>&emsp;&emsp;事实上，DelegatingMethodAccessorImpl 类对象就是一个代理对象，主要负责调用被代理对象 delegate 的 invoke() 方法，它的源码声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">DelegatingMethodAccessorImpl(MethodAccessorImpl methodaccessorimpl) &#123;</span><br><span class="line">setDelegate(methodaccessorimpl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object aobj[])</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _flddelegate.invoke(obj, aobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDelegate</span><span class="params">(MethodAccessorImpl methodaccessorimpl)</span> </span>&#123;</span><br><span class="line">_flddelegate = methodaccessorimpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MethodAccessorImpl _flddelegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在代码 3 行处看到它的构造方法，构造方法中会把传入的 MethodAccessorImpl 类被代理对象作为 setDelegate() 方法参数并调用此方法，这样接着调用 invoke() 方法时，那么就会去调用该被代理对象的 invoke() 方法。</p><p>&emsp;&emsp;而在上面我们提到，NativeMethodAccessorImpl 类的实例对象被作为参数传入 DelegatingMethodAccessorImpl 类对象中，也就是说当前被代理对象是 NativeMethodAccessorImpl 类的实例对象，那么毫无疑问最终 Method 的 invoke() 方法调用的就是 NativeMethodAccessorImpl 类的 invoke() 方法了，我们看看它的源码声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">NativeMethodAccessorImpl(Method method1) &#123;</span><br><span class="line">method = method1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object aobj[])</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">&amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">MethodAccessorImpl methodaccessorimpl = (MethodAccessorImpl) (<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(</span><br><span class="line">method.getDeclaringClass(), method.getName(), method.getParameterTypes(), method.getReturnType(),</span><br><span class="line">method.getExceptionTypes(), method.getModifiers());</span><br><span class="line">parent.setDelegate(methodaccessorimpl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> invoke0(method, obj, aobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl delegatingmethodaccessorimpl)</span> </span>&#123;</span><br><span class="line">parent = delegatingmethodaccessorimpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method method1, Object obj, Object aobj[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"><span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先可以看到在 invoke() 方法中首先会对我们前面在 ReflectionFactory 类中的 inflationThreshold() 方法，该方法会返回 inflationThreshold 的数值 15，假如调用 invoke() 方法没有超过 15 次，那么就继续调用 invoke0() 方法，此方法是一个 native 方法，它是在 JVM 由 C/C++ 语言实现的；而一旦超过 15 次调用后，则会通过 MethodAccessorGenerator 类中的 generateMethod() 方法生成一个 MethodAccessorImpl 类对象，并且设置为被代理对象，这样当我们继续调用 invoke() 方法时就会调用当前新建对象的 invoke() 方法。</p><p>&emsp;&emsp;到此，我们知道实际上 MethodAccessor 对象其实就是生成反射类的入口(MethodAccessorImpl 类实现了 MethodAccessor 接口)，而它的实现有 Native 版本 和 Java 版本，Native 版本一开始启动快，但随着运行时间变长，其速度也开始变慢；而 Java 版本则与之是相反的，一开始加载慢，但长久来说其性能比 Native 版本要好。</p><p>&emsp;&emsp;综合两个版本的特性，当第一次加载时是使用 NativeMethodAccessorImpl 类实现的 Native 版本，而随着反射调用次数超过 15 次后，就改换为 Java 版本去实现反射，以此来达到最大性能。</p><p><br><br><br></p><hr><p>参考文献：<br>《Thinking in Java》<br><a href="https://rednaxelafx.iteye.com/blog/548536" target="_blank" rel="noopener">关于反射调用方法的一个log</a></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于 Java 注解及其原理简析</title>
      <link href="/2019/04/01/Annotation/"/>
      <url>/2019/04/01/Annotation/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>&emsp;&emsp;注解是 Java SE5 版本中引入的一个特性，<code>注解也被称为元数据，它为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据</code>，可以提供用来完整地描述程序所需的信息，并且能对包、类、接口、字段、方法参数以及局部变量等进行注解。</p><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0071ouepgy1g1mw294m9wj30j60cstb6.jpg" alt=""></div></p><p><br></p><h2 id="注解使用"><a href="#注解使用" class="headerlink" title="注解使用"></a>注解使用</h2><p>&emsp;&emsp;Java 中也有内置的注解，例如我们常见 @Override、@Deprecated、@SuppressWarnings，它们的作用分别如下：</p><ul><li>@Override：标明当前的方法定义将覆盖父类中的方法；</li><li>@Deprecated：标明某个类或方法是过时抛弃的；</li><li>@SuppressWarnings：表示关闭不当的编译器警告信息；</li></ul><p>&emsp;&emsp;它们的使用非常简单，只要在需要注解的地方使用注解即可，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我覆盖了父类中的方法."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虽然 Java 定义了一些注解，但主要还需要我们自己自定义注解并且按自己的方式来使用它们，下面我们就来学习实现自定义注解 @TestAnnotation，可以通过它向某个类中注入字符串，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">show</span><span class="params">()</span> <span class="keyword">default</span> "<span class="keyword">null</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面我们可以发现，注解的定义和定义接口的方式好像，唯一不同的是它还要 @符号。一个注解总体上可以分为三部分：元注解、注解体、注解元素，我们以上面的例子为例分别介绍：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0071ouepgy1g1mxb1voijj30p7082aah.jpg" alt=""></div></p><p>&emsp;&emsp;定义注解时，会需要一些元注解，元注解专门负责注解其他的注解，上面例子中用到的 @Target 用来标明我们定义的这个注解应用于什么地方(例如一个类或方法)，@Retention 用来定义该注解在哪个级别可用，例如是在源码 SOURCE、类文件 CLASS 中或者是运行时 RUNTIME。</p><p>&emsp;&emsp;注解体则没什么好说的，注解元素看起来则就好像是接口的方法，不同的是我们可以指定默认值，如果在注解某个类或方法时没有给出具体的元素值，那么默认就会使用此元素的默认值，实际上元素不能有不确定值，要么具有默认值，要么就是在使用注解时指定元素值。此外还需要注意的是，注解元素对可用的类型很挑剔，只允许如下类型：</p><ul><li>所有基本类型（int、float、boolean 等)；</li><li>String；</li><li>Class；</li><li>enum；</li><li>Annotation；</li><li>以上类型的数组；</li></ul><p>&emsp;&emsp;定义好注解后，我们来看看使用注解的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span>(show = <span class="string">"Hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestAnnotation annotation = Main.class.getAnnotation(TestAnnotation.class);</span><br><span class="line">        System.out.println(annotation.show());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：Hello</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因为我们传入了值所以没有输出元素的默认值，到这里这个简单的小实验就完成了，关于元注解的属性下面给出一张介绍图，用到时查一查就够了：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0071ouepgy1g1my3ne6cnj31aa0u0thi.jpg" alt=""></div></p><p><br></p><h2 id="原理简析"><a href="#原理简析" class="headerlink" title="原理简析"></a>原理简析</h2><p>&emsp;&emsp;在前面我们自定义了一个简单的注解，我们好奇注解是怎么实现的，它又是怎么得到我们传入的值，下面我们就来简单分析下(主要还是太菜了…)。首先回到上面的自定义注解的例子中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">show</span><span class="params">()</span> <span class="keyword">default</span> "<span class="keyword">null</span>"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="meta">@TestAnnotation</span>(show = <span class="string">"Hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestAnnotation annotation = Main.class.getAnnotation(TestAnnotation.class);</span><br><span class="line">        System.out.println(annotation.show());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们对 Main 类进行注解，接着通过反射 <code>TestAnnotation annotation = Main.class.getAnnotation(TestAnnotation.class);</code>传入参数注解类生成实例并去获取注解声明时的数值，冥冥之中似乎觉得和 Class 类有什么关系，我们知道编译器会把我们编写好的 Java 源码编译成 class 文件，这也是我们刚入门 Java 经常看到 “一次编写，到处运行” 这个口号的原因，那么下面去瞅瞅注解被编译后的 class 文件，首先使用命令 <code>javac TestAnnotation.java</code>先把这个类文件编译成 class 文件，接下来再使用<code>javap TestAnnotation.class</code>命令查看编译后的文件，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"TestAnnotation.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">binshao</span>.<span class="title">TestAnnotation</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.<span class="function">String <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到我们这个注解被编译后，就是一个继承 <code>java.lang.annotation.Annotation</code> 的接口，事实上 Annotation 也是一个接口，它的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么问题来了，既然它们是接口那么是不能生成实例对象的，那么前面我们通过反射去获取的 Annotation 实例是什么呢？接口……生成对象……等下，会不会是使用到了动态代理机制呢？那么接下来通过 Debug 的形式探探究竟：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0071ouepgy1g1n2rew9knj31ei08k74v.jpg" alt=""></div></p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0071ouepgy1g1n2vh5ewdj30v90bdt9p.jpg" alt=""></div></p><p>&emsp;&emsp;可以看到 TestAnnotation 注解的实例确实是生成了动态代理类的对象，那么接下来我们去看看这个生成的代理类 $Proxy1，在代码中添加代码<code>System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</code>就可以导出文件，查看如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy1</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">TestAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy1(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">show</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Class <span class="title">annotationType</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Class)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.example.binshao.TestAnnotation"</span>).getMethod(<span class="string">"show"</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">"com.example.binshao.TestAnnotation"</span>).getMethod(<span class="string">"annotationType"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从代码第一行处我们也可以看到自定义注解 TestAnnotation 是一个接口，而这个 $Proxy1 动态代理类就是它实现类，并且它还实现了 Annotation 接口声明的方法，那么到这里，<code>我们已经知道了注解其实是一个继承了 Annotation 接口的特殊接口，当通过反射获取注解的时候，它会返回运行时生成的动态代理类，那么这个代理类就是我们这个注解的具体实现类</code>。</p><p><br></p><h3 id="反射注解流程"><a href="#反射注解流程" class="headerlink" title="反射注解流程"></a>反射注解流程</h3><p>&emsp;&emsp;通过前面我们知道获取注解时，我们是通过动态代理机制生成的代理类对象去调用自定义注解中的注解元素，而我们知道在动态代理机制中，代理方法的调用最终会传递给绑定的 InvocationHandler 接口实例中的 invoke 方法处理，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy1</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">TestAnnotation</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">public</span> $Proxy1(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">show</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么在上卖弄代码 9 行处，从中可以看到 show() 方法似乎调用某个 h 对象的 invoke 方法，我们好奇这个 h 对象是什么？要不，通过 Debug 去看看：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0071ouepgy1g1n4z9xt2aj30ji02bdfr.jpg" alt=""></div></p><p>&emsp;&emsp;从 Debug 的结果来看，这个 h 对象是 AnnotationInvocationHandler 的实例，那么它又是在什么地方蹦出来的呢？看的一脸懵逼，带着目前所知道的线索，回到前面我们通过反射获取注解实例时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span>(show = <span class="string">"Hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">        TestAnnotation annotation = Main.class.getAnnotation(TestAnnotation.class);</span><br><span class="line">        System.out.println(annotation.show());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在代码 6 行处我们通过反射 class#getAnnotation 得到实例对象，而它最后是会一路调用到<code>sun.reflect.annotation.AnnotationParser#parseAnnotations 方法</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; parseAnnotations(<span class="keyword">byte</span>[] var0, ConstantPool var1, Class&lt;?&gt; var2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (var0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> parseAnnotations2(var0, var1, var2, (Class[])<span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BufferUnderflowException var4) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">"Unexpected end of annotations."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(var5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如名字所言，解析注解，6行处又调用<code>parseAnnotations2</code>，这里我们先看懂流程就可，不陷于具体实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; parseAnnotations2(<span class="keyword">byte</span>[] var0, ConstantPool var1, Class&lt;?&gt; var2, Class&lt;? extends Annotation&gt;[] var3) &#123;</span><br><span class="line">        LinkedHashMap var4 = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">        ByteBuffer var5 = ByteBuffer.wrap(var0);</span><br><span class="line">        <span class="keyword">int</span> var6 = var5.getShort() &amp; <span class="string">'\uffff'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var7 = <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">            Annotation var8 = parseAnnotation2(var5, var1, var2, <span class="keyword">false</span>, var3);</span><br><span class="line">            <span class="keyword">if</span> (var8 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class var9 = var8.annotationType();</span><br><span class="line">                <span class="keyword">if</span> (AnnotationType.getInstance(var9).retention() == RetentionPolicy.RUNTIME &amp;&amp; var4.put(var9, var8) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">"Duplicate annotation for class: "</span> + var9 + <span class="string">": "</span> + var8);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码 7 行处又是一个调用<code>parseAnnotation2</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Annotation <span class="title">parseAnnotation2</span><span class="params">(ByteBuffer var0, ConstantPool var1, Class&lt;?&gt; var2, <span class="keyword">boolean</span> var3, Class&lt;? extends Annotation&gt;[] var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5 = var0.getShort() &amp; <span class="string">'\uffff'</span>;</span><br><span class="line">        Class var6 = <span class="keyword">null</span>;</span><br><span class="line">        String var7 = <span class="string">"[unknown]"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var7 = var1.getUTF8At(var5);</span><br><span class="line">                var6 = parseSig(var7, var2);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException var18) &#123;</span><br><span class="line">                var6 = var1.getClassAt(var5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoClassDefFoundError var19) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TypeNotPresentException(var7, var19);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            skipAnnotation(var0, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TypeNotPresentException var20) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> var20;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            skipAnnotation(var0, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var4 != <span class="keyword">null</span> &amp;&amp; !contains(var4, var6)) &#123;</span><br><span class="line">            skipAnnotation(var0, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AnnotationType var8 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var8 = AnnotationType.getInstance(var6);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException var17) &#123;</span><br><span class="line">                skipAnnotation(var0, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map var9 = var8.memberTypes();</span><br><span class="line">            LinkedHashMap var10 = <span class="keyword">new</span> LinkedHashMap(var8.memberDefaults());</span><br><span class="line">            <span class="keyword">int</span> var11 = var0.getShort() &amp; <span class="string">'\uffff'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var12 = <span class="number">0</span>; var12 &lt; var11; ++var12) &#123;</span><br><span class="line">                <span class="keyword">int</span> var13 = var0.getShort() &amp; <span class="string">'\uffff'</span>;</span><br><span class="line">                String var14 = var1.getUTF8At(var13);</span><br><span class="line">                Class var15 = (Class)var9.get(var14);</span><br><span class="line">                <span class="keyword">if</span> (var15 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    skipMemberValue(var0);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Object var16 = parseMemberValue(var15, var0, var1, var2);</span><br><span class="line">                    <span class="keyword">if</span> (var16 <span class="keyword">instanceof</span> AnnotationTypeMismatchExceptionProxy) &#123;</span><br><span class="line">                        ((AnnotationTypeMismatchExceptionProxy)var16).setMember((Method)var8.members().get(var14));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    var10.put(var14, var16);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> annotationForMap(var6, var10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;呼~ 代码真长瑟瑟发抖，这里需要注意的是在代码 53 行处 <code>parseMemberValue</code>这个方法，这个方法后面需要用到，这里做个记号：</p><blockquote><p>To DO List : parseMemberValue()</p></blockquote><p>&emsp;&emsp;最后于代码 62 行处又调用了 <code>annotationForMap</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Annotation <span class="title">annotationForMap</span><span class="params">(<span class="keyword">final</span> Class&lt;? extends Annotation&gt; var0, <span class="keyword">final</span> Map&lt;String, Object&gt; var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Annotation)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Annotation&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Annotation <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (Annotation)Proxy.newProxyInstance(var0.getClassLoader(), <span class="keyword">new</span> Class[]&#123;var0&#125;, <span class="keyword">new</span> AnnotationInvocationHandler(var0, var1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;似乎是看到曙光，我们可以在代码 4 行处可以看到，原来前面说到的使用动态代理机制实例化注解接口是在这里使用的，这也证明了前面的结论，接着还能看到 AnnotationInvocationHandler 在这里实例化，我们可以看看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> </span>&#123;</span><br><span class="line">        String var4 = var2.getName();</span><br><span class="line">        Class[] var5 = var2.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (var4.equals(<span class="string">"equals"</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.equalsImpl(var3[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var5.length != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Too many parameters for an annotation method"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span> var7 = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">switch</span>(var4.hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">1776922004</span>:</span><br><span class="line">                <span class="keyword">if</span> (var4.equals(<span class="string">"toString"</span>)) &#123;</span><br><span class="line">                    var7 = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">147696667</span>:</span><br><span class="line">                <span class="keyword">if</span> (var4.equals(<span class="string">"hashCode"</span>)) &#123;</span><br><span class="line">                    var7 = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1444986633</span>:</span><br><span class="line">                <span class="keyword">if</span> (var4.equals(<span class="string">"annotationType"</span>)) &#123;</span><br><span class="line">                    var7 = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span>(var7) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.toStringImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.hashCodeImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Object var6 = <span class="keyword">this</span>.memberValues.get(var4);</span><br><span class="line">                <span class="keyword">if</span> (var6 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteAnnotationException(<span class="keyword">this</span>.type, var4);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var6 <span class="keyword">instanceof</span> ExceptionProxy) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ((ExceptionProxy)var6).generateException();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != <span class="number">0</span>) &#123;</span><br><span class="line">                        var6 = <span class="keyword">this</span>.cloneArray(var6);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> var6;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;前面我们说到，最后方法的调用最终会传递交由给 invoke 方法处理，实际上 invoke() 方法主要做的还是从 memberValues(LinkedHashMap) 这个 Map 取出数据，而这个我们打上 Debug 断点来看看 invoke 方法处理过程：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0071ouepgy1g1n76182sjj30l7089t9h.jpg" alt=""></div></p><p>&emsp;&emsp;可以发现我们自定义注解中的注解元素 show() 中的数值是从一个 memberValues(LinkedHashMap) 中取出的，而且这个 Map 是以我们的注解元素名作为 key 和对应的元素值作为 value。那么我们也许会想，Map 中存储的数据是怎么从自定义的注解得到的？还记得上面我们做记号的 <code>parseMemberValue()</code>方法，我们可以从中得到答案，它的方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">parseMemberValue</span><span class="params">(Class&lt;?&gt; var0, ByteBuffer var1, ConstantPool var2, Class&lt;?&gt; var3)</span> </span>&#123;</span><br><span class="line">        Object var4 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span> var5 = var1.get();</span><br><span class="line">        <span class="keyword">switch</span>(var5) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">            var4 = parseAnnotation(var1, var2, var3, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">91</span>:</span><br><span class="line">            <span class="keyword">return</span> parseArray(var0, var1, var2, var3);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">99</span>:</span><br><span class="line">            var4 = parseClassValue(var1, var2, var3);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">101</span>:</span><br><span class="line">            <span class="keyword">return</span> parseEnumValue(var0, var1, var2, var3);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            var4 = parseConst(var5, var1, var2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(var4 <span class="keyword">instanceof</span> ExceptionProxy) &amp;&amp; !var0.isInstance(var4)) &#123;</span><br><span class="line">            var4 = <span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var4.getClass() + <span class="string">"["</span> + var4 + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;满脸的懵逼，没事儿，我们看到代码 16 处又调用了 parseConst() 方法，而这个方法正如其名 Const，它是 Java 常量池，也就是我们测试注解类 Main 中的常量池，而我们也正是在 Main 类中使用了自定义注解，使用到的这些注解随着编译器处理并附加到 class 结构中，而 class 文件结构是严格有序的格式，唯一可以附加信息到 class 结构中的方式就是保存到 class 结构的 attributes 属性中。</p><p>&emsp;&emsp;那么既然编译后的 class 文件有关系，那么接下来我们看看通过命令<code>javap -verbose Main.class</code>去查看它的编译后的字节码，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">$ javap -verbose Main.class</span><br><span class="line">Classfile /D:/IntelliJ IDEA/CodeSave/Demo/out/production/Demo/com/example/binshao/Main.class</span><br><span class="line">  Last modified <span class="number">2019</span>-<span class="number">4</span>-<span class="number">1</span>; size <span class="number">1007</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">3</span>c28484e2b796842a0ede3a0f74cbe16</span><br><span class="line">  Compiled from <span class="string">"Main.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">binshao</span>.<span class="title">Main</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool: <span class="comment">// 常量池</span></span><br><span class="line">   #1 = Methodref          #11.#30        // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = String             #31            // sun.misc.ProxyGenerator.saveGeneratedFiles</span><br><span class="line">   #3 = String             #32            // true</span><br><span class="line">   #4 = Methodref          #33.#34        // java/lang/System.setProperty:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">   #5 = Class              #35            // com/example/binshao/Main</span><br><span class="line">   #6 = Class              #36            // com/example/binshao/TestAnnotation</span><br><span class="line">   #7 = Methodref          #37.#38        // java/lang/Class.getAnnotation:(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;</span><br><span class="line">   #8 = Fieldref           #33.#39        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #9 = InterfaceMethodref #6.#40         // com/example/binshao/TestAnnotation.show:()Ljava/lang/String;</span><br><span class="line">  #10 = Methodref          #41.#42        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #11 = Class              #43            // java/lang/Object</span><br><span class="line">  #12 = Utf8               &lt;init&gt;</span><br><span class="line">  #13 = Utf8               ()V</span><br><span class="line">  #14 = Utf8               Code</span><br><span class="line">  #15 = Utf8               LineNumberTable</span><br><span class="line">  #16 = Utf8               LocalVariableTable</span><br><span class="line">  #17 = Utf8               this</span><br><span class="line">  #18 = Utf8               Lcom/example/binshao/Main;</span><br><span class="line">  #19 = Utf8               main</span><br><span class="line">  #20 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #21 = Utf8               args</span><br><span class="line">  #22 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #23 = Utf8               annotation</span><br><span class="line">  #24 = Utf8               Lcom/example/binshao/TestAnnotation;</span><br><span class="line">  #25 = Utf8               SourceFile</span><br><span class="line">  #26 = Utf8               Main.java</span><br><span class="line">  #27 = Utf8               RuntimeVisibleAnnotations</span><br><span class="line">  #28 = Utf8               show</span><br><span class="line">  #29 = Utf8               Hello</span><br><span class="line">  #30 = NameAndType        #12:#13        // "&lt;init&gt;":()V</span><br><span class="line">  #31 = Utf8               sun.misc.ProxyGenerator.saveGeneratedFiles</span><br><span class="line">  #32 = Utf8               true</span><br><span class="line">  #33 = Class              #44            // java/lang/System</span><br><span class="line">  #34 = NameAndType        #45:#46        // setProperty:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  #35 = Utf8               com/example/binshao/Main</span><br><span class="line">  #36 = Utf8               com/example/binshao/TestAnnotation</span><br><span class="line">  #37 = Class              #47            // java/lang/Class</span><br><span class="line">  #38 = NameAndType        #48:#49        // getAnnotation:(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;</span><br><span class="line">  #39 = NameAndType        #50:#51        // out:Ljava/io/PrintStream;</span><br><span class="line">  #40 = NameAndType        #28:#52        // show:()Ljava/lang/String;</span><br><span class="line">  #41 = Class              #53            // java/io/PrintStream</span><br><span class="line">  #42 = NameAndType        #54:#55        // println:(Ljava/lang/String;)V</span><br><span class="line">  #43 = Utf8               java/lang/Object</span><br><span class="line">  #44 = Utf8               java/lang/System</span><br><span class="line">  #45 = Utf8               setProperty</span><br><span class="line">  #46 = Utf8               (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  #47 = Utf8               java/lang/Class</span><br><span class="line">  #48 = Utf8               getAnnotation</span><br><span class="line">  #49 = Utf8               (Ljava/lang/Class;)Ljava/lang/annotation/Annotation;</span><br><span class="line">  #50 = Utf8               out</span><br><span class="line">  #51 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #52 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #53 = Utf8               java/io/PrintStream</span><br><span class="line">  #54 = Utf8               println</span><br><span class="line">  #55 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.example.binshao.Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/example/binshao/Main;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #2                  // String sun.misc.ProxyGenerator.saveGeneratedFiles</span><br><span class="line">         2: ldc           #3                  // String true</span><br><span class="line">         4: invokestatic  #4                  // Method java/lang/System.setProperty:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">         <span class="number">7</span>: pop</span><br><span class="line">         8: ldc           #5                  // class com/example/binshao/Main</span><br><span class="line">        10: ldc           #6                  // class com/example/binshao/TestAnnotation</span><br><span class="line">        12: invokevirtual #7                  // Method java/lang/Class.getAnnotation:(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;</span><br><span class="line">        15: checkcast     #6                  // class com/example/binshao/TestAnnotation</span><br><span class="line">        <span class="number">18</span>: astore_1</span><br><span class="line">        19: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">22</span>: aload_1</span><br><span class="line">        23: invokeinterface #9,  1            // InterfaceMethod com/example/binshao/TestAnnotation.show:()Ljava/lang/String;</span><br><span class="line">        28: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">31</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">19</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">31</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">32</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">           <span class="number">19</span>      <span class="number">13</span>     <span class="number">1</span> annotation   Lcom/example/binshao/TestAnnotation;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Main.java"</span></span><br><span class="line">RuntimeVisibleAnnotations:</span><br><span class="line">  0: #24(#28=s#29)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们看到代码 111 行处的<code>RuntimeVisibleAnnotations</code>这么个属性，而它的值为<code>#24(#28=s#29)</code>，而对应上面的字节码中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#24 = Utf8               Lcom/example/binshao/TestAnnotation;</span><br><span class="line">#28 = Utf8               show</span><br><span class="line">#29 = Utf8               Hello</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以发现这个<code>RuntimeVisibleAnnotations</code>这个属性的值就是我们在测试类 Main 中添加的注解值，而它最后是存在常量池中，而在前面我们看的一脸懵逼的源码，诸如<code>parseAnnotations</code>方法大概就是去处理 class 文件中<code>RuntimeVisibleAnnotations</code>属性了，而这也是作为存储在 Map 中的数据。</p><p><br></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;注解事实上就是一个继承自 Annotation 的特殊接口，它最后会通过动态代理机制生成代理类，我们通过代理类调用注解的注解元素时，会使得调用 AnnotationInvocationHandler 中的 invoke() 方法，而在 invoke() 方法中会从 memberValues 这个 Map 中去取出数据，而这个数据的来源则是通过解析 RuntimeVisibleAnnotations 获得的，也就是来源自常量池中。引用知名大牛 R 大的话来说：</p><blockquote><p>注解就是接口 + Map，然后通过动态代理    将它们进行组合。</p></blockquote><p><br><br><br></p><hr><p>参考文献：<br>《Thinking in Java》<br><a href="https://rednaxelafx.iteye.com/blog/1148983" target="_blank" rel="noopener">Java annotation的实例是什么类</a><br><a href="https://blog.csdn.net/wangyangzhizhou/article/details/51698638" target="_blank" rel="noopener">注解机制及其原理</a></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>搞懂 Java 内部类</title>
      <link href="/2019/03/28/InnerClass/"/>
      <url>/2019/03/28/InnerClass/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>&emsp;&emsp;还记得在刚学习内部类时，经常对外部类以及各种内部类傻傻分不清楚，等到后来知道是怎么一回事后，又随着时间的流逝，再要说出个大概却是什么都回顾不起来了，因此本文就对内部类做个回顾，也为方便日后能够快速复习做个笔记。</p><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0071oueply1g1jfj5pogzj30j60csdi3.jpg" alt=""><br><br><br>&emsp;&emsp;关于内部类的定义就是<code>可以将一个类的定义放在另一个类的定义内部</code>，内部类是一种非常有用的特性，它允许我们把一些逻辑相关的类组织在一起，并且可以控制位于内部的类的可视性。对于上面提到的各种内部类，我们可以大概分为下面张图片的分类：</div></p><p><img src="https://ws1.sinaimg.cn/large/0071oueply1g1jfco5clqj30xw0eumyn.jpg" alt="内部类"></p><p><br></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>&emsp;&emsp;从上图中可以看到，内部类分成静态内部类和非静态内部类，而非静态内部类又可以分为局部内部类和匿名内部类，同时我们把包裹内部类的类称之为外部类，就如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非静态内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;外部类可以使用 public 或者默认包权限来修饰，而内部类则可以使用 private、protected、public 以及包权限进行修饰。使用内部类和我们平时使用普通类并没什么不同，<code>此外当生成内部类对象的时候，内部类持有当前外部类的引用，通过这个引用它可以访问外部类所有的成员变量，包括私有变量</code>，也就是说实际上内部类和它所在的外部类实例对象是相关联的，它不能脱离外部类实例而独自存在，那么我们可能会好奇，它是怎么样和外部类进行相关联的呢？其实是编译器在生成 Java 字节码的时候通过给非静态内部类添加构造方法，使其在进行实例化时得到外部类的引用。</p><p>&emsp;&emsp;既然构建内部类时需要持有外部类对象的引用，那么要想创建内部类对象就要使用外部类的对象来创建该内部类对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        OuterClass.Inner in = out.new Inner();</span><br><span class="line">        <span class="comment">// 也可以使用这种方式进行创建</span></span><br><span class="line">        Inner oin = out.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>&emsp;&emsp;当我们不想内部类对象与其外部类对象之间有联系的时候，我们可以将内部类声明为 static，这样它变成了静态内部类，既然没有和外部类对象有任何相关联，所以它也不需要再依赖与外部类对象，这样它也不能访问外部类的非静态成员，只能够访问外部类的静态成员，此外静态内部类和非静态内部类在创建时也稍有区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OuterClass 为外部类，类含有静态内部类 S 以及非静态内部类 I</span></span><br><span class="line">OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line"><span class="comment">// 创建静态内部类</span></span><br><span class="line">out.S staticClass = out.S();</span><br><span class="line"><span class="comment">// 创建非静态内部类</span></span><br><span class="line">out.I in = out.new I();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里对静态内部类和非静态内部类做个总结：</p><ol><li>静态内部类可以有静态成员，而非静态内部类则不能有静态成员；</li><li>静态内部类可以访问外部类的静态变量，而不可访问外部类的非静态变量；</li><li>非静态内部类的非静态成员可以访问外部类的非静态变量；</li><li>静态内部类的创建不依赖于外部类，而非静态内部类必须依赖于外部类的创建而创建；</li></ol><p><br></p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>&emsp;&emsp;如果一个内部类只在一个方法中使用，那么我们就可以将这个类定义在方法内部，这种内部类被称为局部内部类，其作用域也仅限于该方法区内，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类方法"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFunctionClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionClass</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是局部内部类"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        FunctionClass FunctionClass = <span class="keyword">new</span> FunctionClass();</span><br><span class="line">FunctionClass.show();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line">out.show();</span><br><span class="line">out.showFunctionClass();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">//外部类方法</span></span><br><span class="line"><span class="comment">//我是局部内部类</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此外，局部内部类注意事项如下：</p><ol><li>局部内部类对外是隐藏的，只能通过创建这个类的方法中进行访问；</li><li>局部内部类不允许使用访问权限修饰符；</li></ol><p><br></p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>&emsp;&emsp;匿名内部类是没有类名的局部类，匿名内部类使得类的定义和实例化同时进行，所以通常用来进行简化代码编写，而由于它没有类名也就不存在构造方法，下面通过两个小实验来学习匿名内部类的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"eat..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Child child = <span class="keyword">new</span> Child();</span><br><span class="line">child.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是没有使用匿名内部类的普通写法，先实现接口再重写其中的方法，最后再实例化对象并调用方法，前面我们说到匿名内部类可以简化代码，那接下来看同样的例子用匿名内部类怎么来写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span>  </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Person() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"eat..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样引入匿名内部类直接就将接口中的方法进行重写，就省略了一个类的编写，<code>所以只要是一个类是抽象类或者是一个接口，那么其子类方法或接口方法都可以使用匿名内部类来实现</code>，匿名内部类常用的典型场景是使用 Thread 类或者 Runnable 接口来实现多线程。此外，还需要注意的是，匿名内部类如果使用一个在其外部定义的对象时，编译器会要求该变量必须是 final，原因便是要保持参数的一致性。</p><p><br></p><h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>&emsp;&emsp;到这里，我们大概搞清楚内部类的相关知识点，其中在《Thinking in Java》一书中作者说到内部类最吸引人的原因是：</p><blockquote><p>每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p></blockquote><p>&emsp;&emsp;看到这儿，我想说的是大师就是大师，说的我都一脸懵逼了（太菜了），总结了下还是有下面几点：</p><ul><li>内部类方法可以访问该类定义所在作用域中的数据，包括被 private 修饰的私有数据；</li><li>内部类可以对同一包中的其他类隐藏起来；</li><li>内部类可以解决 Java 单继承的缺陷；</li><li>对于一些有大量冗余代码的回调函数可以通过匿名内部类来实现；<br><br><br><br></li></ul><hr><p>参考文献：<br>《Thinking in Java》</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内部类 Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 跨进程通信机制</title>
      <link href="/2019/02/01/IPC/"/>
      <url>/2019/02/01/IPC/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，最近有在追美剧《海豹突击队 第二季》的小朋友吗，举个爪！</p></blockquote><p>&emsp;&emsp;最近又把艺术探索这本书翻了一遍，还记得第一次翻阅此书的时候感觉有些内容可真是难懂阿，现在回想起来自己那时候就是个小菜鸟，同时也很佩服感叹刚哥可真是好牛逼。都说笨鸟先飞，学习还是不能落下的。本篇学习笔记就记录下 Android 中的 IPC 机制学习过程，同时也是艺术探索的读书笔记。</p><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzqwc4lehhj30p00e2431.jpg" alt=""><br><br></div></p><h2 id="IPC-简介"><a href="#IPC-简介" class="headerlink" title="IPC 简介"></a>IPC 简介</h2><p>&emsp;&emsp;IPC 它的完整全称是 Inter-Process Communication，意思是跨进程通信，也就是两个进程间进行数据交换的过程。说起跨进程通信，就会对 Binder 一定不会感到陌生，从框架层角度来说，Binder 是 ServiceManager 连接各种 Manager 和 ManagerService 的桥梁，所以后续我们想要深入地阅读相关源码，我们就要对多进程有一定的了解。此外，为了保护进程空间不被其他进程干扰破坏，Linux 中的进程都是相互独立的，也就是进程隔离，所以进程之间是不能直接访问或操作另外一个线程，为了能够进行通信协作，就需要使用跨进程通信的技术。</p><p>&emsp;&emsp;在学习 IPC 之前，首先我们得要搞明白两个概念，什么是进程和什么是线程，进程和线程是截然不同的概念，这里就不做多介绍了。那么可能我们会有疑问，跨进程通信究竟是用来解决什么问题的呢？我们知道 Android 中每个应用中数据是不共享的，当前应用需要使用其他应用的数据，就要通过跨进程的方式去获取数据，比如四大金刚中的 ContentProvider 也是一种进程间通信。那么接下来我们看看多进程在 Android 中的使用。<br><br></p><h2 id="Android-中的多进程"><a href="#Android-中的多进程" class="headerlink" title="Android 中的多进程"></a>Android 中的多进程</h2><p>&emsp;&emsp;在 Android 中开启多进程的方式很简单，只需要在 AndroidManifest 权限文件中指定 android:process 属性即可，具体详情如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.example.ipcdemo"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:process</span>=<span class="string">":remote"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的代码中，我们为 SecondActivity 指定了 process 属性，这样当前应用就增加了一个新进程，接下来运行起来看看，这里通过 shell 命令来查看当前包名存在的进程信息，如下图：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fznhs59rkpj30pb043q3b.jpg" alt="进程信息"></div></p><p>&emsp;&emsp;我们可以看到当前只有一个包名为 com.example.ipcdemo 的进程，也就是 MainActivity  所运行在的默认进程，那么我们的另外手动创建的新进程呢？那是因为我们的 SecondActivity 还没有被启动，所以我们给它来个 Intent 跳转页面，让系统给它创建一个单独的进程，接着我们再来查看进程信息：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzni1wlh0xj30pc02xq39.jpg" alt="进程信息"></div></p><p>&emsp;&emsp;如上图中，可以看到我们已经开启了多进程，似乎很简单的说，下面我们再来看看多进程中一些注意事项。<br><br></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>&emsp;&emsp;前面我们开启了多线程了，那么这里我们做个小实验，首先新建个类并且类中添加个静态变量，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> numID = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们要做的是，在 MainActivity 中把这个 numID 重新赋值为 2 并且通过 Log 打印出当前变量值，然后在 SecondActivity 中也来打印一下 numID 的变量值，下面来看看它们的打印记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01-26 21:32:25.176 22193-22193/? I/MainActivity: NumManager.numID = 2</span><br><span class="line">01-26 21:33:21.956 22280-22280/? I/SecondActivity: onCreate</span><br><span class="line">01-26 21:33:21.956 22280-22280/? I/SecondActivity: NumManager.numID = 1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上面的打印日志看到，即使我们已经把变量值重新进行赋值，然而结果却不是我们认为的那样子，<code>也就是说即使两个进程中都存在这个 NumManager 这个类，但是它们之间是不会互相影响的，</code>这也就是我们之前即使手动赋值也没有得到同样变量值的原因，除此之外，使用多进程需要注意以下问题：</p><ol><li>静态成员和单例模式完全失效；</li><li>线程同步机制完全失效；</li><li>SharePreferences 的可靠性下降；</li><li>Application 会多次创建；</li></ol><p>&emsp;&emsp;上面我们说到多线程带来的问题，为了解决这些问题，Android 系统也给我们提供了很多的跨进程通信的方法，下面将会逐一来介绍它们。<br><br></p><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>&emsp;&emsp;我们使用 Binder 跨进程通信传输数据时需要使用 Serializable 或 Parcelable，这里对它们做个简单的介绍，<code>Serializable</code> 是 Java 提供的序列化接口，可以声明一个serialVersionUID 但并不是必需的，但是如果不声明会对反序列化过程产生影响。序列化后的数据中的 serialVersionUID 只有和当前类的 serialVersionUID 相同时，才能被正常地反序列化。</p><p>&emsp;&emsp;<code>Parcelable</code> 则是 Android 提供的序列化接口，相比于 Serializable 它使用过程稍显繁琐，但其性能更优于 Serializable，因此 Parcelable 主要也用于内存序列化操作上，实现方式就是类实现 Parcelable 接口，并实现 createFromParcel 和 writeToParcel 等方法。</p><p>&emsp;&emsp;值得要注意的是，我们通过上面提供的接口去序列化相关的对象，最后再执行相关的反序列化操作，产生的都会是新的对象，它们可不是同一个对象，这一点我们可是要清楚地知道。具体关于 Serializable 和 Parcelable 的详细讲解这里就不再展开叙述了。<br><br></p><h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>&emsp;&emsp;Binder 中文译为粘合剂，即是把两个不同的进程粘合在一起，可以想象为河岸两边有座桥，使得可以互相来往，同时个人认为 Binder 在不同的场景下定义也不同，这一点在艺术探索也可以看到，书中是这样描述的：</p><blockquote><p>直观来说，Binder 是 Android 中的一个类，实现了 IBinder 接口。从 IPC 角度来说，Binder 是 Android 中的一种跨进程的通信方式，也可以理解为一种虚拟的物理设备；从 Android Framework 角度来说，Binder 是 ServiceManager 连接各种 Manager 和相应 ManagerService 的桥梁；从 Android 应用层来说，Binder 是客户端和服务端进行通信的媒介。</p></blockquote><p>&emsp;&emsp;在 Android 开发中，系统主要提供以下的跨进程通信方式：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fznp2qyceuj30va0cg0t1.jpg" alt="跨进程通信"></div></p><p>&emsp;&emsp;上图主要列出了主要的 IPC 方式，而一些如 Bundle 或 Intent 等就没有再列出来，但是不代表我们就不用知道和了解。这里我们首先学习 AIDL 并以此去了解 Binder 的工作机制。首先新建一个类 Book 并让它实现 Parcelable 接口，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String bookName;</span><br><span class="line">    <span class="keyword">public</span> String bookDescribe;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String bookName, String bookDescribe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">        <span class="keyword">this</span>.bookDescribe = bookDescribe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        bookName = in.readString();</span><br><span class="line">        bookDescribe = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(bookName);</span><br><span class="line">        dest.writeString(bookDescribe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;都是些实现 Parcelable 接口的基本操作，我们接着在 Java 同级目录下新建一个 IBookManager.aidl 文件，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.ipcdemo;</span><br><span class="line"><span class="keyword">import</span> com.example.ipcdemo.Book;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;它是我们定义的一个接口，并且里面有两个方法。我们看到第二个方法 addBook() 的方法参数中有 in，in 表示的是输入型参数；除此之外，还有 out 和 inout，它们分别表示输出型参数和输入输出型参数。此外，在 AIDL 文件中只支持以下数据类型：</p><ul><li>基本数据类型（int、long、char、boolean、double 等）；</li><li>String 和 CharSequence；</li><li>List ：只支持 ArrayList；</li><li>Map ：只支持 HashMap；</li><li>Parcelable ：所有实现了 Parcelable 接口的对象；</li><li>AIDL ：所有的 AIDL 接口本身也可以在 AIDL 文件中使用；</li></ul><p>&emsp;&emsp;这里还有一个值得注意的是，我们自定义的 Parcelable 对象需要把它手动地 import 进来，从上面代码的第 三 行处我们也可以看到。另外如果在 AIDL 文件中使用了自定义 Parcelable 对象，还必须要创建一个与它同名的 AIDL 文件并声明为 Parcelable 类型，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Book.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.ipcdemo;</span><br><span class="line"></span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;完成上面的工作后，这个时候需要重新编译项目，工程就会自动生成对应的接口文件，下面来看看它的具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 Binder 中传输的接口都要继承自 IInterface 接口.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment">     * 当户端和服务端在同一个进程时不会走 onTransact 过程，当客户端和服务端不在同一个进程时， </span></span><br><span class="line"><span class="comment">     * 会走 onTransact过程，并且逻辑有内部类 Proxy 完成.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">ipcdemo</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Binder 的唯一标识，通常都是用当前类名表示.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.example.ipcdemo.IBookManager"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct the stub at attach it to the interface.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an com.example.ipcdemo.IBookManager interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         * 用于将服务端的 Binder 对象，转换成客户端所需的 IInterface 接口对象. </span></span><br><span class="line"><span class="comment">         * 这个过程是区分进程的：如果客户端和服务端在同一个进程，此方法返回服务端的 Stub 对象本身；</span></span><br><span class="line"><span class="comment">         * 否则就返回 Stub 的内部类 Proxy 对象.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.example.ipcdemo.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.ipcdemo.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.example.ipcdemo.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.example.ipcdemo.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前的 Binder 对象.</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  此方法运行在服务端的 Binder 线程池中，当客户端发起跨进程请求时，远程请</span></span><br><span class="line"><span class="comment">         * 求会通过系统底层封装之后，交给该方法执行.</span></span><br><span class="line"><span class="comment">         *  它会服务端根据 code 参数确定应该执行的目标方法，接着从 data 中取出目标  </span></span><br><span class="line"><span class="comment">         * 方法需要的参数(如果目标参数需要传入参数)，目标方法执行完成后，将结果写          </span></span><br><span class="line"><span class="comment">         * 入 reply 中(如果目标方法有返回值).</span></span><br><span class="line"><span class="comment">         *  如果该方法返回 false，代表客户端请求失败。所以可以在这里面加自己的业</span></span><br><span class="line"><span class="comment">         * 务，比如权限验证，当不通过时直接返回 false.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    java.util.List&lt;com.example.ipcdemo.Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    com.example.ipcdemo.Book _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.example.ipcdemo.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">ipcdemo</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 此方法运行在客户端，当客户端远程调用此方法时，先创建输入和输出 Parcel _data 和 _reply.</span></span><br><span class="line"><span class="comment">             * 然后调用 transact发起 RPC 远程调用，同时线程挂起；</span></span><br><span class="line"><span class="comment">             * 此时服务端的 onTransact 被调用，直到 RPC 结果返回，客户端线程继续运行，并从 _reply</span></span><br><span class="line"><span class="comment">             * 中取出RPC的返回结果，最后返回结果</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;com.example.ipcdemo.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.example.ipcdemo.Book&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.example.ipcdemo.Book.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此方法同上面，只是多了将参数写入到 _data ，由于该方法没有返回值，所以不会从 _reply 中取结果</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.example.ipcdemo.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明了两个整型的 id 用于标识声明的两个方法.</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们在 IBookManager.aidl 文件中声明的方法.</span></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.example.ipcdemo.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.example.ipcdemo.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面我们把 AIDL 文件转换成了一个 Java 类文件，当然我们也可以自己手动来编写。继续来看生成这个类文件都做了什么：</p><ol><li><p>首先它是一个 interface 接口，它包含了我们前面在 AIDL 文件中声明的两个方法函数，并且还发现它继承自 IInterface 接口，而继承 IInterface 接口还需要提供 asBinder() 方法.</p></li><li><p>包含了一个抽象类 Stub，它继承自 Binder 类并且还实现 IBookManager 接口，这个类定义为抽象类的原因是具体相关的服务方法需要由我们去实现。此外在这个类中定义了一些 int 整形常量，这些常量与服务方法函数是对应的，并且是作为 onTransact() 方法中的第一个参数值 Code，此外还有 asInterface() 这个方法，除了其他进程想要使用服务端提供的服务，服务进程内的其他类也可以使用，显然对于其他进程而言，它们不需要跨进程而可以直接获得服务，为了判断 Binder 对象是否是本地引用，Binder 中提供了个方法 queryLocalInterface() 函数。</p></li><li><p>最后还定义了个 Proxy 类，这个类是作为客户端程序访问服务端的代理，当从远程获取服务端的 Binder 对象就会返回 Binder 驱动中的 Binder 对象。</p></li></ol><p>&emsp;&emsp;到这里我们对 Binder 的工作流程算是有一个大致的认识，这里值得注意的是，当客户端发起远程请求时当前线程会被挂起，一直等到服务端进程返回数据，假若远程方法是个耗时方法，那么为了避免 ANR 我们就不能在 UI 线程中去发起远程请求。还有就是服务端的 Binder 方法是运行在 Binder 的线程池中，当多个客户端同时发起请求连接时，就会存在多个线程同时访问的情况，这时候应该采用同步的方式来处理线程同步的问题。文不如图，下面来一张 Binder 的工作机制图，图片来自于艺术探索：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fznuw2353oj30nu0bagm0.jpg" alt="Binder 的工作机制"><br><br></div></p><h2 id="跨进程通信"><a href="#跨进程通信" class="headerlink" title="跨进程通信"></a>跨进程通信</h2><p>&emsp;&emsp;在理解 Binder 的工作流程之后，接下来将继续学习系统提供的 IPC 方法，主要有 AIDL、Messenger、ContentProvider、Socket，下面我们将会逐个地进行学习。<br><br></p><h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>&emsp;&emsp;在上面学习 Binder 的时候，AIDL 接口文件我们已经是创建好了，这里就不再重复赘述，忘记的同学可以再滑到前面看看。使用 AIDL 进行进程间通信，分为客户端和服务端，首先我们先来看服务端的实现，前面定义了 AIDL 接口，这里我们就要实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIDLService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mBookList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mBookList.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="string">"艺术探索"</span>, <span class="string">"刚哥牛逼!!!"</span>));</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="string">"进阶解密"</span>, <span class="string">"皇叔牛逼!!!"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先创建一个 Service 用来监听客户端的请求连接，在 onCreate() 方法中添加两本书籍信息，然后又创建 Binder 对象实现 AIDL 文件中定义的方法，接着最后在 onBind() 方法中将 Binder 对象返回。这里看到上面代码中第三行处的 CopyOnWriteArrayList，前面我们知道 AIDL 方法是在服务端中的 Binder 线程池中执行的，所以需要处理线程同步的问题，而这个 CopyOnWriteArrayList 支持并发读写，这一点我们是要注意的。</p><p>&emsp;&emsp;服务端的代码编写完后，接下来就到客户端的调用，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, AIDLService.class);</span><br><span class="line">        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mServiceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            IBookManager bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">            Book book = <span class="keyword">new</span> Book(<span class="string">"进阶之光"</span>, <span class="string">"必备好书!!!"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bookManager.addBook(book);</span><br><span class="line">                List&lt;Book&gt; bookList = bookManager.getBookList();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookList.size(); i++) &#123;</span><br><span class="line">                    Book mBook = bookList.get(i);</span><br><span class="line">                    Log.i(TAG, mBook.bookName + <span class="string">"---"</span> + mBook.bookDescribe);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unbindService(mServiceConnection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先在客户端 onCreate() 方法中调用 bindService() 方法去绑定远程服务，绑定完成后将服务端返回的 Binder 对象转换成 AIDL 接口，接下来我们就可以通过这个接口去调用服务端的远程方法。这里我们可能会有疑问，为什么通过调用 bindService() 方法就可以绑定远程服务呢？我们先来看 bindService() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看到这个方法的第二个参数 ServiceConnection，我们跟进去看看，可以发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceConnection</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个 ServiceConnection 它是个接口，其中它的 onServiceConnected() 方法中第二个参数是个 IBinder 类型的，也就是说当我们启动这个 Service 后，因为启动调用的参数含有当前 Service 的 Binder 引用，也就是这样客户端获得了远程服务的 Binder 引用，那么接下来就可以调用远程服务。</p><p>&emsp;&emsp;最后一步就是我们的服务端是运行在另外一个进程里的，所以我们要记得在权限文件开启多线程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.example.ipcdemo"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".AIDLService"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:process</span>=<span class="string">":remote"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在客户端我们又创建新的 Book 对象并调用远程服务端的 addBook() 方法将书添加进去，把程序运行起来看看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01-28 16:02:11.474 21501-21501/com.example.ipcdemo I/MainActivity: 艺术探索---刚哥牛逼!!!</span><br><span class="line">01-28 16:02:11.474 21501-21501/com.example.ipcdemo I/MainActivity: 进阶解密---皇叔牛逼!!!</span><br><span class="line">01-28 16:02:11.474 21501-21501/com.example.ipcdemo I/MainActivity: 进阶之光---必备好书!!!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过 Log 的打印日志可以看到，我们成功地在客户端通过 AIDL 调用远程服务端的方法。到这里我们这个 AIDL 小实验似乎是完成的比较顺利，还记得在前面学习 Binder 的时候，<code>我们说到当客户端和服务端位于同一个进程时，方法调用并不会走跨进程的 onTransact</code>，假若对此比较迷惑，下面我们通过以 Debug 的形式来看看，前面的结论是否准确：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzon5l6u9wj317k095abz.jpg" alt="位于同一进程"></div></p><p>&emsp;&emsp;从上图中可以发现，当它们处于同一个进程的时候，就会调用 queryLocalInterface() 方法返回的对象，那么如果不是位于同一个进程时，看下图：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzonbco9bbj314909agnf.jpg" alt="跨进程"></div></p><p>&emsp;&emsp;可以看到方法就会由 Stub 的内部代理类 Proxy 返回代理对象，并且是会走 onTransact 这个方法。从这里我们也可以验证前面的结论是成立并且准确的，源代码是不会骗人的。这里需要注意的是，跨进程通信时，Binder 驱动并不会给 Client 进程返回真正的它想要调用的 obj 对象，而是返回一个和 obj 一模一样的代理对象，似乎给人感觉 Server 进程直接把 obj 对象传递到 Client 进程，事实上并不是这样的，Client 进程得到的是个代理对象并且也是在代理对象进行的操作，最后 Binder 驱动才让真身完成操作，引用维术大神博客中的总结就是：</p><blockquote><p>Client 进程只不过是持有了 Server 的代理，代理对象协助驱动完成了跨进程通信。</p></blockquote><p>&emsp;&emsp;看到这里我们已经对 AIDL 有了一定的了解，最后我们再学习关于在 AIDL 中使用权限验证的功能，毕竟我们不希望远程服务都可以被任何人连接。添加权限验证主要有两种方法：</p><ul><li>通过定义并使用 permission 进行权限校验；</li><li>通过获取应用的 Uid 和 Pid 进行包名验证；</li></ul><p>&emsp;&emsp;使用 permission 进行验证，首先我们要在 AndroidManifest 文件中添加权限，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 声明所需要的权限</span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.ipcdemo.permission.ACCESS_BOOK_SERVICE"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// 如若绑定远程服务，则要添加此权限以验证通过</span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.example.ipcdemo.permission.ACCESS_BOOK_SERVICE"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们就可以在 Service 的 onBind() 方法中做权限验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> check = checkCallingOrSelfPermission(<span class="string">"com.example.ipcdemo.permission"</span> +</span><br><span class="line">               <span class="string">".ACCESS_BOOK_SERVICE"</span>);</span><br><span class="line">       <span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> mBinder;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果应用试图绑定远程服务时，会去验证当前应用是否含有验证所需的权限，如果没有则当前应用无法绑定服务。下面来看看使用包名来进行验证的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> check = checkCallingOrSelfPermission(<span class="string">"com.example.ipcdemo.permission"</span> +</span><br><span class="line">                    <span class="string">".ACCESS_BOOK_SERVICE"</span>);</span><br><span class="line">            <span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String packageName = <span class="keyword">null</span>;</span><br><span class="line">            String[] packages = getPackageManager().getPackagesForUid(getCallingUid());</span><br><span class="line">            <span class="keyword">if</span> (packages != <span class="keyword">null</span> &amp;&amp; packages.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                packageName = packages[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!packageName.startsWith(<span class="string">"com.example.ipcdemo"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(<span class="string">"MainActivity"</span>, <span class="string">"packageName :"</span> + packageName);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面我们通过 getCallingUid 拿到当前客户端所属应用的 Uid，并通过包名进行校验，当前应用必须是以 com.example.ipcdemo 开头且还要使用定义的自定义权限，只有符合条件才能通过验证。到此我们学习利用 AIDL 来完成跨进程通信，那么接下来我们继续学习其他跨进程通信方法。<br><br></p><h3 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h3><p>&emsp;&emsp;Messenger 可以在不同进程之间传递 Message 对象，从官方文档中我们也可以看到对它的简介：</p><blockquote><p>This allows for the implementation of message-based communication across<br>processes, by creating a Messenger pointing to a Handler in one process,<br>and handing that Messenger to another process.</p><p>可以实现基于消息的进程之间通信的方式.</p></blockquote><p>&emsp;&emsp;有了这个特性，我们可以在 Message 中加入想要传递的数据然后进行数据传递，下面我们就来看看具体它是怎么实现的，首先来写服务端的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MessengerService"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_FROM_CLIENT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_FROM_CLIENT :</span><br><span class="line">                    Log.i(TAG, <span class="string">"收到客户端信息------"</span> + msg.getData().getString(<span class="string">"msg"</span>));</span><br><span class="line">                    <span class="comment">// 接收来自客户端的 Messenger 对象</span></span><br><span class="line">                    Messenger client = msg.replyTo;</span><br><span class="line">                    Message replyMessage = Message.obtain(<span class="keyword">null</span>, MSG_FROM_CLIENT);</span><br><span class="line">                    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">                    bundle.putString(<span class="string">"reply"</span>, <span class="string">"这里是服务端，你的信息已收到，over!"</span>);</span><br><span class="line">                    replyMessage.setData(bundle);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        client.send(replyMessage);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler()).getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样也是先创建 Service 来处理来自客户端的请求连接，接着通过使用 Handler 处理从客户端发送过来的消息，取出发送过来的消息并且进行打印。在 onBind() 方法中创建 Messenger 对象并关联接收消息的 Handler，接着通过调用 getBinder() 来获取 Binder 对象。</p><p>&emsp;&emsp;现在服务端就可以接收客户端的消息，那么往下使得服务端能过回应客户端，通过调用 Message.replyTo 获得客户端传来的 Messenger 对象，这里服务端通过这个 replyTo 参数就可以回应客户端，当然这里 Client 端的代码我们还没写，先这样写着，后面到客户端再贴代码。得到 Messenger 对象后创建 Message 对象并放入想要回应客户端的消息，然后通过 Messenger 讲消息发送给客户端。最后 Service 要记得另开一个新的进程。</p><p>&emsp;&emsp;紧接着来看看客户端这边的逻辑，首先还是通过绑定服务端进程的 Service，然后使用服务端返回的 Binder 对象创建 Messenger 并使用它往服务端发送信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class);</span><br><span class="line">        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mServiceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            Messenger mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            Message msg = Message.obtain(<span class="keyword">null</span>, MessengerService.MSG_FROM_CLIENT);</span><br><span class="line">            Bundle data = <span class="keyword">new</span> Bundle();</span><br><span class="line">            data.putString(<span class="string">"msg"</span>, <span class="string">"这里是客户端，服务端收到请回答!"</span>);</span><br><span class="line">            msg.setData(data);</span><br><span class="line">            <span class="comment">// 将 Messenger 传送给服务端</span></span><br><span class="line">            msg.replyTo = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mService.send(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MessengerService.MSG_FROM_CLIENT :</span><br><span class="line">                    Log.i(TAG, <span class="string">"收到服务端信息------"</span> + msg.getData().getString(<span class="string">"reply"</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unbindService(mServiceConnection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行程序，看看打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">01-30 22:35:07.030 2203-2203/com.example.ipcdemo:remote I/MessengerService: 收到客户端信息------这里是客户端，服务端收到请回答!</span><br><span class="line">01-30 22:35:07.030 2156-2156/com.example.ipcdemo I/MainActivity: 收到服务端信息------这里是服务端，你的信息已收到，over!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Messenger 的使用很简单，实际上 Messenger 的底层实现是 AIDL，至于它的内部实现，鸿神也有博客分析：<a href="https://blog.csdn.net/lmj623565791/article/details/47017485" target="_blank" rel="noopener">Android 基于 Message 的进程间通信 Messenger完全解析</a>.</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzpn0ufyetj30pc0bbq32.jpg" alt="Messenger 工作原理"><br><br></div></p><h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>&emsp;&emsp;ContentProvider 为我们存储和获取数据提供方便的便利，它可以在不同的应用之间共享数据，非常适合进程间通信。下面我们学习使用 ContentProvider 进行进程间通信，首先新建数据库和表，表中有两个字段分别用来记录书籍名字和简介，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_NAME = <span class="string">"book_provider.db"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_TABLE_NAME = <span class="string">"book"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DB_VERSION = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> String CREATE_BOOK_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + BOOK_TABLE_NAME +</span><br><span class="line">            <span class="string">"(_id INTEGER PRIMARY KEY,"</span> + <span class="string">"name TEXT,"</span> + <span class="string">"describe TEXT)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, DB_NAME, <span class="keyword">null</span>, DB_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        db.execSQL(CREATE_BOOK_TABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来使用 ContentProvider 对创建的数据库进行操作，放码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.example.ipcdemo.BookProvider"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase db;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="keyword">private</span> String table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        matcher.addURI(AUTHORITY, <span class="string">"book"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        table = DBOpenHelper.BOOK_TABLE_NAME;</span><br><span class="line">        context = getContext();</span><br><span class="line">        initProvider();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        db = <span class="keyword">new</span> DBOpenHelper(context).getWritableDatabase();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                db.execSQL(<span class="string">"DELETE FROM "</span> + DBOpenHelper.BOOK_TABLE_NAME);</span><br><span class="line">                db.execSQL(<span class="string">"INSERT INTO book VALUES(1, '艺术探索', '刚哥牛逼!!!')"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        String table = DBOpenHelper.BOOK_TABLE_NAME;</span><br><span class="line">        Cursor mCursor = db.query(table, projection, selection, selectionArgs, <span class="keyword">null</span>, sortOrder, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> mCursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">        db.insert(table, <span class="keyword">null</span>, values);</span><br><span class="line">        context.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;还是老套路，类继承自 ContentProvider 并实现相应的方法，在 initProvider() 方法中开启线程对数据进行添加表数据，此时数据库表中已经插入了一条字段名为艺术探索的数据记录。此外，当前这个 BookProvider 是要运行在另外一个进程上，所以不要忘记配置多进程属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.example.ipcdemo"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".BookProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"com.example.ipcdemo.BookProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:process</span>=<span class="string">":provider"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要注意的是，android:authorities 是 ContentProvider 的唯一标识，通过这个属性外部应用就可以访问这个 BookProvider，那么下面我们模拟在 Client 进程再插入一条表数据，然后再打印此时表中的所有数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Uri uri = Uri.parse(<span class="string">"content://com.example.ipcdemo.BookProvider"</span>);</span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"_id"</span>, <span class="number">2</span>);</span><br><span class="line">        values.put(<span class="string">"name"</span>, <span class="string">"进阶之光"</span>);</span><br><span class="line">        values.put(<span class="string">"describe"</span>, <span class="string">"皇叔牛逼!!!"</span>);</span><br><span class="line">        getContentResolver().insert(uri, values);</span><br><span class="line">        Cursor bookCursor = getContentResolver().query(uri, <span class="keyword">new</span> String[]&#123;<span class="string">"name"</span>, <span class="string">"describe"</span>&#125;,</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (bookCursor.moveToNext()) &#123;</span><br><span class="line">            Book book = <span class="keyword">new</span> Book(bookCursor.getString(<span class="number">0</span>), bookCursor.getString(<span class="number">1</span>));</span><br><span class="line">            Log.i(TAG, book.bookName + <span class="string">"------"</span> + book.bookDescribe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们通过 ContentValues 往表中插入数据，然后再调用 query() 方法查询数据库中的表数据，最终的打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">01-31 14:59:25.025 31263-31263/? I/MainActivity: 艺术探索------刚哥牛逼!!!</span><br><span class="line">01-31 14:59:25.025 31263-31263/? I/MainActivity: 进阶之光------皇叔牛逼!!!</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>&emsp;&emsp;最后我们再来看看通过 Socket 来实现进程间通信，Socket 是网络通信中的概念，关于这方面让我想起以前刚刚入门学 Java 语法的时候那会，下面就使用 Socket 来实现一个小实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isDestroyed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TcpServer()).start();</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ServerSocket serverSocket;</span><br><span class="line">            <span class="comment">// 监听9096端口</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9096</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!isDestroyed) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等待客户端发起请求并且接收信息</span></span><br><span class="line">                    <span class="keyword">final</span> Socket client = serverSocket.accept();</span><br><span class="line">                    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                responseClient(client);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;.start();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">responseClient</span><span class="params">(Socket clinet)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 接收客户端信息</span></span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clinet.getInputStream()));</span><br><span class="line">        <span class="comment">// 向客户端发送信息</span></span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedOutputStream(clinet.getOutputStream()), <span class="keyword">true</span>);</span><br><span class="line">        out.println(<span class="string">"这里是服务端"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!isDestroyed) &#123;</span><br><span class="line">            String str = in.readLine();</span><br><span class="line">            Log.i(<span class="string">"SocketService"</span>, <span class="string">"来自客户端 : "</span> + str);</span><br><span class="line">            <span class="keyword">if</span> (TextUtils.isEmpty(str)) &#123;</span><br><span class="line">                <span class="comment">// 客户端断开连接</span></span><br><span class="line">                Log.i(<span class="string">"SocketService"</span>, <span class="string">"客户端已下线..."</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String message = <span class="string">"好的，收到!"</span>;</span><br><span class="line">            out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">        clinet.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isDestroyed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样还是利用 Service 作为远程的服务端，当 Service 启动的时候建立 TCP 服务并且监听的 9096 这个端口，当客户端连接时就会生成 Socket 并且服务端可以通过 Socket 和不同客户端进行通信，这里使用流向客户端发送回应，此外需要注意的是主线程中进行网络操作是个耗时操作，接着来看客户端的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button bt_send;</span><br><span class="line">    <span class="keyword">private</span> EditText et_receive;</span><br><span class="line">    <span class="keyword">private</span> Socket mClientSocket;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter mPrintWriter;</span><br><span class="line">    <span class="keyword">private</span> TextView tv_message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        initView();</span><br><span class="line">        Intent service = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SocketService.class);</span><br><span class="line">        startService(service);</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                connectSocketServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        et_receive = findViewById(R.id.et_receive);</span><br><span class="line">        bt_send = findViewById(R.id.bt_send);</span><br><span class="line">        tv_message = findViewById(R.id.tv_message);</span><br><span class="line">        bt_send.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> String msg = et_receive.getText().toString();</span><br><span class="line">                <span class="comment">//向服务器发送信息</span></span><br><span class="line">                <span class="keyword">if</span> (!TextUtils.isEmpty(msg) &amp;&amp; <span class="keyword">null</span> != mPrintWriter) &#123;</span><br><span class="line">                    mPrintWriter.println(msg);</span><br><span class="line">                    tv_message.setText(tv_message.getText() + <span class="string">"\n"</span> + <span class="string">"客户端："</span> + msg);</span><br><span class="line">                    et_receive.setText(<span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSocketServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (socket == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//选择和服务器相同的端口8688</span></span><br><span class="line">                socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">9096</span>);</span><br><span class="line">                mClientSocket = socket;</span><br><span class="line">                mPrintWriter = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream())), <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 接收服务器端的消息</span></span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            <span class="keyword">while</span> (!isFinishing()) &#123;</span><br><span class="line">                <span class="keyword">final</span> String msg = br.readLine();</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            tv_message.setText(tv_message.getText() + <span class="string">"\n"</span> + <span class="string">"服务端："</span> + msg);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mPrintWriter.close();</span><br><span class="line">            br.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先在 onCreate() 中开启线程去连接服务端，连接成功后就是发送消息并且接收服务端回应的消息，此外，记得最后关闭 Socket，来看看运行结果：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzq32d6hcyj30dw0c4t9h.jpg" alt="效果预览"><br><br></div></p><h2 id="IPC-总览"><a href="#IPC-总览" class="headerlink" title="IPC 总览"></a>IPC 总览</h2><p>&emsp;&emsp;最后到这里，我们基本已经将 IPC 方法都简单地过了遍，下面贴出不同 IPC 方式优缺点和适用场景的图表总结：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzqtygge76j314p0if42m.jpg" alt="IPC 方式的优缺点及适用场景"><br><br><br><br></div></p><hr><p>参考文献：<br>《Android 艺术开发探索》<br>&emsp;<a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="noopener">Binder 学习指南</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的个人小程序上线了</title>
      <link href="/2018/10/29/MiniProgram/"/>
      <url>/2018/10/29/MiniProgram/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，大家好久不见，不知道各位那边天气如何，反正广府(广州)已经开始转凉了，每到换季一大堆人感冒……</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs58592ej30j60cs0tc.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="关于小程序"><a href="#关于小程序" class="headerlink" title="关于小程序"></a>关于小程序</h2><p>&emsp;&emsp;对于小程序近来可是越来越火热，从一开始经典的跳一跳，再到前些天上线推出的<code>云开发</code>功能，让人有种感觉这是要上天阿？确实，随着<code>云开发</code>的开放，这让开发小程序的门槛又近一步降低，我们知道没有后端的支持，前端都是些静态页面数据，而现在推出<code>云开发</code>之后确实是方便了不少。</p><p>&emsp;&emsp;毫无疑问看到这就坐不住了，要不自己也弄个小程序玩玩，于是说干就干，就有了自己这个博客小程序的存在，我把博客内容都搬到了小程序里了。这里说下小程序的官方文档挺详细的，建议大家先看看文档了解下大概，挺好上手的。<br><br></p><h2 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h2><p>&emsp;&emsp;总体上小程序功能不是很多，内容都是来自我的博客里的，算是一个博客小程序吧，下面我们分别看看各个页面的效果：</p><p>&emsp;&emsp;首页：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs4rk7w1g30a60i37wk.gif" alt=""></div></p><p>&emsp;&emsp;点击打开文章详情页面，出现 object 什么鬼，估计这里解析 Markdown 文档出了点问题，后续慢慢优化吧……</p><p>&emsp;&emsp;归档：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs3j6m03g30a60i3b29.gif" alt=""></div></p><p>&emsp;&emsp;归档页面对不同文章进行归类，也可以点击打开文章详情页面，并且点击顶部的 Tab 都会进行刷新。</p><p>&emsp;&emsp;妹子：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs0li90ug30a60i3npe.gif" alt=""></div></p><p>&emsp;&emsp;这里就算是个福利了，看文章看累了可以来看看妹子放松放松，嘿嘿，是不是美的一塌糊涂。</p><p>&emsp;&emsp;我的：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrzp0qh5g30a60i3b29.gif" alt=""></div></p><p>&emsp;&emsp;相比于其他页面，这里就没什么看点了，主要是这里会让用户进行授权，由于我之前已经做过授权了，所以演示里没有出现，具体大家也可以访问我的博客小程序玩玩。<br><br></p><h2 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h2><p>&emsp;&emsp;首先为什么要弄了个小程序，肯定是为了学习阿，关于小程序技术上的利弊这里就不多说了，微信用户量是十分庞大的，而且随着一些小程序的出现也确实是方便了生活。</p><p>&emsp;&emsp;目前小程序已经上线，对于整个小程序的开发流程也算是有了个大概了解，在这里对本项目用到的接口及参考的开源项目表示感谢，同时对于这次小程序入门也让我有了不同想法，这是我之前没去仔细想过的，比如假如我要取到数据，那么后端该怎么处理数据并返回等等，怎么说呢，学的越多发现不懂的也就越多，后面也将对小程序不断进行优化以及些新功能的实现，慢慢来。</p><p>&emsp;&emsp;最后奉上小程序码，欢迎大家体验我的小程序，当然也可以在小程序里直接搜索<code>十三的个人博客</code>。</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrz0ko4nj30760760t6.jpg" alt=""><br><br><br><br></div></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxJava 创建操作符详解</title>
      <link href="/2018/10/17/RxJava1/"/>
      <url>/2018/10/17/RxJava1/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsk8wspej30zk0b4ac4.jpg" alt=""></div></p><a id="more"></a><p>&emsp;&emsp;关于这个 create 操作符相信大家应该不会陌生，在我们上一篇的学习记录中就是用它来创建被观察者对象，是最基本的操作符。下面我们来看看它的具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Just"><a href="#Just" class="headerlink" title="Just"></a>Just</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsjuyukqj30zk0h8abi.jpg" alt=""></div></p><blockquote><p>The Just operator converts an item into an Observable that emits that item. </p></blockquote><p>对于 just 操作符文档给出的注释是它可以将传入的对象或一组对象转换为发出事件的<code>Observable</code>，也就是它可以直接发送传入的事件，还是挺方便的，来，我们一起来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsjgj80sj30zk0iwdjy.jpg" alt=""></div></p><blockquote><p>The Defer operator waits until an observer subscribes to it, and then it generates an Observable.</p></blockquote><p>&emsp;&emsp;这个操作符的作用是假如有<code>Observer</code>订阅时，才去为观察者创建新的<code>Observable</code>并且开始发送事件，每一个观察者订阅时都会得到一个新的<code>Observable</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="From"><a href="#From" class="headerlink" title="From"></a>From</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsiuvgywj30zk0hiwj5.jpg" alt=""></div></p><blockquote><p>convert various other objects and data types into Observables.</p></blockquote><p>&emsp;&emsp;From 操作符可以将各种对象或数据结构转换为<code>Observable</code>对象，我们可以将一组数组里的值转换为<code>Observable</code>对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Interval"><a href="#Interval" class="headerlink" title="Interval"></a>Interval</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsiex491j30zk0aut9y.jpg" alt=""></div></p><blockquote><p>create an Observable that emits a sequence of integers spaced by a given time interval.</p></blockquote><p>&emsp;&emsp;Interval 操作符创建的<code>Observable</code>会根据我们给定的间隔时间发送事件，类似于定时器的概念，发送事件从 0 开始且无限递增下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsi0vqlsj30zk0audhg.jpg" alt=""></div></p><blockquote><p>create an Observable that emits a particular range of sequential integers.</p></blockquote><p>&emsp;&emsp;Range 操作符创建一个发出特定范围且是连续整数的<code>Observable</code>，也就是说我们可以指定其中的选择范围的起点及长度，直接看码就懂了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhshjwqopj30zk0gy0ut.jpg" alt=""></div></p><blockquote><p>create an Observable that emits a particular item multiple times.</p></blockquote><p>&emsp;&emsp;Repeat 顾名思义就是重复的意思，那么毫无疑问这个操作符可以创建一个多次发出特定事件的<code>Observable</code>，放码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testRepeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">                .repeat(<span class="number">3</span>,Schedulers.io())</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer item)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">"TAG"</span>, <span class="string">"onNext:"</span> + item);</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">"TAG"</span>, <span class="string">"onErr:"</span> + error.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">"TAG"</span>, <span class="string">"Sequence complete."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsgxvxxmj30zk0b475d.jpg" alt=""></div></p><blockquote><p>create an Observable that emits a particular item after a given delay.</p></blockquote><p>&emsp;&emsp;Timer 操作符创建<code>Observable</code>并且同样也是根据指定延迟时间发射事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RxJava2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxJava 创建操作符 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxJava2 入门笔记</title>
      <link href="/2018/10/14/RxJava/"/>
      <url>/2018/10/14/RxJava/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，最近在项目学习中使用到 RxJava 并且随着它越来越流行没有理由不去了解它，但是刚开始接触的时候，还是一脸懵逼的，这里我就来记录下 RxJava 的学习笔记！</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsgckswrj30j60cs751.jpg" alt=""></div></p><a id="more"></a><p>&emsp;&emsp;网络上关于 RxJava 的讲解多不胜数，其中更是不乏好的博客文章，但是别人的知识终究还是别人的，在看懂理解的基础上自己再去动手实践，最后以输入倒逼输出，这样我们才能掌握到知识同时也能加深印象，废话不多说了！</p><h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsfxzcadj30j609owgi.jpg" alt="官网"></div></p><p>&emsp;&emsp;在 GitHub 上我们可以看到 RxJava 的简介：</p><blockquote><p>RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.</p></blockquote><p>&emsp;&emsp;翻译为 <code>RxJava 是一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库，</code>不明觉厉……说得我们能听懂的话就是 RxJava 是一个基于事件流，实现异步操作的库。</p><p>&emsp;&emsp;说到异步操作，我们下意识就会想到 Android 当中的 Handler 又或是 AsyncTask ，那么可能就会有疑问了，为什么我们不用它们而用 RxJava 呢？原因是随着请求增多并且代码逻辑会变得越来越复杂而它依然能够保持简洁清晰的逻辑，真的那么神奇吗？？？光说不练假把式，那么下面我们就先按照国际惯例先来写个 Hello World。<br><br></p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>&emsp;&emsp;其实 RxJava 的异步操作是基于扩展的观察者模式来实现的，关于观察者模式之前也记录过一篇学习总结，大家可以去翻翻。理论概念一上是不是一脸懵逼，最好还是结合代码来学习，事不宜迟，放码过来！这里我们先来看看使用步骤：</p><p>&emsp;&emsp;首先要想在 Android 中使用 RxJava2 就要先添加配置： <code>implementation &#39;io.reactivex.rxjava2:rxjava:2.2.2&#39;</code>，目前版本是 2.2.2。</p><ol><li>创建 Observable (被观察者) : 定义事件触发行为.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个被观察者 Observable 对象</span></span><br><span class="line">        Observable&lt;String&gt; observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 向观察者发送事件</span></span><br><span class="line">                e.onNext(<span class="string">"Hello World, RxJava!"</span>);</span><br><span class="line">                e.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们创建 Observable 对象是通过 create() 方法来创建，然后我们在重写的 subscribe() 方法里定义发送的事件，那么它是通过什么手段发送的呢？我们接着往下看到 <code>ObservableEmitter</code> 这个类，其实它是一个事件发射器，而我们就是通过它向观察者发送事件，可以通过它分别调用 onNext()、 onComplete() 和 onError() 方法就可以发射相对应的事件。</p><ol start="2"><li>创建 Observer (观察者) : 定义响应事件行为.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个观察者 Observer 对象</span></span><br><span class="line">        Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"进行连接..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收事件并作出响应</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"发生错误了..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"完成事件..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们创建观察者并通过重写对应事件方法，从而响应对应的事件。当观察者接收到事件前，最先调用的是 onSubscribe() 方法。</p><p>&emsp;&emsp;那么在前面的被观察者我们发射了 Next 事件，在这里我们的观察者接收到事件后就会调用 onNext() 方法进行事件的响应，而 onError() 和 onComplete() 方法也是类似，当被观察者发射事件后观察者接收到事件并进行响应。<code>此外，这里要注意的是，当 Observable（被观察者）发射了 onComplete() 事件后，Observable 之后的事件还将会继续发送事件，而 Observer (观察者) 接受到 onComplete 事件后就不会继续接受事件了。</code></p><ol start="3"><li>通过 Subscribe (订阅) 连接观察者和被观察者.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过订阅(subscribe)连接观察者和被观察者</span></span><br><span class="line">        observable.subscribe(observer);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么最后一步就是把两者连接起来。        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 打印结果</span><br><span class="line">10-15 14:33:39.890 15860-15860/? I/RxJava: 进行连接...</span><br><span class="line">    Hello World, RxJava!</span><br><span class="line">    完成事件...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到这里我们的 Hello World 就运行起来了，这里我把完整代码再贴出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = <span class="string">"RxJava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个被观察者 Observable 对象</span></span><br><span class="line">        Observable&lt;String&gt; observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 向观察者发送事件</span></span><br><span class="line">                e.onNext(<span class="string">"Hello World, RxJava!"</span>);</span><br><span class="line">                e.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个观察者 Observer 对象</span></span><br><span class="line">        Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"进行连接..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收事件并作出响应</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"发生错误了..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"完成事件..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过订阅(subscribe)连接观察者和被观察者</span></span><br><span class="line">        observable.subscribe(observer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然上面的代码我们还可以使用链式调用的方式将代码连在一起，使得逻辑简洁，同样贴码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = <span class="string">"RxJava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个被观察者 Observable 对象</span></span><br><span class="line">        Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 向观察者发送事件</span></span><br><span class="line">                e.onNext(<span class="string">"Hello World, RxJava!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(TAG, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 打印结果</span><br><span class="line">10-15 16:26:06.675 24477-24477/com.example.binshao.rxjavademo I/RxJava: Hello World, RxJava!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到我们同样也能得到结果，有仔细的同学可能会发现这里的 subscribe() 方法里的 Consumer 又是什么，其实这个 Observer 观察者的 subscribe() 是具有多个重载的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError, Action onComplete)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError, Action onComplete, Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们上面使用到的带有一个 Consumer 参数的方法表示 Observer 只关心 onNext 事件，其他我一概不接收处理，按照这个逻辑分析，没有任何参数的方法就是什么事件都不管，其他方法我们也可以举一反三！<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;到这里这篇 RxJava2 的入坑学习记录算是接近尾声了，接下来将继续记录 RxJava2 的学习过程，最后放张图来帮我们加深对 RxJava2 的学习理解：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsf5x8gtj30j609jaa6.jpg" alt=""></div></p><p>&emsp;&emsp;上游水库相当于 <code>Observable(被观察者)</code>, 而下游水库就相当于我们的<code>Observer(观察者)</code>，当下游水库缺水时，上游水库就会往下游放水，这个过程就相当于 <code>Observable</code> 向 <code>Observer</code> 发射事件；上游放水最终流到下游水库补充了水源，我们可以看作响应事件；最后最关键的，也是最重要的一点是水源能够流动的前提是我们的水闸必须是否开着的，也就是通过 <code>Subscribe(订阅)</code> 连接观察者和被观察者，不然水闸都是关着的，水源又怎么进行流动呢？<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> RxJava2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxJava2 入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单实现个购物车商品数量控件</title>
      <link href="/2018/09/27/NumAddSubView/"/>
      <url>/2018/09/27/NumAddSubView/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，最近突然对马克思感兴趣了起来，此前可是一点都不感冒……看来凡事都不要太早下定论了。</p></blockquote><p>&emsp;&emsp;平时我们在各大电商平台上购物时，购物车清单里的商品数量选择器都很常见，它可以让用户选择购买商品的数量，而在最近学习项目中我们需要用到，索性我们就自己来自定义这个控件。</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs6pqgtlj30j60csmxg.jpg" alt=""></div></p><a id="more"></a><h2 id="演示效果"><a href="#演示效果" class="headerlink" title="演示效果"></a>演示效果</h2><p>&emsp;&emsp;老规矩，我们先来看看我们要实现的效果：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs65unw8g309s08j43e.gif" alt=""></div></p><p>&emsp;&emsp;你没看错，这家平台胆还真肥阿！我们从演示图中可以看到，左右两边分别是一个按钮，点击可以对商品数量进行选择，而中间则是一个 TextView，对选择的商品数量进行展示。其实这个控件还是挺简单的，那么我们分析完后，下面就开始动手撸码。<br><br></p><h2 id="控件布局及自定义属性"><a href="#控件布局及自定义属性" class="headerlink" title="控件布局及自定义属性"></a>控件布局及自定义属性</h2><p>&emsp;&emsp;那么我们先来看看布局代码先，上面我们分析了左右两边都是一个 Button，中间是一个 TextView，这里的布局代码就不多说了，放码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@drawable/selector_number_add_sub"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_sub"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@drawable/bg_btn_style_white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"-"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#000"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/etxt_num"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"16sp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"@color/black"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_add"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@drawable/bg_btn_style_white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"+"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#000"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然说到了自定义控件，那么自定义属性我们肯定是不陌生的，关于自定义属性十三之前有记录过一篇学习记录，大家可以移步到 <a href="https://binshao.site/2018/03/08/AttributeSet/">Android 自定义属性</a> 这里查看。</p><p>&emsp;&emsp;那么我们这里需要什么属性呢，既然商品数量选择，那么我们肯定要提供<code>当前商品数量、最低数量、以及库存的最大数量。</code>总不能库存都清空了还拿出来卖吧！还有其他一些如提供修改按钮等控件的背景色等属性，下面来看看属性文件代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"value"</span> <span class="attr">format</span>=<span class="string">"integer|reference"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"minValue"</span> <span class="attr">format</span>=<span class="string">"integer|reference"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"maxValue"</span> <span class="attr">format</span>=<span class="string">"integer|reference"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"editBackground"</span> <span class="attr">format</span>=<span class="string">"reference"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"buttonAddBackgroud"</span> <span class="attr">format</span>=<span class="string">"reference"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"buttonSubBackgroud"</span> <span class="attr">format</span>=<span class="string">"reference"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"NumAddSubView"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"value"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"minValue"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"maxValue"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"editBackground"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"buttonAddBackgroud"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"buttonSubBackgroud"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="自定义控件代码"><a href="#自定义控件代码" class="headerlink" title="自定义控件代码"></a>自定义控件代码</h2><p>&emsp;&emsp;搞定了我们的布局以及属性，接下来我们就可以来写自定义控件的代码了，这里还是直接贴出源码，看起来还是挺简单的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberAddSubView</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mTxtNum;</span><br><span class="line">    <span class="keyword">private</span> Button mBtnAdd;</span><br><span class="line">    <span class="keyword">private</span> Button mBtnSub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnButtonClickListenr onButtonClickListener;</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater mInflater;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxValue = DEFAULT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberAddSubView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberAddSubView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberAddSubView</span><span class="params">(Context context, @Nullable AttributeSet attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        mInflater = LayoutInflater.from(context);</span><br><span class="line">        initView();</span><br><span class="line">        <span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> TintTypedArray a = TintTypedArray.obtainStyledAttributes(getContext(),</span><br><span class="line">                    attrs, R.styleable.NumberAddSubView, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> val = a.getInt(R.styleable.NumberAddSubView_value, <span class="number">0</span>);</span><br><span class="line">            setValue(val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> maxVal = a.getInt(R.styleable.NumberAddSubView_maxValue, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (maxVal != <span class="number">0</span>)</span><br><span class="line">                setMaxValue(maxVal);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> minVal = a.getInt(R.styleable.NumberAddSubView_minValue, <span class="number">0</span>);</span><br><span class="line">            setMinValue(minVal);</span><br><span class="line"></span><br><span class="line">            Drawable etBackground = a.getDrawable(</span><br><span class="line">                    R.styleable.NumberAddSubView_editBackground);</span><br><span class="line">            <span class="keyword">if</span> (etBackground != <span class="keyword">null</span>)</span><br><span class="line">                setEditTextBackground(etBackground);</span><br><span class="line"></span><br><span class="line">            Drawable buttonAddBackground = a.getDrawable(</span><br><span class="line">                    R.styleable.NumberAddSubView_buttonAddBackgroud);</span><br><span class="line">            <span class="keyword">if</span> (buttonAddBackground != <span class="keyword">null</span>)</span><br><span class="line">                setButtonAddBackgroud(buttonAddBackground);</span><br><span class="line"></span><br><span class="line">            Drawable buttonSubBackground = a.getDrawable(</span><br><span class="line">                    R.styleable.NumberAddSubView_buttonSubBackgroud);</span><br><span class="line">            <span class="keyword">if</span> (buttonSubBackground != <span class="keyword">null</span>)</span><br><span class="line">                setButtonSubBackgroud(buttonSubBackground);</span><br><span class="line"></span><br><span class="line">            a.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        View view = mInflater.inflate(R.layout.widet_num_add_sub, <span class="keyword">this</span>,</span><br><span class="line">                <span class="keyword">true</span>);</span><br><span class="line">        mTxtNum = view.findViewById(R.id.etxt_num);</span><br><span class="line">        mTxtNum.setInputType(InputType.TYPE_NULL);</span><br><span class="line">        mTxtNum.setKeyListener(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        mBtnAdd = view.findViewById(R.id.btn_add);</span><br><span class="line">        mBtnSub = view.findViewById(R.id.btn_sub);</span><br><span class="line"></span><br><span class="line">        mBtnAdd.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        mBtnSub.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.btn_add) &#123;</span><br><span class="line">            numAdd();</span><br><span class="line">            <span class="keyword">if</span> (onButtonClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                onButtonClickListener.onButtonAddClick(v, <span class="keyword">this</span>.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.getId() == R.id.btn_sub) &#123;</span><br><span class="line">            numSub();</span><br><span class="line">            <span class="keyword">if</span> (onButtonClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                onButtonClickListener.onButtonSubClick(v, <span class="keyword">this</span>.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">numAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getValue();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value &lt;= maxValue)</span><br><span class="line">            <span class="keyword">this</span>.value = +<span class="keyword">this</span>.value + <span class="number">1</span>;</span><br><span class="line">        mTxtNum.setText(value + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">numSub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getValue();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value &gt; minValue)</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="keyword">this</span>.value - <span class="number">1</span>;</span><br><span class="line">        mTxtNum.setText(value + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = mTxtNum.getText().toString();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(value))</span><br><span class="line">            <span class="keyword">this</span>.value = Integer.parseInt(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        mTxtNum.setText(value + <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxValue</span><span class="params">(<span class="keyword">int</span> maxValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxValue = maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinValue</span><span class="params">(<span class="keyword">int</span> minValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.minValue = minValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEditTextBackground</span><span class="params">(Drawable drawable)</span> </span>&#123;</span><br><span class="line">        mTxtNum.setBackgroundDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEditTextBackground</span><span class="params">(<span class="keyword">int</span> drawableId)</span> </span>&#123;</span><br><span class="line">        setEditTextBackground(getResources().getDrawable(drawableId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setButtonAddBackgroud</span><span class="params">(Drawable backgroud)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBtnAdd.setBackground(backgroud);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setButtonSubBackgroud</span><span class="params">(Drawable backgroud)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBtnSub.setBackground(backgroud);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnButtonClickListener</span><span class="params">(OnButtonClickListenr onButtonClickListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onButtonClickListener = onButtonClickListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnButtonClickListenr</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">onButtonAddClick</span><span class="params">(View view, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">onButtonSubClick</span><span class="params">(View view, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;按照国际惯例，我们先初始化控件，然后再读取自定义属性值并赋值，最后再根据具体的点击按钮提供相应的点击事件，这样一来我们就完成了这个自定义控件的基本功能，还是挺简单的有木有，为了学习记录的完整性，下面贴出运行 Activity 界面布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/orange"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">"5dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.CardView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardBackgroundColor</span>=<span class="string">"@color/white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardCornerRadius</span>=<span class="string">"13dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginLeft</span>=<span class="string">"15dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/drawee_view"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"180dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"180dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:src</span>=<span class="string">"@drawable/ak74"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_marginLeft</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/text_title"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_marginTop</span>=<span class="string">"20dp"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:maxLines</span>=<span class="string">"3"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:text</span>=<span class="string">"武器型号：AK47步枪 弹匣容量：30"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:textColor</span>=<span class="string">"@color/gray"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:textSize</span>=<span class="string">"16sp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/txt_price"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_gravity</span>=<span class="string">"right"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:text</span>=<span class="string">"400$"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:textColor</span>=<span class="string">"@color/crimson"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:textSize</span>=<span class="string">"18sp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">com.example.binshao.cainiaoshop.widget.NumberAddSubView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/number_control"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_marginTop</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">app:minValue</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.v7.widget.CardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到这里这一篇学习记录就差不多接近尾声了，当然了，上面这些也只是一些 Demo，还有很多地方需要完善，比如点击数量选择器时，价格也可以跟着改变等等……</p><p>&emsp;&emsp;好了，该撤了，读马克思去……<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自定义控件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>扎心的八月</title>
      <link href="/2018/08/30/Aug/"/>
      <url>/2018/08/30/Aug/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，人生中最后一个暑假假期就剩下两天了，余额严重不足感……  </p></blockquote><p>&emsp;&emsp;好些天没来记录了，这段时间都用来养病去了，以至于感觉过的没那么充实却又觉意义深远，今天家这边大雨倾盆，竟然有些凉意。</p><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhr6hv2iaj30j60eeadu.jpg" alt=""></div></p><h2 id="糟糕的八月"><a href="#糟糕的八月" class="headerlink" title="糟糕的八月"></a>糟糕的八月</h2><p>&emsp;&emsp;假期这段时间以来，大多数时间就在电脑前敲代码、查阅技术书籍，记录学习过程并总结成文，就这样一天过一天，时间如流水，转眼就来到月，也不知道是哪天感觉双眼发烫，眨眼间有种胀痛感，镜子前一看双眼充红，这一下给吓得不行，赶紧找大夫去…</p><p>&emsp;&emsp;接下来这段时间自然便是与药片相伴的日子，因用眼过度导致眼疲劳，一不小心病毒就入侵了，病毒侵占成功并大肆举起红旗，颇有得意之感。双眼看起来就像杀红了眼…每隔 2 小时就得滴眼药水，这种状态一直持续了好久，还记得养病期间和老友们去影院看电影，全程都在闭着眼睛没怎么看电影，过后还被批评不走心（你看我一脸委屈脸，哭），现在想想还觉得挺好笑，哈哈！<br><br></p><h2 id="用眼指南"><a href="#用眼指南" class="headerlink" title="用眼指南"></a>用眼指南</h2><p>&emsp;&emsp;既然出了问题就要找出问题所在，我回顾了下，长期坐在电脑跟前不动这算其一，放松娱乐就是下意识拿起手机，真当身体是刀枪不入？这样子下来眼睛肯定受不了，是该学点养生知识了：  </p><ul><li>泡点菊花枸杞茶喝喝.  </li><li>使用电脑每隔 <code>四五十</code> 分钟起身走走，让眼睛眺望远处放松放松.</li><li>有意识地增加眨眼次数.</li><li>做做眼保健操.</li><li>保证充足的睡眠.</li><li>真的要加强锻炼身体.</li></ul><p>&emsp;&emsp;是不是俨然一副手拿保温杯养生老干部的样子，高手在民间，呵…</p><p>&emsp;&emsp;经过这段时间的休息，眼睛也恢复的差不多了，然而我的假期就快要结束了，没有想到会这样度过这最后一个暑假期，我想这还真是让人印象深刻阿！吃一垫，长一智！这看似糟糕的八月，却敲响了警钟，我们始终认为自己还年轻，可事实却告诉我们这是在玩火！</p><p>&emsp;&emsp;最后希望大家都有一个强壮健康的身体！<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 时光任意门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活杂谈 </tag>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈 runOnUiThread</title>
      <link href="/2018/08/17/runOnUiThread/"/>
      <url>/2018/08/17/runOnUiThread/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，今天对咱来说还是不太友好的，咱还是先回避回避…</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhseqpzjpj30j60b1ta1.jpg" alt=""></div></p><p>&emsp;&emsp;上篇学习记录中我们提到了 IntentService 并且是把它大致工作流程简单走了一遍，来一个传送门：<a href="https://binshao.site/2018/08/16/IntentService/">IntentService 的深入理解</a> 。</p><p>&emsp;&emsp;一方面十三是非常害怕哪里理解错或者说是理解的不够深入，但是既然是学习记录我就把学习过程记录下来，也好让自己加深印象，还望各位大牛同学一起指出错误，指点下愚钝的十三。</p><a id="more"></a><p><br></p><h2 id="runOnUiThread"><a href="#runOnUiThread" class="headerlink" title="runOnUiThread"></a>runOnUiThread</h2><p>&emsp;&emsp;那么今天我们就来看看 runOnUiThread，这是一种更加简洁的写法，它是 Activity 提供的方法，首先我们先来看看文档对它的介绍：</p><blockquote><p>Runs the specified action on the UI thread. If the current thread is the UI thread, then the action is executed immediately. If the current thread is not the UI thread, the action is posted to the event queue of the UI thread.</p></blockquote><p>&emsp;&emsp;大概意思是说：在 UI 线程上运行指定的操作。如果当前线程是 UI 线程，则立即执行该操作。如果当前线程不是 UI 线程，则将操作发布到 UI 线程的事件队列。</p><p>&emsp;&emsp;runOnUiThread 相信大家平时使用中也非常常用，那么这里我们先不说那么多，先来个小例子实战演示下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main4);</span><br><span class="line">        mTextView = findViewById(R.id.response_text);</span><br><span class="line">        Button mButton = findViewById(R.id.send_request);</span><br><span class="line">        mButton.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.send_request) &#123;</span><br><span class="line">            sendRequest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                HttpURLConnection conn = <span class="keyword">null</span>;</span><br><span class="line">                BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    URL url = <span class="keyword">new</span> URL(<span class="string">"https://www.vip.com"</span>);</span><br><span class="line">                    conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">                    conn.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">                    conn.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line">                    conn.setReadTimeout(<span class="number">5000</span>);</span><br><span class="line">                    InputStream in = conn.getInputStream();</span><br><span class="line">                    reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">                    StringBuilder response = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    String line;</span><br><span class="line">                    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        response.append(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                    showResponse(response.toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            reader.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        conn.disconnect();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showResponse</span><span class="params">(<span class="keyword">final</span> String s)</span> </span>&#123;</span><br><span class="line">        runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mTextView.setText(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码非常简单，我们点击按钮就请求访问一个 URL 站点，然后我们使用 runOnUiThread 这个方法把请求结果展示到 UI 界面上。这里我们简单的布局代码就不贴了，我们来看看演示：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhseb5cpvg307o0d54qp.gif" alt=""></div></p><p>&emsp;&emsp;从演示结果中我们可以得到请求后的一堆 H5 代码，说明我们访问请求成功并得到响应，而 runOnUiThread 方法也的确好用，我们只需要关心更新 UI 操作即可，确实是更加简洁了。<br><br></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>&emsp;&emsp;那么我们可能会好奇它是怎么做到的，我们就得去看看它的源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">            mHandler.post(action);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            action.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先它会先判断当前线程是否是 UI 线程，不是就调用 Handler 的 post 方法；是就直接调用 Runnable 的 run 方法。正如文档介绍那样，相信有了前些篇学习记录的基础上，这里的源码就知道是什么意思了，嘿嘿…十三也不瞎 BB 了，免得又说啰嗦了。<br><br></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>&emsp;&emsp;说实话，今天这一篇学习记录还挺短的，难道是今天想偷懒？不不不，我们前面就把 Handler 相关的知识做了个总结，那么到 runOnUiThread 这里也是和 Handler 有很大关系，这算不算是以不变应万变呢？</p><p>&emsp;&emsp;到这里，我们这一系列的学习记录算是完结了，我们先从线程以及线程池开始，接着从异步消息机制再到这里，脑袋都不够用，然而十三总觉得这还仅是些皮毛，还有好多东西都不知道不了解的，一步步来！</p><p>最后来一波系列回顾：</p><ol><li><p><a href="https://binshao.site/2018/08/08/ThreadPool/">Android中的线程池</a></p></li><li><p><a href="https://binshao.site/2018/08/10/AsyncTask/">AsyncTask 的深入理解</a></p></li><li><p><a href="https://binshao.site/2018/08/12/Handler/">Handler 的深入理解</a></p></li><li><p><a href="https://binshao.site/2018/08/13/HandlerThread/">HandlerThread 的深入理解</a></p></li><li><p><a href="https://binshao.site/2018/08/16/IntentService/">IntentService 的深入理解</a></p></li></ol><p>&emsp;&emsp;这一系列的学习回想起来真是好艰苦阿，前前后后不知道看了多少遍，种瓜得瓜，种豆得豆，刻苦的学习过程带来的还是知识的收获，最后我再反问自己，标题都是深入理解，那么自己是真的深入理解吗？<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> runOnUiThread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IntentService 的深入理解</title>
      <link href="/2018/08/16/IntentService/"/>
      <url>/2018/08/16/IntentService/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，快要七夕了，这个中国版情人节朋友圈估计又是刷屏的节奏，不知道大家打算好怎么过呢？</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhruw8gh6j30j60csjsq.jpg" alt=""></div></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;平时我们在开发中，需要执行耗时的任务操作我们可能会交给 Service 去处理，并且为了避免 ANR，通常我们会在服务里开启子线程执行这些耗时的操作，比如如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们知道 Service 一旦启动之后，就会一直处于运行状态，那么我们就要调用 stopService() 或者 stopSelf() 方法可以使 Service 停止运行状态，这些都是基础知识，相信大家都滚瓜烂熟了，十三也就不 BB 了，Google 也提供了一个 IntentService 这个类同样也能帮助我们解决上面这些问题。</p><p>&emsp;&emsp;而我们在上一篇学习记录中提到 HandlerThread，其实它在 Android 中的具体使用场景是 IntentService，这里我们先来个传送门：<a href="https://binshao.site/2018/08/13/HandlerThread/">HandlerThread 的深入理解</a> 。<br><br></p><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>&emsp;&emsp;首先我们先来看看文档对它的介绍：</p><blockquote><p>IntentService is a base class for Services that handle asynchronous requests (expressed as Intents) on demand. Clients send requests through Context.startService(Intent) calls; the service is started as needed, handles each Intent in turn using a worker thread, and stops itself when it runs out of work.</p></blockquote><p>&emsp;&emsp;大概就是说 IntentService 继承自 Service 类，我们可以用它来处理异步请求，客户端通过调用 Context.startService(Intent) 发送请求，服务会在需要的时候启动，并且使用工作线程执行任务是依次处理每个 Intent 的，在完成所有任务后会自己停止运行状态。</p><p>&emsp;&emsp;通过上面的了解，相比于普通的 Service，我们不用再创建子线程并且也不用操心手动停止 Service 了，就好像是手动点火炸药进化到遥控炸弹那样，很方便有木有，那么下面我们来做个小例子演示怎么使用 IntentService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> android.os.Handler mUIHandler;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT_MSG = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUIHandler</span><span class="params">(android.os.Handler UIHandler)</span> </span>&#123;</span><br><span class="line">        mUIHandler = UIHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"MyIntentService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"MyIntentService"</span>, <span class="string">"Thread id："</span> + Thread.currentThread().getId());</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">           sb.append(Thread.currentThread().getName() + Thread.currentThread().getId())</span><br><span class="line">                   .append(<span class="string">"\n"</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           sendMessageToMainThread(WHAT_MSG, sb.toString());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessageToMainThread</span><span class="params">(<span class="keyword">int</span> id, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mUIHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mUIHandler.sendMessage(mUIHandler.obtainMessage(id, obj));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.i(<span class="string">"MyIntentService"</span>, <span class="string">"onDestroy()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们新建了个类并继承自 IntentService，首先我们要提供一个无参的构造方法并调用父类的构造方法，接着实现 onHandlerIntent() 这个抽象方法，我们在这里分别打印 三 次当前线程名和 id。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main6Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main6);</span><br><span class="line">        mTextView = findViewById(R.id.text_info);</span><br><span class="line">        MyIntentService.setUIHandler(<span class="keyword">new</span> Handler(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">btnClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.start_service) &#123;</span><br><span class="line">            Intent intentService = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyIntentService.class);</span><br><span class="line">            startService(intentService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MyIntentService.WHAT_MSG:</span><br><span class="line">                    mTextView.setText((String)msg.obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着 Activity 里的代码，就是点击按钮我们就启动服务，并让服务去执行任务最后并把执行任务的结果显示到 UI 上，代码非常简单，十三也就不多说了，来看看运行效果演示吧：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhruhyuepg30bn07bn0c.gif" alt=""></div></p><p>&emsp;&emsp;可以看到每点击次按钮就会执行三次打印，并且每次打印的线程名和 id 都是一样的，那么我们再来看看 logcat 中的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I/MyIntentService: Thread id：2788</span><br><span class="line">I/MyIntentService: onDestroy()</span><br><span class="line">I/MyIntentService: Thread id：2789</span><br><span class="line">I/MyIntentService: onDestroy()</span><br><span class="line">I/MyIntentService: Thread id：2790</span><br><span class="line">I/MyIntentService: onDestroy()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的演示效果里我们可以看到，我们一共点击 3 次按钮，每一次执行 3 次打印输出，尽管每一次打印 3 次，可执行的还是同一个线程，当执行完最后一个任务的时候它会自己停止，也就是 onDestroy() 方法被调用。<br><br></p><h2 id="IntentService-深入学习"><a href="#IntentService-深入学习" class="headerlink" title="IntentService 深入学习"></a>IntentService 深入学习</h2><p>&emsp;&emsp;同样我们还是去看看它的源码实现，其实它的源码非常短，先给它来张全家福：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mRedelivery;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntentService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        mRedelivery = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mServiceLooper.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@WorkerThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;把注释一删掉后就没只有 65 行左右的代码，我们首先看到它继承自 Service 并且是个抽象类，所以我们都是创建它的子类来使用 IntentService，先来看看 onCreate 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate();</span><br><span class="line">       HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">       thread.start();</span><br><span class="line"></span><br><span class="line">       mServiceLooper = thread.getLooper();</span><br><span class="line">       mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当启动 IntentService 的时候 onCreate 方法会被调用，在方法中创建一个 HandlerThread 并去启动它，然后把 HandlerThread 的 Looper 对象传入到 mServiceHandler 中去，那么这个 mServiceHandler 又是什么呢？其实它是个 Handler，我们可以看看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个 ServiceHandler 类继承自 Handler，而前面我们说到 HandlerThread 的 Looper 对象又传入给它，所以这样通过 ServiceHandler 处理异步任务了。</p><p>&emsp;&emsp;那么我们可能就会疑问了？这个 IntentService 是怎么启动任务的呢，这个我们就得看看 onStartCommand() 方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在 onStartCommand 方法中又去调用 onStart() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而在 onStart 方法中，我们可以看到 IntentService 通过 mServiceHandler 发送了一条消息，那么这条消息就会在 HandlerThread 中处理，<code>注意，因为这里的 Looper 对象是 HandlerThead 中拥有的，</code>接着 mServiceHandler 收到消息会把 Intent 对象交给 handleMessage 方法处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而在 handleMessage 方法中又调用 onHandleIntent 方法并把 Intent 对象一同传入，事实上这个 Intent 就是我们在 startService 中传入的 intent 内容，当方法执行结束后，在 代码 9 行处 IntentService 通过 stopSelf(msg.arg1) 方法停止服务，原来这个自动停止服务状态的秘密在这里！</p><p>&emsp;&emsp;那么到这里，我们可能会好奇这个 onHandleIntent 方法为什么那么眼熟呢？我们赶紧去看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过源码我们知道，原来 IntentService 的 onHandleIntent 方法是一个抽象方法，所以我们在创建 IntentService 的时候必须实现该方法，而我们在前面的示例中也确实实现了该方法，同学们可以滑到前面去看看，怪不得那么眼熟呢！</p><p>&emsp;&emsp;假如此时有一个或者多个任务，那么 onHandleIntent 就会执行任务，直到执行任务完成后，stopSelf 就会自动停止服务状态。而且每次执行后台任务都会启动一次 IntentService，而 IntentService 通过发送消息到 HandlerThread 执行任务，并且我们知道 Looper 是按顺序执行任务的，所以当有多个任务执行时它们都是顺序排队执行的。<br><br></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>&emsp;&emsp;到这里，IntentService 的学习记录就接近尾声了，越来越觉得自己不知道不懂得还有很多了，可是都后头来还是觉得学习的同时还要注意身体健康，大家都要注意锻炼身体。</p><p>技术参考文献：<br>【鸿洋大神的博客】<a href="http://blog.csdn.net/lmj623565791/article/details/47143563" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/47143563</a><br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntentService </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HandlerThread 的深入理解</title>
      <link href="/2018/08/13/HandlerThread/"/>
      <url>/2018/08/13/HandlerThread/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，最近新出了一种以老师名字命名的语言——Julia，看到 Julia 相信懂的人自然就懂，嘿嘿，今晚秋名山见…</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrso0svzj30j60cs404.jpg" alt=""></div></p><p>在上篇学习记录中我们提到 Android 消息机制 Handler，并且我们也把它整个工作流程大概走了一篇，不知道十三就在说啥的同学请到这边的传送门接受安检：<a href="https://binshao.site/2018/08/12/Handler/">Handler 的深入理解</a>。</p><a id="more"></a><p>&emsp;&emsp;我们知道使用 Handler 就必须为线程创建 Looper，而主线程已经在初始化的时候为我们创建好了，所以我们可以直接使用 Handler，那么如果在子线程呢？这个问题也很好解决，相信大家在看了十三上一篇学习记录后也知道答案，我们就得这样来写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Looper.prepare();</span><br><span class="line"></span><br><span class="line">          mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                  ......</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          Looper.loop();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么这东西写一次两次还好，写多了就会觉得麻烦阿，感觉非常繁琐。这不，HandlerThread 就应运而生，那么我们来看看它有多方便。<br><br></p><h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><blockquote><p>Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called.</p></blockquote><p>&emsp;&emsp;首先我们来看看文档对它的介绍，大概意思就是说 HandlerThread 是一个包含 Looper 的类，我们可以直接使用这个 Looper 创建 Handler，注意的是必须调用 start() 方法。十三英语不好，翻译不规范还请大家多多见谅。</p><p>&emsp;&emsp;说了那么多咱们直接先用起来，下面我们用一个小例子来演示下使用过程，那个谁，放码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main5Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_UPDATE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">private</span> Handler msgHandler;</span><br><span class="line">    <span class="keyword">private</span> HandlerThread mThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main5);</span><br><span class="line">        mTextView = findViewById(R.id.id_textview);</span><br><span class="line">        initBackThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后台线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBackThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mThread = <span class="keyword">new</span> HandlerThread(<span class="string">"message"</span>);</span><br><span class="line">        mThread.start();</span><br><span class="line">        msgHandler = <span class="keyword">new</span> Handler(mThread.getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                updateInfo();</span><br><span class="line">                <span class="keyword">if</span> (isUpdate) &#123;</span><br><span class="line">                    msgHandler.sendEmptyMessageDelayed(MESSAGE_UPDATE, <span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    String data = <span class="string">"当前气温：&lt;font color='red'&gt;%d&lt;/font&gt; ℃"</span>;</span><br><span class="line">                    data = String.format(data, (<span class="keyword">int</span>) (Math.random() * <span class="number">39</span> + <span class="number">1</span>));</span><br><span class="line">                    mTextView.setText(Html.fromHtml(data));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        isUpdate = <span class="keyword">true</span>;</span><br><span class="line">        msgHandler.sendEmptyMessage(MESSAGE_UPDATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        isUpdate = <span class="keyword">false</span>;</span><br><span class="line">        msgHandler.removeMessages(MESSAGE_UPDATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mThread.quit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里布局文件代码就不贴出来了，就一个 TextView，最后我们来看看效果演示：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrs2jns9g30ac06jgpb.gif" alt=""></div></p><p>&emsp;&emsp;可以看到这里的气温变化还是蛮大的，就像是女人的心情…主要是随机数范围没写好，嘿嘿，我们代码中去获取天气数据是个耗时操作，所以我们通过 HandlerThread 去获取 Looper，然后通过 Handler 的 post(Runnable r) 并在 handleMessage 方法里进行处理，感觉很方便有没有，并且很方便进行线程间的通信。<br>那么这时候问题就来了，它是怎么做到的呢？<br><br></p><h2 id="HandlerThread-的深入学习"><a href="#HandlerThread-的深入学习" class="headerlink" title="HandlerThread 的深入学习"></a>HandlerThread 的深入学习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原来 HandlerThread 继承了 Thread，所以一定不要忘了调用 start() 方法，那么既然本质上是个线程，那么下面我们去看看它的 run 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到在 run 方法中，在代码 4 行处，它调用 Looper.prepare() 创建一个 Looper 对象，然后又调用了 Looper.loop 方法开启消息循环并从队列中取消息，看到这里我们明白原来它把脏活累活都帮我们干了，如此一来，在 HandlerThread 中我们可以创建 Handler 了。</p><p>&emsp;&emsp;那么在代码 10 行处，有同学眼尖可能已经发现，这个 onLooperPrepared() 又是个什么东东呢？我们接着跟进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call back method that can be explicitly overridden if needed to execute some</span></span><br><span class="line"><span class="comment"> * setup before Looper loops.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们发现它是个空方法，通过注释也可以看到，我们可以在 Looper.prepare()创建完后做些初始化的工作，那么我们只需要重写这个方法。</p><p>&emsp;&emsp;下面我们来看看 getLooper 这个方法，还记得上面我们例子中使用的这个方法吗，我们在构造 Handler 时传入 Looper 是通过这个方法的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgHandler = new Handler(mThread.getLooper())</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么我们来看看它在源码中的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment"> * or for any reason isAlive() returns false, this method will return null. If this thread</span></span><br><span class="line"><span class="comment"> * has been started, this method will block until the looper has been initialized.  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此方法返回与此线程关联的 Looper。如果此线程未启动或由于任何原因 isAlive() 返回 false，则此方法将返回null。如果此线程已启动，则此方法将阻塞，直到looper已初始化为止。也就是说它返回的是在 run 方法中创建的 mLooper。</p><p>&emsp;&emsp;此外我们再看看 quit 和 quitSafely 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们知道由于 HandlerThread 的 run 方法是会一直循环的，所以当我们不再需要 HandlerThread 的时候，我们可以通过 quit 或 quitSafely 方法来结束线程的执行，在前面的例子中我们也要使用，同学们可以滑到前面看看。<br><br></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>&emsp;&emsp;看到这里，关于 HandlerThread 的学习记录就差不多到了尾声，相信有了前篇 Handler 学习记录的基础上，再看 HandlerThread 会显得比较轻松，HandlerThread 它是一个帮我们创建了 Looper 的线程，并且我们可以在线程中使用 Handler 处理后台任务。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HandlerThread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Handler 的深入理解</title>
      <link href="/2018/08/12/Handler/"/>
      <url>/2018/08/12/Handler/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，感觉最近肉欲好强，好想吃烤肉、各种肉肉…</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrrgva5qj30j60crgot.jpg" alt=""></div></p><p>&emsp;&emsp;在上些篇学习记录里我们提到了 AsyncTask 并且算是把它的大体源码流程走了一遍，实际上 AsyncTask 封装了 Thread 和 Handler，正是它完好的封装使得我们无需关心太多。这里来个传送门：<a href="https://binshao.site/2018/08/10/AsyncTask/">AsyncTask 的深入理解</a> 。</p><a id="more"></a><p>&emsp;&emsp;说到了 Handler，想必大家也是很熟悉了，还记得十三刚学习 Android 那会儿要在主线程更新 UI，第一个先接触的就是它。<br><br></p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>&emsp;&emsp;通常我们所说的异步消息处理机制主要是指 Handler 的运行机制，它主要由 Message、Handler、MessageQueue 和 Looper 所组成，老规矩，我们先来看看它们的概念介绍：</p><ul><li><p>Message：顾名思义，它是在线程之间传递的信息，可携带少量的信息在不同线程间交换数据.</p></li><li><p>Handler：主要用于发送和处理消息的，一般我们通过调用它的 sendMessage() 方法发送消息，最终消息又传递到 HandlerMessage() 方法中.</p></li><li><p>MessageQueue：消息队列，主要用于存放所有通过 Handler 发送的消息，<code>每个线程中只会有一个 MessageQueue 对象.</code></p></li><li><p>Looper：在这里我们可以理解为消息循环，前面我们提到了 MessageQueue 会对消息进行存储，那么 Looper 就会去查找并处理消息，<code>注意：它可是已无限循环的形式存在，没有消息则会一直等待着.</code></p></li></ul><p>&emsp;&emsp;概念介绍完后，我们把 Handler 的整个工作流程大致捋一遍：</p><p>&emsp;&emsp;首先我们需要在主线程中创建 Handler 对象并重写 handlerMessage() 方法，接着当我们在子线程中需要对 UI 进行访问时，我们就会创建一个 Message 对象，并通过 Handler 把这条信息发送出去，之后这条信息就会被添加到 MessageQueue 队列中等待处理，而我们的 Looper 则会很勤劳，它会从 MessageQueue 队列中取出消息，并把消息发回到 Handler 的 handlerMessage() 方法里，这样一来执行环境便切换到主线程当中了，我们便也能对 UI 进行操作。</p><p>&emsp;&emsp;下面我们就快速来写个小例子，演示下效果，相信各位老司机都是信手捏来了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main3Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANGE_TEXT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Button mButton;</span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> CHANGE_TEXT:</span><br><span class="line">                   mTextView.setText(<span class="string">"十三"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main3);</span><br><span class="line">        mTextView = findViewById(R.id.text);</span><br><span class="line">        mButton = findViewById(R.id.button);</span><br><span class="line">        mButton.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.button) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Message message = <span class="keyword">new</span> Message();</span><br><span class="line">                    message.what = CHANGE_TEXT;</span><br><span class="line">                    handler.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrqyersbg30au073t9g.gif" alt=""><br><br></div></p><h2 id="Handler-的深入学习"><a href="#Handler-的深入学习" class="headerlink" title="Handler 的深入学习"></a>Handler 的深入学习</h2><p>&emsp;&emsp;我们仅仅会调用 Api 还是不够的，我们得透过现象看本质，去学习它的原理。我们知道线程本来是没有 Looper 的，而 Handler 创建的时候会采用当前线程的 Looper 构造消息循环系统，所以这就要求我们使用 Handler 的时候就要为线程创建了 Looper ，这里可能有同学会有疑问了，没有吧，我平时为什么直接创建 Handler 就可以愉快地使用了？——实际上，我们平时可以直接在主线程中创建 Handler ，是因为主线程已经帮我们初始化好了 Looper，我们通过源码就可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">        <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">        <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">        EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">        <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在 21 行代码处，我们可以看到调用 Looper.prepareMainLooper() 方法，而我们进一步跟进去，源码声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;prepareMainLooper() 方法中又调用 prepare 方法，ThreadLocal 是一个线程内部的数据存储类，而我们的 Looper 显然则是通过它存取在线程中。在 prepare 方法中先对 sThreadLocal 进行判断是否存在 Looper 对象，没有则创建 Looper 对象，这样一来主线程中便有了 Looper 对象，这也是我们默认能够直接使用 Handler 的原因。</p><p>&emsp;&emsp;可能到这里，有同学和十三一样有个疑问了，那我要在子线程中创建 Handler 而不是主线程中创建，会怎么样？那么我会告诉你，你可能连第一关都过不了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先在 11 行代码处，先通过 Looper.myLooper() 方法获得 Looper，这个方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果这时候没有 Looper 那么就会抛出异常，这也就是在没有 Looper 的子线程中创建 Handler 会引发程序异常的原因。那么我们应该怎么解决呢，其实办法从我们上面的分析也能想到，那就是调用 Looper.prepare 方法就可以了。</p><p>&emsp;&emsp;创建 Handler 后我们接下来当然就是发送消息了，通常我们都是 sendMessage 方法进行消息的发送，那我们下面就一起来看看这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从 sendMessage 方法一直调用到 sendMessageAtTime 这个方法里来，其实 Handler 发送消息的过程就是向 MessageQueue 消息队列中插入消息，在代码 22 行处我们可以看到调用这个 enqueueMessage 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先把 msg.target = this，也就是指当前发送消息的这个 Handler，然后把当前这个消息插入到消息队列中去。<br><br></p><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>&emsp;&emsp;前面说到 Handler 发送消息后就是把消息插入到消息队列中，下面我们来看看插入消息的 enqueueMessage 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">                <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">                <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;MessageQueue 实际上就是通过单链表来维护消息列表的，从上面的操作主要也还是对单链表进行插入操作，在代码 43 行处，调用 next 方法，它会从消息列表中取出消息并把消息从列表移除，我们去看它的源码时可以看到它是个无限循环的方法，如果消息队列中有新插入的消息，next 方法就会返回这条消息并把这条消息从单链表中移除，总不可能一直占着茅坑吧！而如果消息队列中没有消息，那么 next 方法就会一直阻塞，直到等待新插入消息到来，至于 next 方法的源码就不贴了，有点长…<br><br></p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>&emsp;&emsp;MessageQueue 消息队列存储着消息，而负责处理我们的消息便是 Looper，它非常勤奋，一直不停地从 MessageQueue 中查看是否有新消息，如果有就立即处理否则一直等待新消息。不知道大家有没有感觉到它怎么和上边的 next 方法有点相似啊，这样一说还真的是，我们耐着心思继续往下看，Looper 有个 loop 方法，当调用 loop 方法后消息循环系统才会工作起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> start = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> time = end - start;</span><br><span class="line">                <span class="keyword">if</span> (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Dispatch took "</span> + time + <span class="string">"ms on "</span></span><br><span class="line">                            + Thread.currentThread().getName() + <span class="string">", h="</span> +</span><br><span class="line">                            msg.target + <span class="string">" cb="</span> + msg.callback + <span class="string">" msg="</span> + msg.what);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们看到 loop 方法同样也是一个死循环，在代码 14 行处我们能看到它调用了 MessageQueue 的 next 方法，并在下一行对它进行是否为空的判断，跳出这个死循环就看这个 MessageQueue 的 next 为 null，否则 loop 方法就会一直循环下去。</p><p>&emsp;&emsp;也就是说，loop 方法会调用 MessageQueue 的 next 方法来获取最新的消息，前面我们分析到 next 方法是一个阻塞操作，当没有消息的时候它会一直阻塞着，而这样也会导致我们的 loop 方法同样也会一直阻塞着；而假如这时候有了新消息，那么 loop 也会处理这条消息，真的是难兄难弟阿！</p><p>&emsp;&emsp;那么 Looper 怎么来处理消息呢？在 36 行处 msg.target.dispatchMessage(msg)，这里的 msg.target 就是我们前面说过的发送这条消息的 Handler 对象，然后发送的消息又交给这个 Handler 对象的 dispatchMessage 方法来进行处理，那我们就来看看这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先对 msg.callback 进行非空的判断，不为空就调用 handleCallback 方法进行对消息的处理，否则就调用 handleMessage 方法处理消息，那我们首先来看看这个 handleMessage 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到注释，其实这个 handleMessage 也就是我们平时重写的方法，通常我们在里面进行对消息的判断并执行 UI 操作。</p><p>&emsp;&emsp;而这个 handleCallback 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Message 的 callback 其实是一个 Runnable 对象，我们知道通过 Handler 的 post 方法也可以在子线程中对 UI 进行访问，看看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line"><span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;它调用了 sendMessageDelayed 方法发送消息，那么参数里的这个 getPostMessage 又是什么呢？我们接着往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看到代码 3 行处，它把 Runnable 对象转换成了转换成了消息，然后我们再看回 handleCallback 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原来这里的 message.callback 就是 Handler 的 post 方法所传递的 Runnable 参数，然后调用了一开始传入的 Runnable 对象的 run() 方法。这样和我们在 handleMessage 方法中操作 UI 的原理是一样的。<br><br></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>&emsp;&emsp;到这里，这篇 Handler 的学习记录就到尾声了，说实话是真的累，有同学说十三你瞎忙什么呀，网上大把这些文章。我想说看别人文章那只是看，要想把知识变成自己的，还是需要自己手把手把完整流程走一遍，不信你看看，走一遍你就发现自己会遇到很多问题。</p><p>技术参考文献：<br>【郭霖大神的博客】<a href="http://blog.csdn.net/guolin_blog/article/details/9991569" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/9991569</a><br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Handler </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之命令模式</title>
      <link href="/2018/08/11/Command/"/>
      <url>/2018/08/11/Command/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，看来真的要开始关注养生这方面了，感觉视力蹭蹭地往下掉阿，我还年轻阿…</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve188862tj30u00k0ace.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;不知道大家是否和十三一样是个 FPS 游戏爱好者，还记得《使命召唤4》里有一关普莱斯和麦克米兰一起狙击扎卡耶夫的情景吗？十三最喜欢这种潜入剧情的关卡了，个人感觉使命召唤现代战争(4，6和8代)剧情是最经典，最好看的。大家感兴趣的话可以去看看，这里推荐一个 B 站的 Up 主叫做哲学的石头，他的打法真的是一路凶残到底，喜欢这种这么凶猛的玩家，希望各位读者不嫌十三罗嗦老谈使命召唤，嘿嘿！</p><p>&emsp;&emsp;好了，废话就不多说了，其实那个狙击的场景可以用到我们设计模式中的命令模式，那么下面我们就来看看什么是命令模式。<br><br></p><h2 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式(Command)"></a>命令模式(Command)</h2><p>&emsp;&emsp;命令模式将一个请求封装为一个对象，从而使得我们可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p><p>命令模式中的角色和职责：</p><ul><li><p>Command：抽象命令类，用来声明执行操作的接口.</p></li><li><p>ConcreteCommand：将一个接收者对象绑定于一个动作，调用接收者相应的操作以实现 Execute.</p></li><li><p>Receiver：接收者，用来实施执行一个请求相关的操作.</p></li><li><p>Invoker：请求者，要求该命令执行这个请求.</p></li></ul><p>&emsp;&emsp;理论概念一大堆，大家是不是都一脸懵逼，下面我们一起来写个小例子看看命令模式的简单应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先是 Command 类，用来声明执行操作的接口并且里面提供了 execute 的方法，执行的意思。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着就是 ConcreteCommand 类，它实现了 Command 接口并重写方法，它还持有了 Receiver 类的引用，也就是持有接受者这个类的引用，然后在重写的方法里调用 receiver 的 action 方法，那么这个 Receiver 类是什么，下面我们来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狙击手：收到，目标已击毙.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Receiver 好比于是命令的执行者，它知道如何去执行命令相关的操作。这里回到使命召唤里的剧情，当我们收到上级的命令，我们作为战士肯定要去执行这个任务，那么有命令的执行者，就有命令的发起者，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoke</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoke</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"指挥部：目标对象已出现，立即击毙.."</span>);</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个命令的发起者也就是我们的 Invoke 这个类，它发起了请求并命令执行这个请求。就好比于上级指挥部下达命令，下级战士收到命令并去执行命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Command c = <span class="keyword">new</span> ConcreteCommand(<span class="keyword">new</span> Receiver());</span><br><span class="line">        Invoke i = <span class="keyword">new</span> Invoke(c);</span><br><span class="line">        i.call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们来完成客户端代码，首先我们创建一个具体命令对象并设定它的接收者，接着我们再创建一个请求者并要求执行请求，同样由于它持有我们的 Command 类的引用，所以下达的命令是能够到达命令执行者那里去的，这样执行者收到命令就可以去执行命令了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果:</span><br><span class="line">指挥部：目标对象已出现，立即击毙..</span><br><span class="line">狙击手：收到，目标已击毙..</span><br></pre></td></tr></table></figure><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面我们同样还是来总结下：</p><p>常见场景：</p><ul><li><p>数据库事务机制的底层实现.</p></li><li><p>命令的撤销和恢复.</p></li><li><p>Struts 2 中 action 的调用过程.</p></li></ul><p>&emsp;&emsp;命令模式能比较容易地设计一个命令队列，这里我们的例子其实还是可以用一个容器来装载我们的一系列命令。其实命令模式还可以实现对请求的撤销和恢复，并且每添加新的具体命令类是不会影响其他的类。</p><p>&emsp;&emsp;不过平时在我们开发中，感觉命令模式我们不太用得到，这里的学习记录就偷个懒吧，好了，养生去了……<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AsyncTask 的深入理解</title>
      <link href="/2018/08/10/AsyncTask/"/>
      <url>/2018/08/10/AsyncTask/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，眨眼间人生中最后一个暑假期已经过去了一大半了，最是时间留不住…我想老朋友了、我想出去玩、我还想去见见那个谁。</p></blockquote><p>&emsp;&emsp;上篇学习记录中我们记录了 Android 中线程及线程池 的应用，一脸懵逼不知道什么情况的同学请到传送门接受安检： <a href="https://binshao.site/2018/08/08/ThreadPool/">Android 中的线程池</a> 。</p><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve0njtkorj30zk0jz78c.jpg" alt=""></div></p><p>&emsp;&emsp;主线程更新是个老生常谈的话题，当我们通过线程去执行耗时的任务，并在操作完成后可能还要更新 UI，为了方便开发者在子线程对 UI 进行操作， Google 则提供如 Handler、AsyncTask 等工具帮助我们解决这个问题。那么今天我们下面我们来看看 AsyncTask。<br><br></p><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>&emsp;&emsp;对于 AsyncTask，各位老司机肯定都用烂了…它是一种轻量级的异步任务类，借助 AsyncTask 我们可以很轻松地从子线程切换到主线程，更加方便地执行后台耗时任务和切换到主线程中去访问 UI，但是不太建议在 AsyncTask 中进行太过耗时的后台任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的源码中我们可以看到 AsyncTask 是一个抽象类，并且它提供了 三 个泛型参数，所以我们要使用它都是创建个子类去继承它，并指定 三个泛型参数，它们的含义分别如下：</p><ul><li><p>Params：在执行时 AsyncTask 需要传入的参数，用于在后台任务中使用.</p></li><li><p>Progress：表示后台任务执行进度的类型.</p></li><li><p>Result：当任务执行完成后，返回结果的类型.</p></li></ul><p>这些参数在平时开发中，我们可以根据自己的实际需要去定义类型，假设我们都不需要可以用 Void 代替。</p><p>接下来我们来看看 AsyncTask 提供的一些重要方法，如下：</p><ul><li><p>onPreExecute()：这个方法在主线程中执行，它会在后台任务执行之前调用，用于在界面进行一些初始化的操作.</p></li><li><p>doInBackground(Params…params)：这个方法会在子线程中运行，它会在 onPreExecute()<br>方法执行后运行，通常我们会在这里进行耗时任务的执行，任务执行完成后通过 return 把结果返回。<code>注意，我们不能在此进行 UI 操作，我们可以通过调用 PublishProgress 方法更新任务的进度.</code></p></li><li><p>onProgressUpdate(Progress..values)：这个方法在主线程中执行，在上一步中我们通过调用 PublishProgress 方法后，它就会被调用，也就是说当后台任务的执行进度发生改变的时候它就会被调用，我们可以在这里进行 UI 更新操作.</p></li><li><p>onPostExecute(Result result)：当后台任务执行完成后并且通过 return 返回结果时，这个方法就会被调用，我们可以利用返回结果进行 UI 更新操作.</p></li></ul><p>&emsp;&emsp;理论概念说了一大堆，还是要动手实践下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line">    <span class="keyword">private</span> SeekBar seekBar;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main2);</span><br><span class="line">        button = findViewById(R.id.button);</span><br><span class="line">        textView = findViewById(R.id.textView);</span><br><span class="line">        seekBar = findViewById(R.id.seekBar);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                MyAsyncTask myTask = <span class="keyword">new</span> MyAsyncTask(textView, seekBar);</span><br><span class="line">                Toast.makeText(Main2Activity.<span class="keyword">this</span>, <span class="string">"开始下载"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                myTask.execute(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView txt;</span><br><span class="line">    <span class="keyword">private</span> SeekBar seekBar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAsyncTask</span><span class="params">(TextView txt, SeekBar seekBar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.txt = txt;</span><br><span class="line">        <span class="keyword">this</span>.seekBar = seekBar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DelayOperator dop = <span class="keyword">new</span> DelayOperator();</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">10</span>; i &lt;= <span class="number">1000</span>; i += <span class="number">10</span>) &#123;</span><br><span class="line">                dop.delay();</span><br><span class="line">                publishProgress(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + params[<span class="number">0</span>].intValue() + <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            txt.setText(<span class="string">"拼命下载ing..."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = values[<span class="number">0</span>];</span><br><span class="line">        seekBar.setProgress(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayOperator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的布局很简单，十三就不贴布局代码了。下面我们来看看效果演示：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve0vaclzug30b807fwfk.gif" alt=""></div></p><p>&emsp;&emsp;好了，到这里我们的 AsyncTask 的基本使用就介绍完了，AsyncTask 除了上面十三列举这些方法外，还提供了 onCancelled() 方法，当我们取消后台任务的时候就会被调用，既然任务被取消了，那么 onPostExecute() 最后也是不会被调用的了。</p><p>&emsp;&emsp;会使用 Api 还不满足的，我们得要深入去理解它的内在，不要浮于表面。阅读源码过程很痛苦，如同盲人摸象，摸不着底细。我们可以借助大神老司机的力量，自己拿好纸笔一遍遍去撸，去梳理，别无他法。<br><br></p><h2 id="深入理解-AsyncTask"><a href="#深入理解-AsyncTask" class="headerlink" title="深入理解 AsyncTask"></a>深入理解 AsyncTask</h2><p>&emsp;&emsp;在上面的例子中我们调用 AsyncTask 的 execute 方法，它便开始执行。那么我们就从 execute 这个方法入手，我们来看看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当我们平时调用 execute 方法执行 AsyncTask 时，它又去调用了 executeOnExecutor，那我们接着往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">            Params... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">                <span class="keyword">case</span> RUNNING:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                            + <span class="string">" the task is already running."</span>);</span><br><span class="line">                <span class="keyword">case</span> FINISHED:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                            + <span class="string">" the task has already been executed "</span></span><br><span class="line">                            + <span class="string">"(a task can be executed only once)"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">        onPreExecute();</span><br><span class="line"></span><br><span class="line">        mWorker.mParams = params;</span><br><span class="line">        exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在第 15 行中，先对 AsyncTask 的状态设置为 RUNNING，我们从上面的 switch 语句对状态进行判断可以看出，一个 AsyncTask 对象只能运行一次，否则就会报异常。接着我们又可以看到熟悉的 onPreExecute() 方法被调用了，而我们知道这个方法是在主线程中执行的，可以做些初始化操作。往下从第 19 行开始，我们可能又有疑问了，这又是什么，没见过？我们不妨拿出纸笔，做下个小标记，然后我们接着跟进去这个 mWorker：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">        Params[] mParams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们一路追踪找到这个 WorkerRunnable 这个类，我们可以看到它实现了 Callable 接口，我们知道实现 Callable 并且重写 call 方法可以用来实现多线程，那么看到这里好像没下文了？似乎我们的线索断了，别急，我们继续往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">        mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">            ? getMainHandler()</span><br><span class="line">            : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line"></span><br><span class="line">        mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">                Result result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                    <span class="comment">//noinspection unchecked</span></span><br><span class="line">                    result = doInBackground(mParams);</span><br><span class="line">                    Binder.flushPendingCommands();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                    mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">throw</span> tr;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    postResult(result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    postResultIfNotInvoked(get());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                    postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原来在我们的 AsyncTask 的构造方法里，mWorker 在这里进行的初始化，我们从上面知道 WorkerRunnable 它实现了 Callable 接口，并且在这里实现了 call 方法。在 call 方法中首先将 mTaskInvoked 设为 true，它表示的是当前任务被调用过了，接着在 13 行中又调用了 doInBackground(mParams) 方法执行任务，任务完成后在 19 行调用了 postResult(result) 把结果投送出去，这里先不贴它的源码，因为下面我们还要用到。</p><p>&emsp;&emsp;然后我们往 25 行看到 mFuture 并且看到 FutureTask 这个类，那我们跟进去看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的源码我们可以看到，FutureTask 它实现了 Runnable 和 Future 这两个接口，回到上面的源码中，我们发现 mWorker(WorkerRunnable) 作为参数传进了 FutureTask 中，到这里我们对于前面莫名出现的变量应该有个印象了，拿出纸笔记录下后，回到我们最开始的起点，这里我们再贴出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">            Params... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">                <span class="keyword">case</span> RUNNING:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                            + <span class="string">" the task is already running."</span>);</span><br><span class="line">                <span class="keyword">case</span> FINISHED:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                            + <span class="string">" the task has already been executed "</span></span><br><span class="line">                            + <span class="string">"(a task can be executed only once)"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">        onPreExecute();</span><br><span class="line"></span><br><span class="line">        mWorker.mParams = params;</span><br><span class="line">        exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们继续看到上次我们看到的 19 行，这里把 AsyncTask 的 params 参数传给 mWorker，通过前面的构造方法中我们已经分析到 mWorker 也就是 WorkerRunnable 又作为参数传给 FutrueTask 里面，我们拿出纸看看前面做下的记录，果然没错。接着往下，在 20 行中调用了 exec 的 execute 方法，并把我们的 mFuture(FutureTask) 作为参数传了进去，到这里我们就看完了这个方法，可这里有个疑问，这个 exec 是干什么的，这里我们做个记号后，回到我们最开始的源头 execute，我们再贴出源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们看到它调用了 executeOnExecutor 这个方法，<code>注意看第一个参数 sDefaultExecutor</code>原来上面我们疑惑的 exec 是这里传进来的参数 sDefaultExecutor，那我们就继续往下顺藤摸瓜看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">        Runnable mActive;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">            mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        r.run();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        scheduleNext();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduleNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们一路追踪找到这个静态类 SerialExecutor，实际上它是一个串行的线程池，内部维护着一个任务队列，在 9 行中我们看到之前调用的 execute 这个方法，我们之前的调用源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec.execute(mFuture);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们回过头来看看 mFuture(FutureTask) 它作为参数传入，也就是说 FutureTask 对象在这里充当了 Runnable 的作用，并把它加入到这里的 mTasks 中排队，最后不管是否有无任务，在 15 行中都会去调用 scheduleNext() 这个方法，而它的源码声明在 24 行，它会从 mTasks 中去取出任务并交给 THREAD_POOL_EXECUTOR 去执行任务。从这里我们知道原来，SerialExecutor 这个线程池是用来给任务排队的，而去执行任务的是 THREAD_POOL_EXECUTOR 这个线程池，并且默认情况下，AsyncTask 是串行执行的。</p><p>&emsp;&emsp;接着我们看 13 行中，前面我们说到 FutureTask 充当了 Runnable 的作用，所以这里实际上就是调用了它的 run 方法，这里我们来说下 FutureTask 因为实现了 Runnable 和 Future 这两个接口(前面的源码也能看到)，所以它可以包装 Runnale 和 Callable，可以直接调用线程执行(.run 方法)。</p><p>&emsp;&emsp;而我们在分析前面的构造方法的时候，mWorker(WorkerRunnable) 作为了参数传给 mFuture(FutureTask)，所以这里最终调用的是 mWorker(WorkerRunnable) 中的 call 方法，这里我们把之前的源码再贴出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">                Result result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                    <span class="comment">//noinspection unchecked</span></span><br><span class="line">                    result = doInBackground(mParams);</span><br><span class="line">                    Binder.flushPendingCommands();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                    mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">throw</span> tr;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    postResult(result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们就来看看这个 postResult(result) 这个方法，它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</span><br><span class="line">        message.sendToTarget();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的源码我们可以看到，它在方法里通过创建 Message 并通过这里的 Handler 发送消息，它这个 Handler 是通过 getHandler() 这个方法来获得，而在 getHandler() 它又去创建了 InternalHandler 我们接下来去看看这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                    <span class="comment">// There is only one result</span></span><br><span class="line">                    result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                    result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在 switch 语句中在接收到 MESSAGE_POST_RESULT 消息后就会调用 finish 方法，来看看这个方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">            onCancelled(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onPostExecute(result);</span><br><span class="line">        &#125;</span><br><span class="line">        mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假如当前我们取消任务，那么就会调用 onCancelled(result)，看到这里是不是感觉很熟悉，没错，我们通过这个方法得到了任务执行后的结果，而如果我们取消任务就不会调用这个方法了，这也验证了我们前面所说的。</p><p>&emsp;&emsp;那么再回过头来，我们去看看如果接受到的是 MESSAGE_POST_PROGRESS 这个消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                    <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说当我们调用的是 publishProgress(Progress… values) 这个方法对任务进度进行更新，那么它就会发送这个 MESSAGE_POST_PROGRESS 消息，当接受到消息后又去调用 onProgressUpdate 这个方法，这也就是我们平时在使用 AsyncTask 的时候，当我们去调用 publishProgress 方法后，onProgressUpdate 方法就会被调用的原因。<br><br></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>&emsp;&emsp;到这里，我们的 AsyncTask 的源码流程就学习到这里了，说实话，十三在看这块源码的时候不知道来来回回看了多少遍，写这篇记录的时候更是写了好几天，也许是十三太菜了…</p><p>&emsp;&emsp;真的还是感谢大神老司机的博客文章，有着老司机的带路也不至于像无头苍蝇到处乱窜，所以我们也要借助好老司机前辈的力量，拿出纸笔该记的记，该写的写。</p><p>技术参考文献：<br>【鸿洋大神的博客文章：Android AsyncTask 源码解析】<br>【Android进阶之光 刘望舒】PS：听说皇叔 9 月份又出新书了！<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AsyncTask </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从富豪财产身家中学习状态模式</title>
      <link href="/2018/08/09/State/"/>
      <url>/2018/08/09/State/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，准是假期这段时间以来，十三疯狂修炼，以至于走火入魔……</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve0denhl5j30zk0nndkl.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;十三，你瞎嚷嚷着什么阿，说人话！好吧，其实是身体不太舒服，人有点伤风感冒是正常，可十三自认为生活十分规律，也没有经常去浪，这好端端地怎么会头晕脑重呢？直到后来，十三才明白了，原来这是一段奇遇！</p><p>&emsp;&emsp;其实事情是这样的，话说那天十三去找大夫，给大夫说了病情后，便替十三把脉等一套流程走了下来，过后大夫意味深长地对十三说：“小伙子怕是没少撸？”，十三第一反应便是，哎呀，我去！怕不是遇见道友了？便回话：“大夫，好眼力！”，许是这句话打开了他的话匣子，一下子便和十三说起他辉煌的过去，也是挺能唠叨的一个人。后来，十三通过聊天才知道，原来人家之前还是个亿万富翁。出身医学世家又精通医术，可偏偏又对商业感兴趣，从赚的第一桶金 100 万开始，再到 1000 万，再到成为后来的亿万富翁。</p><p>&emsp;&emsp;“做的啥生意，这么牛？”，十三心想。生意人眼睛就是毒辣，一下子就能看到十三在想些啥，做的是房地产这方面的，原来是房地产，怪不得。这时，十三又忍不住地说：等下，咱们用代码演示下这个过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setage</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age == <span class="number">23</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"23岁成为百万富翁.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age == <span class="number">26</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"26岁成为千万富翁.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age == <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"30岁成为亿万富翁.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"年龄段："</span> + <span class="keyword">this</span>.getage() + <span class="string">"岁是异次元.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码非常简单，我们在 doSomething() 这个方法里就能看到大夫他的成名发家史。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line"></span><br><span class="line">        person.setage(23);</span><br><span class="line">        person.doSomething();</span><br><span class="line"></span><br><span class="line">        person.setage(26);</span><br><span class="line">        person.doSomething();</span><br><span class="line"></span><br><span class="line">        person.setage(30);</span><br><span class="line">        person.doSomething();</span><br><span class="line"></span><br><span class="line">        person.setage(8);</span><br><span class="line">        person.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果:</span><br><span class="line">23岁成为百万富翁..</span><br><span class="line">26岁成为千万富翁..</span><br><span class="line">30岁成为亿万富翁..</span><br><span class="line">年龄段8岁是异次元..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们在 main 方法里实例化 Person 类对象，然后传入 age 参数并调用 doSomething() 方法，接着我们传入的 age 参数便会在方法里面进行判断，然后根据不同的年龄段输出不同的语句，这个我们从运行结果中也能看到。可是我们回过头来想想，我们的这个方法似乎有点长，它有很多的判断分支，且不说它十分臃肿，单单是它承担的责任太大了，每个年龄阶段的财富状态都需要通过它来改变这实际上是非常糟糕的，这显然违背了<code>单一职责原则。</code>而且假如我们想要想要更改它的财富状态，那么就要在这个方法里面进行修改，这又违背了<code>开放-封闭原则，</code>那么我们还有没有其他办法呢？<br><br></p><h2 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式(State)"></a>状态模式(State)</h2><p>&emsp;&emsp;状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况，把状态的判断逻辑转移到表示不同状态的一系列类当中，这样可以把复杂的判断逻辑简化。当然了，假如我们的状态判断很简单，就没有必要使用状态模式了。</p><p>状态模式中的角色和职责：</p><ul><li><p>Context(环境类)：环境类中维护一个 State 对象，它定义了当前的状态.</p></li><li><p>State(抽象状态类)：它定义一个接口以封装和 Context 的特定状态相关行为.</p></li><li><p>ConcreteState(具体状态类)：每一个子类封装了一个状态对应的行为.</p></li></ul><p>&emsp;&emsp;好，那么下面我们就用状态模式改写上面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们先定义了个抽象状态类，并且里面提供了抽象方法 doSomething() 方法，这个方法是交给每个不同状态的子类来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MState</span> <span class="keyword">extends</span> <span class="title">State</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"23岁成为百万富翁.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KState</span> <span class="keyword">extends</span> <span class="title">State</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"26岁成为亿万富翁.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NState</span> <span class="keyword">extends</span> <span class="title">State</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"30岁成为亿万富翁.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoState</span> <span class="keyword">extends</span> <span class="title">State</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"所在年龄段为异次元.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的四个具体状态类分别实现了 四 种不同的状态，这样一来，每个类承担了相关的责任，做到了代码责任的分解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age == <span class="number">23</span>) &#123;</span><br><span class="line">            state = <span class="keyword">new</span> MState();</span><br><span class="line">            state.doSomething();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age == <span class="number">26</span>) &#123;</span><br><span class="line">            state = <span class="keyword">new</span> KState();</span><br><span class="line">            state.doSomething();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age == <span class="number">30</span>) &#123;</span><br><span class="line">            state = <span class="keyword">new</span> NState();</span><br><span class="line">            state.doSomething();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state = <span class="keyword">new</span> NoState();</span><br><span class="line">            state.doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们的 Person 类就要进行改写了，首先它先持有 State 类对象的引用，在 doSomething() 方法里才能根据传入不同的参数实例化不同的状态类，并调用不同状态类的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">23岁成为百万富翁..</span><br><span class="line">26岁成为千万富翁..</span><br><span class="line">30岁成为亿万富翁..</span><br><span class="line">年龄段8岁是异次元..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;客户端代码和之前是一样的，这里就不重复贴出来了，可以看到我们程序运行起来结果还是和之前一样，不同的状态由不同的状态类负责，这样即使我们想要添加状态只需要添加状态类就可以了，符合开放-封闭原则。可是这里我们的判断分支依旧还是存在，这玩意看着有点烦，我们想点法子把它去掉？走你！<br><br></p><h2 id="最终版"><a href="#最终版" class="headerlink" title="最终版"></a>最终版</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state = <span class="keyword">new</span> MState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.doSomething(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 复位</span></span><br><span class="line">        state = <span class="keyword">new</span> MState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先对 Person 类进行改写，首先我们先对 Person 类添加构造方法，并把我们的财富状态设置为”百万富翁”，然后再调用状态类的 doSomething 方法，注意这里我们传参是 this，也就是 Person 类对象参数，这里这样做是因为，我们可以根据传入参数对象的状态调用不同的状态对象方法。接着又把状态再一次初始化为”百万富翁”这个状态，这里为什么要怎么做呢？这个我们待会后面再讲。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Person person)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们先定义个抽象状态类，并且提供了抽象 doSomething 方法，当然了，这个方法它是交给我们不同状态的子类去实现，同时这个方法还需要传入 Person 类的参数，这个我们上面也说了，到时候我们可以根据它的 person 参数，调用它的 getAge() 函数，得到年龄段状态并去调用不同状态的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person.getAge() == <span class="number">23</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"23岁成为百万富翁.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            person.setState(<span class="keyword">new</span> KState());</span><br><span class="line">            person.doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person.getAge() == <span class="number">26</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"26岁成为千万富翁.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            person.setState(<span class="keyword">new</span> NState());</span><br><span class="line">            person.doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person.getAge() == <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"30岁成为亿万富翁.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            person.setState(<span class="keyword">new</span> NoState());</span><br><span class="line">            person.doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"所在时间段:"</span> + person.getHour() + <span class="string">"为异次元.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里 四 个状态类分别对应不同状态，重要的是之前我们的逻辑判断也放在了这些具体状态类里，它的判断工作流程大致如下：首先会先对传入的 person 参数调用它的年龄方法，看看这个年龄是否符合要求，不符合则把它交给下一个状态类去处理。由于我们的 Person 类(Context 角色)中持有抽象状态(State 角色)的引用，所以每次它都能找到具体的状态类并交给它处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        person.setage(<span class="number">23</span>);</span><br><span class="line">        person.doSomething();</span><br><span class="line"></span><br><span class="line">        person.setage(<span class="number">26</span>);</span><br><span class="line">        person.doSomething();</span><br><span class="line"></span><br><span class="line">        person.setage(<span class="number">30</span>);</span><br><span class="line">        person.doSomething();</span><br><span class="line"></span><br><span class="line">        person.setage(<span class="number">8</span>);</span><br><span class="line">        person.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果:</span><br><span class="line">23岁成为百万富翁..</span><br><span class="line">26岁成为千万富翁..</span><br><span class="line">30岁成为亿万富翁..</span><br><span class="line">年龄段8岁是异次元..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过运行程序我们可以看到结果和我们之前是一样的，而我们这一次的写法相比于前两次的写法无疑是好了不少，这里还有个小细节要注意下的是，还记得前面的 Person 类里的 doSomething() 方法吗？为什么还要又一次初始化状态为百万富翁，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.doSomething(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 复位</span></span><br><span class="line">        state = <span class="keyword">new</span> MState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其实是这样的，当我们的状态从百万富翁到亿万富翁，那么这最后一次的状态就是为亿万富翁的状态，假如这时候我们输入年龄段为 23 ，那么它对应的财富状态是百万富翁，可当前这个财富状态已经是指向了亿万富翁这个状态，而它就会从亿万富翁开始判断，不符合条件就交给下一个状态类处理，而下个状态类是异次元，所以也不符合，而这个状态就会一直处于这个状态，所以我们每次调用这个方法，都需要将状态进行复位，每次都从头开始，这也就是我们之前初始化状态为百万富翁这个状态的原因。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;到这里我们的学习记录也接近尾声了，那么国际惯例，我们来简单地总结一下：</p><p>&emsp;&emsp;状态模式的好处在于它将不同状态的行为分割开来，将特定的状态相关的行为都放入一个对象中，不同状态的代码都放入在每个不同的状态子类中，所以我们可以直接通过定义新的状态子类就可以很容易增加新的状态，这样不仅容易扩展和维护，还减少了相互之间的耦合。当一个对象的行为取决于它的状态，并且它需要在运行时根据不同的状态改变不同的行为时，我们应该考虑使用状态模式。<br><br></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>&emsp;&emsp;没想到这次出来真是涨见识了，不仅学到知识还能听到牛逼故事，可是问题就来了，你个亿万富翁那么有雅致来替人看病，体验生活？原来，后来他娶了个貌美如花的老婆，成功地从亿万富翁变成了百万富翁……现在也只能收点诊费，过过小康生活这样子。可十三转而一想，我连一百万都没有，那岂不是…<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 中的线程池</title>
      <link href="/2018/08/08/ThreadPool/"/>
      <url>/2018/08/08/ThreadPool/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>如今这个时代，没有网络真的是难受，这不，十三今天家里就给停网了，后来才知道电信那边在搞事…说到网络，从 Android 3.0 开始，系统就要求网络等耗时操作必须在子线程中进行，否则就会抛出异常。这么做的原因是为了避免把耗时操作放在主线程中引起阻塞从而造成 ANR，给用户第一的感觉就是：卡出了翔…从这里可以看到多线程在我们应用开发中占据着十分重要的位置，今天十三也来总结下自己学习多线程这方面的内容，当然了都是些基础内容（勿喷），输入倒逼内容输出，做个学习记录。</p></blockquote><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvdzrdexgej30zj0ki786.jpg" alt=""><br><br></div></p><h2 id="线程的几种写法"><a href="#线程的几种写法" class="headerlink" title="线程的几种写法"></a>线程的几种写法</h2><p>&emsp;&emsp;还记得刚入门 Java 语法的那时候吗，嘿嘿。下面我们快速来回顾下线程的编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, I am thread!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread mThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一种写法是继承 Thread 类，并重写 run() 方法，这个 run() 方法就是线程要去执行的任务，最后可别忘了要调用线程对象的 start() 方法来开启线程，十三还记得在初学 Java 的时候，没有调用这个 start() 方法，后来就一直在找问题究竟是出在哪里，哈哈！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, I am runnable!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mainclass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable mRunnable = <span class="keyword">new</span> Runnable();</span><br><span class="line">        Thread mThread = <span class="keyword">new</span> Thread(mRunnable);</span><br><span class="line">        mThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是第二种写法实现 Runnable 接口并实现 run 方法，再把该实现接口的实例对象传给 Thread 对象并调用 start 方法。<br>以上这两种写法是我们平时最常用的写法，当然还有其他的实现方式，这里十三就不写出来了。</p><p>&emsp;&emsp;我们都知道在操作系统中，线程是操作系统调度的最小单元，在我们平时编程中会使用线程异步来处理任务，但是每个线程的创建和销毁都是要一定的开销，假如我们频繁地创建和销毁线程，显然会消耗大量的资源，这时候正确的做法是采用线程池，但是在了解线程池前首先我们得要先知道阻塞队列的相关内容。<br><br></p><h2 id="阻塞队列-BlockingQueue"><a href="#阻塞队列-BlockingQueue" class="headerlink" title="阻塞队列(BlockingQueue)"></a>阻塞队列(BlockingQueue)</h2><p>&emsp;&emsp;阻塞队列经常用于生产者消费者的场景，生产者是往队列里添加元素的线程，而消费者是从队列里取元素的线程，阻塞队列就是生产者添加元素的容器，消费者则从容器里取元素。</p><p>Java 中提供 7 个阻塞队列：</p><ol><li><p>ArrayBlockingQueue：由数组结构组成的有界阻塞队列.</p></li><li><p>LinkedBlockingQueue：由链表结构组成的有界阻塞队列.</p></li><li><p>PriorityBlockingQueue：支持优先级排序的无界阻塞队列.</p></li><li><p>DelayQueue：使用优先级队列实现的无界阻塞队列.</p></li><li><p>SynchronousQueue：不存储元素的阻塞队列.</p></li><li><p>LinkedTransferQueue：由链表结构组成的无界阻塞队列.</p></li><li><p>LinkedBlockingDeque：由链表结构组成的双向阻塞队列.</p></li></ol><p>&emsp;&emsp;这里十三也只是简单介绍下阻塞队列，关于这方面的具体内容大家还是去看看更详细的介绍，如《Java编程思想》、《Java并发编程实战》等书籍。<br><br></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>&emsp;&emsp;Android 中的线程池源自于 Java 中的 Executor，Executor 是一个接口，而线程池的真正实现是由 ThreadPoolExecutor 来实现的，它是线程池的核心实现类，它提供了一系列参数来配置线程池，我们可以通过不同的参数创建不同的线程池，下面我们通过它的构造方法来看看所需参数的含义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><ul><li><p>corePoolSize：线程池的核心线程数，默认情况核心线程会在线程池中一直存活，如果当前运行的线程数少于核心线程数，就会创建新线程处理任务；如果等于或多于核心线程数，则不会再创建线程.</p></li><li><p>maximumPoolSize：线程池所能容纳的最大线程数，当活动线程数等于这个数值，后续的新任务将会被阻塞，就好比于我们买车票，一辆车满人就是没座位了，只等等下一班车，这个很好理解.</p></li><li><p>keepAliveTime：非核心线程闲置的超时时间，超过这个时长，非核心线程就会被回收。我们也可以通过设置 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设置为 true，那么核心线程超过时长同样被回收.</p></li><li><p>TimeUnit：用于指定 keepAliveTime 参数的时间单位，这是一个枚举，常用的有 TimeUnit.MILLISECONDS、TimeUnit.SECONDS 以及 TimeUnit.MINUTES 等，分别对应毫秒、秒、分钟.</p></li><li><p>workQueue：任务队列，通过线程池的 execute 方法提交的 Runnable 对象会存储在这个参数中.</p></li><li><p>threadFactory：线程工厂，为线程池提供创建新线程的功能.</p></li><li><p>RejectedExecutionHandler：饱和策略，这是当任务队列和线程池都满了所采取的应对策略，默认是 AbordPolicy，表示无法处理新任务，并抛出异常.</p></li></ul><p>接下来我们来看看线程池工作的大致流程：</p><ol><li><p>如果线程池中的线程数量少于核心线程数量，那就创建核心线程并执行任务.</p></li><li><p>如果线程池中的线程数量多于核心线程数量，那么任务就会被插入到任务队列中排队并等待执行.</p></li><li><p>假如在上一步中，我们的任务无法插入到任务队列中，则说明任务队列满人啦，如果这个时候线程数量没有超过线程池容纳的最大值，那么这时候会启动非核心线程来执行任务；如果线程数量已经达到容纳最大值，那么无法处理任务并会抛出异常通知调用者.<br><br></p></li></ol><h2 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h2><p>&emsp;&emsp;上面我们说过了<code>可以通过不同的参数创建不同的线程池，</code>在 Android 中通常有四种线程池比较常用，它们分别是 FixedThreadPool、CachedThreadPool、SingleThreadExecutor 和 ScheduledThreadPool，实际上它们都直接或间接地通过配置 ThreadPoolExecutor 来实现的，下面我们分别来介绍它们，这里我们还以下面这个界面为例子，界面上分别有四个按钮相对应我们四个线程池，按下按钮线程池便会创建线程执行任务。</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvdzx1wlvrj308w08zt8o.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">简单UI界面<br><br></div></p><h2 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h2><p>&emsp;&emsp;它是一个线程数量固定的线程池，我们可以通过 Executors 类提供的 newFixedThreadPool 方法创建，我们可以跟进去看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到它的核心线程数和最大线程数都被设置为创建 FixedThreadPool 的参数 nThreads，也就是说它只有核心线程并且数量还是固定的，并且没有非核心线程。keepAliveTime 设置为 0L 表示它并没有超时机制，接着我们还看到它的任务队列采用了 LinkedBlockingQueue，这也是前面我们简单介绍阻塞队列的原因，它是没有大小限制的。我们来看看怎么用，放码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">        mTextView = findViewById(R.id.content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            service.execute(command());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">command</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                sb.append(Thread.currentThread().getName()).append(<span class="string">"\n"</span>);</span><br><span class="line">                show();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mTextView.setText(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;来看下运行效果演示：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvdzzmpaaig30d90gp4ax.gif" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">FixedThreadPool</div></p><p>&emsp;&emsp;为了方便我们观察，我在 command 方法中故意让线程睡个 1 秒钟，从演示效果中我们可以看到每次执行任务都是三个线程在工作，因为我们在创建就指定它的 nThreads 参数为 3。<br>我们再来梳理一遍工作流程：首先当我们执行 execute 方法时，如果当前活动线程数量少于核心线程数就创建核心线程并执行任务；如果大于核心线程数，那么不好意思，则把这些任务添加到任务队列中，而它的任务队列是 LinkedBlockingQueue ，当线程池中有空闲线程就会从任务队列中取出任务并执行。</p><p>&emsp;&emsp;由于 FixedThreadPool 中只有核心线程并且这些核心线程并不会被回收，所以它能够快速响应外界的请求，另外它的任务队列是没有大小限制的。<br><br></p><h2 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h2><p>&emsp;&emsp;CachedThreadPool 同样也是通过 Executors 类提供的 newFixedThreadPool 方法创建，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到它的核心线程数为 0，但是非核心线程却是任意大，它是一种线程数量不定的线程池。此外，它的空闲线程的超时时长为 60 秒，超过便要回收闲置线程。而它的任务队列是 SynchronousQueue 阻塞队列，上面我们提到这种队列是不存储元素的，换句话来说我们是没有办法把任务添加到队列里的，而又因为线程池的线程可以是无限制，所以每次提交任务都会有线程去执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            service.execute(command());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样来个演示：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve01huhg2g30d90gpdls.gif" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">CachedThreadPool</div></p><p>&emsp;&emsp;由于这种线程池的任务队列 SynchronousQueue 相当于空集合，因为它不存储任何元素，所以一有任务就立即执行任务，这个从演示结果中我们可以看到，几乎是我们一点击按钮，它的工作就已经完成了。<br><br></p><h2 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h2><p>&emsp;&emsp;Single，Single 一看就是单身的，事实上这是一个只有单个工作线程的线程池，它的创建源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到它的核心线程数和非核心线程数都为 1，所以它相比于其他线程池还是很孤独的，此外它的任务队列也是采用 LinkedBlockingQueue 这个阻塞队列。由于只有一个核心线程，所有的任务都在同一个线程中按顺序执行，放码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">singleThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            service.execute(command());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve06o3b8og30d90gp18v.gif" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">SingleThreadExecutor</div></p><p>&emsp;&emsp;从演示结果中我们看到，线程在执行任务的时候是一个个执行的，散发着单身狗的清香有木有…<br><br></p><h2 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h2><p>&emsp;&emsp;这个线程池则是用来实现定时或周期性任务的线程池，类似于定时器，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">             DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里咱就不具体说了，累了…..来看看演示效果吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduledThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 每隔 1 秒执行</span></span><br><span class="line"><span class="comment">//        service.scheduleWithFixedDelay(getRunnable(), 1, 1, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="comment">// 1 秒后执行一次</span></span><br><span class="line"><span class="comment">//        service.schedule(getRunnable(), 1, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="comment">// 延迟 1 秒后，每隔 1 秒执行一次</span></span><br><span class="line">        service.scheduleAtFixedRate(command(), <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fve095czdkg30d90gph10.gif" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">ScheduledThreadPool</div></p><p>&emsp;&emsp;好了，到这里我们这篇线程池的学习记录就到尾声了，由于篇幅所限，一些如队列等详细的细节可以去查阅其他资料。走了走了，最后问下有没有女孩子愿意和十三出去玩呀！<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从组装枪械中学习模板方法模式</title>
      <link href="/2018/08/07/TemplateMethob/"/>
      <url>/2018/08/07/TemplateMethob/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，依旧三伏天（热）中渡劫，我给自己算过一卦：还是要好好修炼，否则在劫难逃…</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvdzm6hfa6j30zk0jn43s.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;今天还是我们设计模式系列的学习记录，十三记得之前说过自己是个枪械迷，不知道大家是否也是和十三一样有这个爱好呢？那么今天我们自己就来体验下造枪，废话不多说，放码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Gun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeBarrel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeBody</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeMagazine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们定义了个抽象类，我们都知道枪可不止一种型号，有 M4 和 AK 等等，所以具体的制造方法我们交给具体的子类去完成制造，定义的三个抽象方法也分别交给子类去实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M4</span> <span class="keyword">extends</span> <span class="title">Gun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBarrel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4：组装枪管.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4：组装枪身.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMagazine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4：组装弹夹.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AK</span> <span class="keyword">extends</span> <span class="title">Gun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBarrel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AK：组装枪管.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AK：组装枪身.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMagazine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AK：组装弹夹.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里两个类代码非常简单，我也就不再罗嗦了，也就是继承刚刚定义的抽象类并实现抽象方法。那我们接下来就来开始制造枪械：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Gun M4 = <span class="keyword">new</span> M4();</span><br><span class="line">        M4.makeBarrel();</span><br><span class="line">        M4.makeBody();</span><br><span class="line">        M4.makeMagazine();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------军火库--------"</span>);</span><br><span class="line"></span><br><span class="line">        Gun AK = <span class="keyword">new</span> AK();</span><br><span class="line">        AK.makeBarrel();</span><br><span class="line">        AK.makeBody();</span><br><span class="line">        AK.makeMagazine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">M4：组装枪管..</span><br><span class="line">M4：组装枪身..</span><br><span class="line">M4：组装弹夹..</span><br><span class="line">--------军火库--------</span><br><span class="line">AK：组装枪管..</span><br><span class="line">AK：组装枪身..</span><br><span class="line">AK：组装弹夹..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样我们就完成了两支经典名枪的制造，但是不知道大家发现了没有，不管我们制造哪种型号的枪械，它的制造过程大体上是相似的，比如枪械有枪管、枪身和弹夹组成，假如我现在还想再制造其他型号的枪械，岂不是又要写多这些重复语句，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M911.makeBarrel();</span><br><span class="line">M911.makeBody();</span><br><span class="line">M911.makeMagazine();</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这样一写下来，我们将会写出大量的重复语句，而且既然我们前面使用了继承，并且这个继承是有意义的，那所有的重复的代码都应该要写到父类里去，让父类称为子类的模板，这时候就该猪脚上场了。<br><br></p><h2 id="模板方法模式-TemplateMethob"><a href="#模板方法模式-TemplateMethob" class="headerlink" title="模板方法模式 (TemplateMethob)"></a>模板方法模式 (TemplateMethob)</h2><p>&emsp;&emsp;模板方法模式是行为模式之一，它把具有特定步骤算法中的某些必要的处理委让给抽象方法，通过子类继承对抽象方法的不同实现改变整个算法的行为。</p><p>&emsp;&emsp;那我们来使用模板方法模式对我们刚刚的例子进行改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Gun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeBarrel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeBody</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeMagazine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.makeBarrel();</span><br><span class="line">        <span class="keyword">this</span>.makeBody();</span><br><span class="line">        <span class="keyword">this</span>.makeMagazine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改我们的抽象类，抽象方法依旧还是交给子类去实现，因为每种不同型号的枪械外观等属性都不相同，只能由具体子类去实现制造，除此之外，我们添加了个 make() 方法，而这个方法里则调用的是我们定义的抽象方法，这个方法就是模板方法了，它给出我们造枪的逻辑骨架，而逻辑的组成则是由相应的抽象去操作，也就是上面那三个抽象方法，在这里它推迟到子类去实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Gun M4 = <span class="keyword">new</span> M4();</span><br><span class="line">        M4.make();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------军火库--------"</span>);</span><br><span class="line"></span><br><span class="line">        Gun AK = <span class="keyword">new</span> AK();</span><br><span class="line">        AK.make();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">M4：组装枪管..</span><br><span class="line">M4：组装枪身..</span><br><span class="line">M4：组装弹夹..</span><br><span class="line">--------军火库--------</span><br><span class="line">AK：组装枪管..</span><br><span class="line">AK：组装枪身..</span><br><span class="line">AK：组装弹夹..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样我们来运行，也能得到相同的结果，相比于之前的写法，我们不再需要写大量的重复语句了，而这里事实上，它调用的 make 方法还是由它自身完成的。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;例行惯例，在最后我们来做个简单总结：</p><p>&emsp;&emsp;当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。模板方法模式是通过把不变行为写到父类中，避免了子类再去编写重复代码。</p><p>应用场景：</p><ul><li><p>具有统一的操作步骤或操作过程.</p></li><li><p>具有不同操作细节.</p></li><li><p>存在多个具有同样操作步骤的应用场景，但某些具体的操作细节却不相同.</p></li></ul><p>&emsp;&emsp;好了，今天设计模式的学习就记录到这了，说实话这个模板方法模式还是挺简单的，不过也可能是我比较菜吧，只看到短浅的层次…避暑去了。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板方法模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之迭代模式</title>
      <link href="/2018/07/31/Iterator/"/>
      <url>/2018/07/31/Iterator/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，今天工地上的砖格外烫手，天气依旧还是那么炎热，我不想努力了……</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvdzdi4zj8j30zk0nqdkl.jpg" alt=""></div></p><a id="more"></a><p><br>    </p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;热热热，热到爆炸，热到融化，这天气真的一年比一年还热，受不了啊！好吧，咱还是要学习的，今天我们学习迭代器模式，废话不多说，开搞！</p><p>&emsp;&emsp;首先我们先以一个小例子开头，十三喜欢看书，平时没事会去淘书找好书来读，会把要找的书写成个书单，书单上有书籍的详细信息等，那么就用代码演示下这个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String ISBN;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String iSBN, String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        ISBN = iSBN;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getISBN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ISBN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setISBN</span><span class="params">(String iSBN)</span> </span>&#123;</span><br><span class="line">        ISBN = iSBN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ISBN:"</span> + ISBN + <span class="string">" BookName:"</span> + name + <span class="string">"  price:"</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里是对应书籍这个类，它的代码非常简单，都是些字段属性及构造函数，以及还有个打印书籍详细的方法，这个待会我们要用到，接着继续往下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; bookList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bookList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        bookList.add(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bookIndex = bookList.indexOf(book);</span><br><span class="line">        bookList.remove(bookIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= bookList.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookList.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来的这个类就相当于是个书单类，因为书单肯定不止一本书，所以这里为了方便我们就用容器来装载我们的书籍，可以看到它分别有添加和删除两个方法，那么我们怎么知道书单共有多少本书籍呢？没错，第一反应就是遍历就可以了，所以这里最后我们在容器类里添加了可访问的遍历方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BookList list = <span class="keyword">new</span> BookList();</span><br><span class="line"></span><br><span class="line">        Book bookA = <span class="keyword">new</span> Book(<span class="string">"01013"</span>, <span class="string">"Java从入门到放弃"</span>, <span class="number">90</span>);</span><br><span class="line">        Book bookB = <span class="keyword">new</span> Book(<span class="string">"01039"</span>, <span class="string">"颈椎病康复指南"</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        list.addBook(bookA);</span><br><span class="line">        list.addBook(bookB);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(list.hasNext()) &#123;</span><br><span class="line">            Book book = list.getNext();</span><br><span class="line">            book.display();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们就可以来看看我们书单，首先实例化两本书籍对象，并把它们添加到容器中，接着我们进行遍历得到书单信息，在我们的书单容器中都已经提供可访问的遍历方法，所以我们可以直接调用就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 输出结果：</span><br><span class="line">ISBN:01013 BookName:Java从入门到放弃  price:90.0</span><br><span class="line">ISBN:01039 BookName:颈椎病康复指南    price:60.0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过打印信息，我们可以看到书单上详细情况，但是我们回过头来想想，在我们的容器类中，我们提供了书籍的添加和删除等本身具有的方法，不仅如此，我们还在容器类中提供遍历访问的功能，容器类承担了太多的功能，不太符合我们的单一职责原则，那我们就来改写看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; bookList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bookList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        bookList.add(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bookIndex = bookList.indexOf(book);</span><br><span class="line">        bookList.remove(bookIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然你说我书单类太多功能，那我就不提供遍历方法了，我直接返回我整个书单容器给你，你自己遍历去吧！书单类怒了…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BookList list = <span class="keyword">new</span> BookList();</span><br><span class="line"></span><br><span class="line">        Book bookA = <span class="keyword">new</span> Book(<span class="string">"01013"</span>, <span class="string">"Java从入门到放弃"</span>, <span class="number">90</span>);</span><br><span class="line">        Book bookB = <span class="keyword">new</span> Book(<span class="string">"01039"</span>, <span class="string">"颈椎病康复指南"</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        list.addBook(bookA);</span><br><span class="line">        list.addBook(bookB);</span><br><span class="line"></span><br><span class="line">        List&lt;Book&gt; bookData = list.getBookList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookData.size(); i++) &#123;</span><br><span class="line">            Book book = bookData.get(i);</span><br><span class="line">            book.display();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样一来，不再提供遍历方法我们只好自己实现遍历，虽说这样书单类减少了不少功能，但是这样做的话则直接暴露数据细节给外部。是时候了，该出大招了。<br><br></p><h2 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式 (Iterator)"></a>迭代器模式 (Iterator)</h2><p>&emsp;&emsp;<code>迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</code>简单来说，迭代器模式提供一种有效的方法，可以屏蔽聚集对象集合的容器类的实现细节，还能对容器内包含的对象元素按顺序进行有效的遍历访问。</p><p>迭代器模式的角色和职责 ：</p><ul><li><p>Iterator (迭代器接口)：该接口必须定义实现迭代功能的最小定义方法集.</p></li><li><p>ConcreteIterator (迭代器实现类)：迭代器接口的实现类，可以根据具体情况加以实现.</p></li><li><p>Aggregate (容器接口)：抽象聚集类.</p></li><li><p>ConcreteAggregate (容器实现类)：具体聚集类，继承 Aggregate.</p></li></ul><p>&emsp;&emsp;那我们来使用迭代器模式对我们刚刚的例子进行改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; bookList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bookList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        bookList.add(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bookIndex = bookList.indexOf(book);</span><br><span class="line">        bookList.remove(bookIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= bookList.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> bookList.get(index++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里为了方便，我们直接使用 JDK 提供的类库 Iterator，你没看错，事实上 Java 已经把这个模式做在语言里了。这里我们定义了个匿名类 Itr 它实现了 Iterator 这个接口，之所以为匿名内部类是因为我们要实现遍历得需要容器的详细信息，也就是我们书单容器的大小等，不然我们从何做起？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BookList list = <span class="keyword">new</span> BookList();</span><br><span class="line"></span><br><span class="line">        Book bookA = <span class="keyword">new</span> Book(<span class="string">"01013"</span>, <span class="string">"Java从入门到放弃"</span>, <span class="number">90</span>);</span><br><span class="line">        Book bookB = <span class="keyword">new</span> Book(<span class="string">"01039"</span>, <span class="string">"颈椎病康复指南"</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        list.addBook(bookA);</span><br><span class="line">        list.addBook(bookB);</span><br><span class="line"></span><br><span class="line">        Iterator iter = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            Book book = (Book) iter.next();</span><br><span class="line">            book.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 输出结果：</span><br><span class="line">ISBN:01013 BookName:Java从入门到放弃  price:90.0</span><br><span class="line">ISBN:01039 BookName:颈椎病康复指南    price:60.0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样我们来运行，也能得到相同的结果，相比于之前的写法，我们让容器只需实现本身的基本功能，把迭代功能委让给外部类实现，符合类的设计原则，隐藏容器的实现细节。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;最后我们来简单总结下。</p><p>&emsp;&emsp;当需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，就应该考虑用迭代器模式，总地来说，迭代器模式模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。平时我们访问数组、集合等数据时，事实上，许多语言都对它进行过封装，这使得迭代器模式不太经常使用，但是我们却可能天天都在用。</p><p>&emsp;&emsp;来一个以前刚学 Java 时学到 Iterator 的 Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">"One"</span>);</span><br><span class="line">        list.add(<span class="string">"#"</span>);</span><br><span class="line">        list.add(<span class="string">"Two"</span>);</span><br><span class="line">        list.add(<span class="string">"#"</span>);</span><br><span class="line">        list.add(<span class="string">"Three"</span>);</span><br><span class="line">        list.add(<span class="string">"#"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * iterator()方法</span></span><br><span class="line"><span class="comment">         * 该方法会返回一个Iterator的实现类实例，用于遍历当前集合</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * Iterator在java.util包下</span></span><br><span class="line"><span class="comment">         * 其是一个接口，定义了遍历器应有的方法</span></span><br><span class="line"><span class="comment">         * 不同的集合返回的Iterator不都是一个子类实现</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 迭代器的使用方式:先问后拿</span></span><br><span class="line"><span class="comment">         * 问:boolean hashNext()</span></span><br><span class="line"><span class="comment">         *   该方法询问迭代器当前集合是否还有元素</span></span><br><span class="line"><span class="comment">         * 拿:Object next()</span></span><br><span class="line"><span class="comment">         *   该方法会获取当前元素</span></span><br><span class="line"><span class="comment">         * 迭代器的迭代方法是为while循环量身定制的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Iterator it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())<span class="comment">//集合中是否还有下一个元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            String element = (String)it.next();<span class="comment">//有就将其取出</span></span><br><span class="line">            <span class="comment">//需要造型，因为当前集合没有添加泛型，只要有泛型，此处迭代不需加String</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在迭代器迭代的过程中，我们不能通过集合的增删等操作来改变该集合的元素数量！</span></span><br><span class="line"><span class="comment">             * 否则会引发迭代异常！若想删除迭代出来的元素，只能通过Iterator</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(element);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"#"</span>.equals(element))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//list.remove(element);//不可以</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 迭代器的remove()方法可以将刚刚获取的元素1从集合中删除，但是不能</span></span><br><span class="line"><span class="comment">                 * 重复调用两次!</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                it.remove();<span class="comment">//删除当前位置的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">One</span><br><span class="line">#</span><br><span class="line">Two</span><br><span class="line">#</span><br><span class="line">Three</span><br><span class="line">#</span><br><span class="line">[One, Two, Three]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;哈哈，怀恋。想起当初啃 Java 语法的时候，有时候想过为什么会这样，怎么搞的呢？到后来随着学习的深入，或许之前的疑惑也慢慢拨开了，同时也发现自己不懂的也就越多……<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迭代模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从请假流程来学习责任链模式</title>
      <link href="/2018/07/29/Responsibility/"/>
      <url>/2018/07/29/Responsibility/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，越来越感觉自身知识技能缺乏性了，真的是学的越多发现自己不懂的也就也多，稍不注意就在原地踏步，不管怎样还是要酷，Skr ~</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhscoll3lj30j60cs0ug.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;不知道大家都有请过假吗？不管是在校园还是职场上，请假似乎很常见，我们都知道请假可不是你想请就能请的，还得经过上司同意才能请假，要是请假天数太长，上司还得上报他的上司进行审批，可见这假不是想请就请的。</p><p>&emsp;&emsp;实际上，这请假流程类似于我们设计模式中的责任链模式，那么什么是责任链模式呢？今天就来学习记录一下。<br><br></p><h2 id="责任链模式-Chain-of-Responsibility"><a href="#责任链模式-Chain-of-Responsibility" class="headerlink" title="责任链模式 (Chain of Responsibility)"></a>责任链模式 (Chain of Responsibility)</h2><p>&emsp;&emsp;使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为之。</p><p>&emsp;&emsp;那么下面我们就以请假为例演示下责任链模式的简单应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaveRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leaveDays;</span><br><span class="line">    <span class="keyword">private</span> String reason;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeaveRequest</span><span class="params">(String name, <span class="keyword">int</span> leaveDays, String reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.leaveDays = leaveDays;</span><br><span class="line">        <span class="keyword">this</span>.reason = reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeaveDays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leaveDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeaveDays</span><span class="params">(<span class="keyword">int</span> leaveDays)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leaveDays = leaveDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReason</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReason</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.reason = reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们定义了请假请求类，它分别有请假人姓名、天数以及理由三个字段属性，还有构造方法和对应的 get/set 方法，代码非常简单，我们继续往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="comment">// 责任链上的后继对象</span></span><br><span class="line">    <span class="keyword">protected</span> Leader nextLeader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leader</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设定责任链上的后继对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLeader</span><span class="params">(Leader nextLeader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextLeader = nextLeader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求的核心业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(LeaveRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着我们定义了个抽象领导类，之所以是抽象类是因为公司不止一个领导，小领导没权处理的就交给上一级的领导来处理，所以这里我们定义了指定上一级领导的方法 setNextLeader，而每个领导的权力范围都不相同，就交给我们子类来做，就有了抽象方法 handleRequest。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(LeaveRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getLeaveDays() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"员工："</span> + request.getName() + <span class="string">"请假, 天数"</span> + </span><br><span class="line">        request.getLeaveDays() + <span class="string">", 请假理由："</span> + request.getReason());</span><br><span class="line">            System.out.println(<span class="string">"主任："</span> + <span class="keyword">this</span>.name + <span class="string">"，批准！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.nextLeader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.nextLeader.handleRequest(request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们底层的小领导上线了，它继承了 Leader 这个抽象类并重写了抽象方法，在抽象方法里处理请假这个流程，我们可以看到，只要请假天数不超过 3 天，他有权可以审批我们请假要求，如果是超过 3 天，那他就无权处理，只能交给上一级领导来审批，那么来看看他的上一级领导：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(LeaveRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getLeaveDays() &lt; <span class="number">7</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"员工："</span> + request.getName() + <span class="string">"请假, 天数"</span> + </span><br><span class="line">        request.getLeaveDays() + <span class="string">", 请假理由："</span> + request.getReason());</span><br><span class="line">            System.out.println(<span class="string">"经理："</span> + <span class="keyword">this</span>.name + <span class="string">"，批准！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.nextLeader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.nextLeader.handleRequest(request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到这个类与上面的类几乎是相同的，没什么区别，区别在于他能审批不超过 7 天的请假要求，否则他也只能上报上一级领导。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneraManager</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GeneraManager</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(LeaveRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getLeaveDays() &lt; <span class="number">14</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"员工："</span> + request.getName() + <span class="string">"请假, 天数"</span> + </span><br><span class="line">        request.getLeaveDays() + <span class="string">", 请假理由："</span> + request.getReason());</span><br><span class="line">            System.out.println(<span class="string">"总经理："</span> + <span class="keyword">this</span>.name + <span class="string">"，批准！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"员工："</span> + request.getName() + <span class="string">"请假, 天数"</span> + </span><br><span class="line">                    request.getLeaveDays() + <span class="string">", 请假理由："</span> + request.getReason());</span><br><span class="line">            System.out.println(<span class="string">"总经理：没钱哪都去不了，给我好好写代码去！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后一级大 Boss…下面立即开始我们的请假流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Leader director = <span class="keyword">new</span> Director(<span class="string">"张三"</span>);</span><br><span class="line">        Leader manager = <span class="keyword">new</span> Manager(<span class="string">"李四"</span>);</span><br><span class="line">        Leader generaManager = <span class="keyword">new</span> GeneraManager(<span class="string">"王五"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组织责任链关系</span></span><br><span class="line">        director.setNextLeader(manager);</span><br><span class="line">        manager.setNextLeader(generaManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始请假</span></span><br><span class="line">        LeaveRequest request = <span class="keyword">new</span> LeaveRequest(<span class="string">"十三"</span>, <span class="number">14</span>, <span class="string">"世界那么大，我想去看看..."</span>);</span><br><span class="line">        director.handleRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">员工：十三请假, 天数14, 请假理由：世界那么大，我想去看看...</span><br><span class="line">总经理：没钱哪都去不了，给我好好写代码去！</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们先把相关领导类实例化后再指定责任链关系，然后我们再进行请求，这样我们请求的客户端并不知道是哪一个对象处理这个请求，但是我们能得到相关的处理结果，这样系统的更改可以在不影响客户端的情况下动态分配责任。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;最后我们来简单总结下。</p><p>&emsp;&emsp;责任链模式中最关键的是客户提交请求时，请求是沿着链进行传递直到有一个具体处理对象负责处理它，这样一来，请求者不需要关心是哪个处理对象在处理，我只要等请求被处理即可。责任链还简化了对象之间的连接，它们只需要<code>保持一个指向其后继者的引用，</code>这和数据结构的链表是非常相似的，无需保持后继者的引用，这就大大<code>降低耦合度。</code>不仅如此，我们可以<code>随时随地增加或修改请求的结构，</code>当然了，假如我们没有正确配置责任链，可能请求到了链尾都没有被处理。</p><p>常见场景：</p><ul><li><p>Java 中的异常机制就是一种责任链模式，一个 try 可以对应多个 catch，当一个 catch 不匹配类型，则自动跳转到下一个 catch.</p></li><li><p>JS 中事件的冒泡和捕获机制.</p></li></ul><p><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 责任链模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序猿相亲记</title>
      <link href="/2018/07/27/Mediator/"/>
      <url>/2018/07/27/Mediator/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，最近又把使命召唤的现代战争系列重看了一遍，剧情是真的赞，个人认为使命召唤 4、6、8 这三部曲实在是经典阿，还有荣誉勋章这款游戏也不错，青春阿……    </p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrxikj4hj30j60ctwhw.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;不知道有小伙伴是否也是枪械迷，推荐大家去 B 站搜索 Up 主哲学的石头，他的打法真的一路凶残到底，枪法意识都很好，看了他的视频再去看其他视频，感觉其他 Up 主的视频都没劲，当然对我而言是这样的，太厉害了。</p><p>&emsp;&emsp;好了，题外话就说到这里了，今天咱们继续来学习中介者设计模式，说到中介者十三第一个想到就是房产中介了，可是老是提房也是烦，主要是穷的一笔……好，那咱就换个婚姻中介，卧槽……你这真的是猝不及防。当然了，也不是什么都一上来就是找中介什么的，什么都得自己先试试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> condition;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.condition = condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCondition</span><span class="params">(<span class="keyword">int</span> condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.condition = condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person person)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们定义了个抽象 Person 类，它有字段属性及构造方法，还提供了个抽象的找对象方法…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">(String name, <span class="keyword">int</span> condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, condition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Man) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Sorry,我不是Gay.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getCondition() == person.getCondition()) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"和"</span> + person.getName() + <span class="string">"般配"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"和"</span> + person.getName() + <span class="string">"无缘"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着这个 Man 类继承自 Person 类，它实现了 Person 类里的抽象方法，在这个抽象方法里首先判断传入的 person 参数是否是 Man 实例，因为总不可能两个大老爷们在一起吧，当然你喜欢吧…接着再往下判断两人之间是否条件相等，这就好比于对方是不是对你有好感，考虑你条件够不够好等等，太复杂了这个，就不多说了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Woman</span><span class="params">(String name, <span class="keyword">int</span> condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, condition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Woman) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Sorry,我不是Gay.."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getCondition() == person.getCondition()) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"和"</span> + person.getName() + <span class="string">"般配"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"和"</span> + person.getName() + <span class="string">"无缘"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然有 Man 类，那肯定就有 Woman 类了，这里和上面是一样的，就不再多介绍了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person shisan = <span class="keyword">new</span> Man(<span class="string">"十三"</span>, <span class="number">9</span>);</span><br><span class="line">        Person p = <span class="keyword">new</span> Man(<span class="string">"路人乙"</span>, <span class="number">10</span>);</span><br><span class="line">        Person ll = <span class="keyword">new</span> Woman(<span class="string">"LL"</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        shisan.getPartner(ll);</span><br><span class="line">        p.getPartner(ll);</span><br><span class="line">        p.getPartner(shisan);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">十三和LL般配</span><br><span class="line">路人乙和LL无缘</span><br><span class="line">Sorry,我不是Gay..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;好了，通过结果我们可以看到十三真幸运，他和 LL 牵手成功，而路人乙则悲催了点，但是不论结果是怎样，它们互相之间是认识的，这就要求对象之间需要其他对象，好比于十三如果不认识 LL 他最后怎么可能牵手成功呢。</p><p>&emsp;&emsp;站在我们开发中来讲，类与类之间的联系就比较紧密，对象之间的相互连接降低其可复用性，可能会使得一个对象在没有其他对象的支持下而罢工。迪米特原则中提到：如果两个类不必互相通信，那么这两个类就不应该发生直接的相互作用。好，那我们应该要怎么来做呢？<br><br></p><h2 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式 (Mediator)"></a>中介者模式 (Mediator)</h2><p>&emsp;&emsp;中介者模式是行为模式之一，用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>&emsp;&emsp;那么许多像路人乙那样被狠心拒绝，或者平时没有什么机会接触异性，那怎么办呢？于是，可能看到这个商机，各种婚姻中介强势崛起。通过这些中介对象，每个具体对象就不再同其他对象打交道了，而是通过这些中介者对象与另外一个对象发生相互作用。那么我们在上面例子的基础上再改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> condition;</span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person2</span><span class="params">(String name, <span class="keyword">int</span> condition, Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.condition = condition;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mediator <span class="title">getMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMediator</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCondition</span><span class="params">(<span class="keyword">int</span> condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.condition = condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person2 person)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们这个抽象 Person 类，它增加对中介者 Mediator 的应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man2</span> <span class="keyword">extends</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man2</span><span class="params">(String name, <span class="keyword">int</span> condition, Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, condition, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person2 person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getMediator().setMan(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.getMediator().getPartner(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman2</span> <span class="keyword">extends</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Woman2</span><span class="params">(String name, <span class="keyword">int</span> condition, Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, condition, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person2 person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getMediator().setWoman(<span class="keyword">this</span>); </span><br><span class="line">        <span class="keyword">this</span>.getMediator().getPartner(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里就相当于两个具体的 Person 类，分别实现了抽象找对象方法，但是这里找对象可是通过中介介绍找的对象，这个过程我们可以这样理解，因为抽象父类 Person 持有中介者 Mediator 类的引用，所以我们这里的 getPartner 找对象方法，先是通过父类找到当前这个中介，然后注册相关会员信息，注册好后中介就会帮我们找对象了，当我们调用找对象的方法，实际上是中介者帮我们找的对象，那么下面我来看看这个中介者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Man2 man;</span><br><span class="line">    <span class="keyword">private</span> Woman2 woman;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMan</span><span class="params">(Man2 man)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.man = man;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWoman</span><span class="params">(Woman2 woman)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.woman = woman;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPartner</span><span class="params">(Person2 person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Man2) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setMan((Man2) person);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setWoman((Woman2) person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (man.getCondition() == woman.getCondition()) &#123;</span><br><span class="line">            System.out.println(man.getName() + <span class="string">"和"</span> + woman.getName() + <span class="string">"般配"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(man.getName() + <span class="string">"和"</span> + woman.getName() + <span class="string">"无缘"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到这个中介者类它持有对具体对象的引用，这个很好理解，就相当于你要我帮你找对象，你得要把你相关信息告诉我，我好给你找对吧。再之后中介就会帮我们筛选出合适的对象，就会通知我们出来见个面？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Mediator mediator = <span class="keyword">new</span> Mediator();</span><br><span class="line"></span><br><span class="line">        Person2 man = <span class="keyword">new</span> Man2(<span class="string">"路人乙"</span>, <span class="number">3</span>, mediator);</span><br><span class="line">        Person2 woMan = <span class="keyword">new</span> Woman2(<span class="string">"小芳"</span>, <span class="number">3</span>, mediator);</span><br><span class="line">        man.getPartner(woMan);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//运行结果：</span><br><span class="line">路人乙和小芳般配</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样，路人乙就通过中介找到他的真爱，祝福他们。我们回过头来看下，相比于我们第一次的写法，路人乙和小芳它们本来之间就是不认识的，就类似于两个人类之间可以不用进行通信。但是它们都通过中介认识接触到对方，这样的话，我们的类与类之间就不需要知道其他对象了，只需要和中介者打交道就可以了。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;最后我们来简单总结下。</p><p>&emsp;&emsp;中介者的出现减少了各个类之间的耦合，明确类之间的相互关系；中介者模式将原来相互依存的多对多的类关系简化为中介者类与其他关联类一对多的关系，当其中一个类修改时也不影响其他关联类。</p><p>&emsp;&emsp;后来，据路人乙说其实那天下午他去和中介介绍的女孩见面了，等他到场时才发现对方是个男的？一问才知道，对方也是被安排出来见面的，只是没想对方竟然是个男的，没过多一会儿，原来是中介搞错了……因为生意太过于火爆，这将使得中介者会变得相当复杂繁忙。</p><p>这都不是重点，重点是路人乙发现对方竟然也是程序员，哈哈，这下可好，两人一见如故，那天他们整整聊了一下午的技术，走时，他们还互相交换了微信……<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中介者模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之适配器模式</title>
      <link href="/2018/07/25/Adapter/"/>
      <url>/2018/07/25/Adapter/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，也许是我昨天求雨的诚意感动了老天还是受台风气压影响，还真是下了场雨舒服阿，哈哈…</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhr0ldb9yj30j60csn0x.jpg" alt=""></div></p><a id="more"></a>    <p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;不知道大家在日常生活中有没有发现，凡是需要用电的电子产品它总得要插头充电（废话），而有些电子产品如手机、笔记本电脑等，它们不是直接插上电源就完事，电源还得经过电源适配器转换为稳定的电压才能进行充电，我们都知道每个国家地区的电压标准都是不一样的，所以要能正常充电就得需要电源适配器为我们工作，那么我们先用代码演示下没有电源适配器的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电压</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">voltage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前电压：220V.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;咱天朝的家庭电压标准是 220 V。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Voltage current = <span class="keyword">new</span> Voltage();</span><br><span class="line">        current.voltage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">当前电压：220V..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在我们就没有电源适配器的情况下，要是我们直接插上电源，恐怕笔记本要炸…</p><p>&emsp;&emsp;事实上这个场景和设计模式中的适配器模式相似，那下面我们就来一起看看适配器模式相关的介绍。<br><br></p><h2 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 (Adapter)"></a>适配器模式 (Adapter)</h2><p>&emsp;&emsp;适配者模式是构造型模式之一，通过 Adapter 模式可以改变已有类（或外部类)的接口形式。也就是说将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>桥接模式中的角色及职责 ：</p><ul><li><p>Target ：目标接口，客户所期待的接口，目标可以是具体的或抽象的类，也可以是接口.</p></li><li><p>Adaptee : 需要适配的类或适配者类.</p></li><li><p>Adapter : 通过包装一个需要适配的对象，把原接口转换成目标接口.</p></li></ul><p>&emsp;&emsp;好，说到这里，那么我们来看看怎么使用适配器模式，废话不多说，给我放码 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类继承实现 Adapter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Voltage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage();</span><br><span class="line">        System.out.println(<span class="string">"使用电源适配器中：20V.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们先定义个适配器类，它通过继承之前的电压类得到当前电压伏特，然后提供了个适配方法，将电压降到 20 伏特，其实这个过程相当于我们把插头插进插座里，这样就有了电流输入，接着连接到适配器中，降低当前电压电流以达到电源适配的效果，这样我们就能充电了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Adapter adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        adapter.adapter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//运行结果：</span><br><span class="line">当前电压：220V..</span><br><span class="line">使用电源适配器中：20V..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过结果我们可以看到，的确使用电源适配器可以起到适配的效果。事实上，我们上面的这种写法是通过类继承来实现适配器的，我们也还可以通过另外一种方式来实现，与类继承有相似效果莫过于是组合了，没错，我们可以通过组合的方式实现适配器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过组合实现 Adapter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Voltage voltage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter2</span><span class="params">(Voltage voltage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage = voltage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        voltage.voltage();</span><br><span class="line">        System.out.println(<span class="string">"使用电源适配器中：20V.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;它持有对电压类的引用，先在构造器中传入电压类对象参数，以便我们得到当前电压信息，再提供适配的方法，同样也能实现适配的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Adapter2 adapter = <span class="keyword">new</span> Adapter2(<span class="keyword">new</span> Voltage());</span><br><span class="line">        adapter.adapter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//运行结果：</span><br><span class="line">当前电压：220V..</span><br><span class="line">使用电源适配器中：20V..</span><br></pre></td></tr></table></figure><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;当系统的数据和行为都正确时，但接口不兼容，我们应该考虑使用适配器，使得对象与接口能够匹配并一起工作，适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境不一致的情况。</p><p><code>应用场景 :</code></p><ul><li><p>双方不太容易修改的时候再使用适配器模式.</p></li><li><p>旧系统改造和升级.</p></li><li><p>Java I/O 流.</p></li></ul><p>&emsp;&emsp;最后，适配器模式不能滥用，因为适配器模式只有在无法改变原有的设计和代码的情况下，才去考虑适配，假如一开始设计我们问题考虑全面，那么不匹配的问题就不会发生，我们也就不需要考虑适配了。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 适配器模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秋名山车王 —AE86— 改装记</title>
      <link href="/2018/07/24/Bridge/"/>
      <url>/2018/07/24/Bridge/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，新的一周依旧热的要把人融化，还是喜欢秋天，可惜在广东是没有秋天……</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhr9p1w3vj30j60csgn3.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;不知道大家喜欢看《头文字D》吗？十三我就喜欢看，特别是 86 在一次车赛中抛锚瘫痪后，拓海他老爸整了个核爆引擎，给 86 安装后简直是爆炸性输出，活脱脱一头野兽。那么今天我们也来体验一把改装的乐趣。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">installEngine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们定义了个 Car 接口，里面有个安装引擎的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AE86</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">installEngine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着这里是个 86 的抽象类，它实现 Car 接口里的方法，它之所以是抽象类是因为我们可以给 86 进行不同的改装，而这些改装则交给它子类去完成，那么下面我们就看看它具体的子类 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">V8</span> <span class="keyword">extends</span> <span class="title">AE86</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"安装V8涡轮引擎.. "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">V10</span> <span class="keyword">extends</span> <span class="title">Bus</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"安装V10核弹引擎.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里两个类分别对应是两种引擎，它实现了抽象类里的抽象方法，代码非常简单就不再多说了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子类太多</span></span><br><span class="line">        AE86 car = <span class="keyword">new</span> V8();</span><br><span class="line">        car.installEngine();</span><br><span class="line"></span><br><span class="line">        AE86 Pandacar = <span class="keyword">new</span> V10();</span><br><span class="line">        Pandacar.installEngine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//输出结果：</span><br><span class="line">AE86安装V8涡轮引擎..</span><br><span class="line">AE86安装V10核弹引擎..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样的话，我们想要给 86 装上什么引擎就去实例化对应的引擎类，再调用安装方法就可以了，可是这样子的话，那我们编写的类就太多了，给人感觉非常庞杂。你看，假如我们不止要给 86 改装，还要给其他车子改装，那么不同车子引擎规格也不同，那么我们就要重新编写相关类，这样下来还不得死人？那还有没有其他的写法呢。<br><br></p><h2 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h2><p>&emsp;&emsp;天无绝人之路，想了许久，十三终于想出另外一种写法，我们一起来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span>    <span class="function"><span class="keyword">void</span> <span class="title">installV8Engine</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">4</span>    <span class="function"><span class="keyword">void</span> <span class="title">installV10Engine</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先定义了个 Car 接口，相比于之前的 Car 接口，我们这里接口直接就是不同规格的引擎方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AE86</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installV8Engine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AE86安装V8涡轮引擎.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installV10Engine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AE86安装V10核弹引擎.."</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要修改原有方法，不符原则</span></span><br><span class="line">        AE86 car = <span class="keyword">new</span> AE86();</span><br><span class="line">        car.installV8Engine();</span><br><span class="line"></span><br><span class="line">        AE86 Pandacar = <span class="keyword">new</span> AE86();</span><br><span class="line">        Pandacar.installV10Engine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//运行结果：</span><br><span class="line">AE86安装V8涡轮引擎..</span><br><span class="line">AE86安装V10核弹引擎..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样这样子我们也可以完成对 86 的改装，而且的确比之前的写法少写了不少，但是我们回过头来看，假如这时候又有其他最强的引擎，我们想要给 86 装上，那么就要在接口里再加上安装最新引擎的方法，这样子一来，就要修改到原来的代码结构，不符合我们的开放-封闭原则。看来得要放大招。<br><br></p><h2 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式 (Bridge)"></a>桥接模式 (Bridge)</h2><p>&emsp;&emsp;桥接模式，是构造型的设计模式之一。桥接模式基于类的最小设计原则，通过使用封装、聚合以及继承等行为来让不同的类承担不同的责任。它的主要特点是把抽象（abstraction) 与行为实现 (implementation) 分离开来，从而可以保持各部分的独立性以及应对它们的功能扩展。</p><p>&emsp;&emsp;那么什么叫抽象与它的行为实现分离，<code>注意，这里不是抽象类与派生类分离，实现指的是抽象类和它的派生类用来实现自己的对象。</code></p><p>桥接模式中的角色及职责 ：</p><ul><li><p>Abstraction ：抽象类接口（接口或抽象类），维护对行为实现（Implementor）的引用.</p></li><li><p>Refined Abstraction : Abstraction 子类.</p></li><li><p>Implementor : 行为实现类接口（Abstraction 接口定义了基于 Implementor 接口的更高层次的操作）.</p></li><li><p>ConcreteImplementor : Implementor 子类.</p></li></ul><p>&emsp;&emsp;好，理论说了一大堆，究竟这个桥接模式要怎么使用呢？我们下面同样就以上面的例子演示下桥接模式的简单使用，废话不多说，放码 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementor 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">installEngine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先出场的是我们 Implementor 类，接口里定义了安装引擎的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteImplementor 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">V8Engine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AE86安装V8涡轮引擎.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">V10Engine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AE86安装V10核弹引擎.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后是两个 ConcreteImplementor 类，分别重写接口里的接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(Engine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">installEngine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着我们看到这个抽象类，它持有对 Engine 类的引用，也就是维护对行为实现 Implementor 的引用，毫无疑问它是 Abstraction 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AE86</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AE86</span><span class="params">(Engine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getEngine().installEngine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后我们 86 类出现了，它继承自 Abstraction 类，知道它是 Refined Abstraction 类角色，默认有个构造方法，传入的是 Engine 类型参数，也就是我们要给 86 改装什么样的引擎，再调用 installEngine 这个方法，由于父类 Abstraction 持有 Implementor 类的引用，所以最终调用的是具体的 ConcreteImplementor 类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Engine v8 = <span class="keyword">new</span> V8Engine();     </span><br><span class="line">        Car car = <span class="keyword">new</span> AE86(v8);</span><br><span class="line">        car.installEngine();</span><br><span class="line"></span><br><span class="line">        Engine v10 = <span class="keyword">new</span> V10Engine();        </span><br><span class="line">        Car pandaCar = <span class="keyword">new</span> AE86(v10);</span><br><span class="line">        pandaCar.installEngine();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 运行结果：</span><br><span class="line">AE86安装V8涡轮引擎..</span><br><span class="line">AE86安装V10核弹引擎..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样的设计显然不会修改原来的代码，假如有其他需求我们只用扩展类就行了，相比于之前的写法更灵活，扩展性更好。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;<code>优先使用对象合成/聚合，而不是类继承。</code>对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</p><p><code>应用场景 :</code></p><ul><li><p>不希望或不适用使用继承的场景.</p></li><li><p>重用性要求较高的场景.</p></li></ul><p><code>优点 ：</code></p><ol><li><p>抽象和实现分离.</p></li><li><p>优秀的扩充能力.</p></li><li><p>客户不用关心细节的实现，它已经由抽象层通过聚合关系完成了封装.</p></li></ol><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhr8m66unj30j607fwf6.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">Bridge 结构图</div></p><p>&emsp;&emsp;桥接模式的意图还是对变化的封装，尽量把可能变化的因素封装起来，因此在我们开发中，发现类的继承过多时，可以考虑桥接模式。</p><p>今天的学习记录就到这里了，放松放松下，去看个电影了。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桥接模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之组合模式</title>
      <link href="/2018/07/23/Composite/"/>
      <url>/2018/07/23/Composite/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，今日是 二十四 节气中的大暑，要是此时此刻下一场大雨就好了，而我在屋里喝茶看书，好生快活。</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrd646usj30j60cs0uu.jpg" alt=""><br><br></div></p><a id="more"></a><p><br></p><h2 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 (Composite)"></a>组合模式 (Composite)</h2><p>&emsp;&emsp;想不出有什么好的小故事作为开头，我想我需要放纵，但是想了下，咱还是继续学习设计模式吧……</p><p><code>定义：将对象组合成树形结构以表示“部分-整体“的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性.</code></p><p>组合模式中的角色及职责 ：</p><ul><li><p>Component (树形结构的节点抽象) ：定义了叶子和容器构件的共同点.</p></li><li><p>Leaf (树形结构的叶子节点) : 无子节点.</p></li><li><p>Composite (树形结构的枝节点) : 有容器特征，可以包含子节点.</p></li></ul><p>&emsp;&emsp;好，说了那么多，究竟这个组合模式要怎么使用呢？我们下面就以杀毒软件杀毒的过程作为例子，演示下组合模式的简单使用，废话不多说，放码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstrastFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">killVirus</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先定义个抽象节点接口，接口里提供了杀毒方法，它定义所有类对象共同的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 容器组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">implements</span> <span class="title">AbstrastFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;AbstrastFile&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Folder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbstrastFile file)</span> </span>&#123;</span><br><span class="line">        list.add(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(AbstrastFile file)</span> </span>&#123;</span><br><span class="line">        list.remove(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killVirus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"文件夹："</span> + name + <span class="string">",查杀ing..."</span>);</span><br><span class="line">        <span class="keyword">for</span> (AbstrastFile file : list) &#123;</span><br><span class="line">            file.killVirus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后是 Composite 类，可以定义枝节点和子节点的行为，它用容器集合用来存储其下属的枝节点和叶节点，这就好比于在我们电脑里的硬盘下有个文件夹，这个文件夹相当于 Composite 类，而文件夹里还可以有文件夹或者文件，文件夹里的文件夹相当于枝节点，所以我们在这个 Folder 类中分别提供了 add 和 remove 方法用来添加文件夹或文件，在重写的方法里对它的下级进行遍历，这样就可以一层层找到所有的节点。文件则是叶节点，叶节点里可就没有子节点了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageFile</span> <span class="keyword">implements</span> <span class="title">AbstrastFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ImageFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killVirus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---图像文件:"</span> + name + <span class="string">", 查杀ing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextFile</span> <span class="keyword">implements</span> <span class="title">AbstrastFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killVirus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---文本文件:"</span> + name + <span class="string">", 查杀ing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoFile</span> <span class="keyword">implements</span> <span class="title">AbstrastFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killVirus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---视频文件:"</span> + name + <span class="string">", 查杀ing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着在这里我们定义了三个叶节点类，分别实现抽象节点的方法。现在我们的电脑里有个“我的下载”这个文件夹，这个文件夹里有一个“下载的视频”文件夹和其他一些文件，那么我们现在要对它杀毒，来看看 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AbstrastFile imageFile, videoFile, textFile;</span><br><span class="line">        Folder folder = <span class="keyword">new</span> Folder(<span class="string">"我的下载"</span>);</span><br><span class="line"></span><br><span class="line">        imageFile = <span class="keyword">new</span> ImageFile(<span class="string">"高圆圆.jpg"</span>);</span><br><span class="line">        textFile = <span class="keyword">new</span> TextFile(<span class="string">"MainActivity.java"</span>);</span><br><span class="line"></span><br><span class="line">        Folder videoFolder = <span class="keyword">new</span> Folder(<span class="string">"下载的视频"</span>);</span><br><span class="line">        videoFile = <span class="keyword">new</span> VideoFile(<span class="string">"倚天屠龙记"</span>);</span><br><span class="line">        videoFolder.add(videoFile);</span><br><span class="line"></span><br><span class="line">        folder.add(videoFolder);</span><br><span class="line">        folder.killVirus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件夹：我的下载,查杀ing...</span><br><span class="line">---图像文件:高圆圆.jpg, 查杀ing...</span><br><span class="line">---文本文件:MainActivity.java, 查杀ing...</span><br><span class="line">文件夹：下载的视频,查杀ing...</span><br><span class="line">---视频文件:倚天屠龙记, 查杀ing...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样我们使用组合模式完成对这个文件夹进行杀毒的过程，我们来再看下组合模式工作流程 ：</p><ol><li><p>组合模式为处理树形结构提供完美的解决方案，描述了如何将容器和叶子进行递归组合，使得用户在使用时可以一致性的对待容器和叶子.</p></li><li><p>当容器对象的指定方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员，并调用执行，其中，使用了递归调用的机制对整个结构进行了处理.<br><br></p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;最后来简单总结下 ：</p><p><code>应用场景 :</code></p><ul><li><p>需求中体现部分与整体层次的结构时，希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中所有对象，应该考虑使用组合模式.</p></li><li><p>操作系统的资源管理器.</p></li><li><p>GUI 中容器层次图.</p></li><li><p>XML 文件解析.</p></li><li><p>Junit 单元测试框架.</p></li></ul><p><code>优点 ：</code></p><ul><li><p>基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合.</p></li><li><p>用户不需关心是叶节点还是组合组件，可以一致地使用组合结构或者单个对象.</p></li></ul><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrcewa97j30j609dzkx.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">Facade 结构图</div></p><p><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从造人的角度来学习外观模式</title>
      <link href="/2018/07/22/Facade/"/>
      <url>/2018/07/22/Facade/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，今天我们来讲讲如何造人，哦不……还是设计模式的学习，继续搬砖！</p></blockquote><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrkos7yoj30j60csacd.jpg" alt=""><br><br></div></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;不知道大家还记得小学有篇文章《女娲造人》吗？现在的课本还有没有我就不清楚了，对这篇文章印象挺深刻的，在古代人们的科学技术没有现在那么先进，对于一些事情无法做出科学合理的解释，所以古人只能凭借自己狭隘的生活体验加以想象和幻想。</p><p>&emsp;&emsp;话说女娲某天见大地了无生机，遂产生造个与自己一样的生物，先是在河边捉起一把黄泥，和点水，揉成一团，再捏个头，插上四肢，做好后女娲向泥人吹了口气，一放到地上，泥人便有了生命，它会走会说会唱，女娲非常高兴给它取了个名字叫做人…</p><p>&emsp;&emsp;于是女娲便开始疯狂造人，还别说，工作量也是挺大的。那么今天我们也来造人，试试用代码造人……瞬间掉了一个档次有木有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"捏个头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"揉成身体"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Limb</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeLimb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"插上四肢"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们分别创建了 三 个类，对应是头、身体和四肢，每个类中分别有对应的制造人体的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 耦合性太高</span></span><br><span class="line">         Head head = <span class="keyword">new</span> Head();</span><br><span class="line">         head.makeHead();</span><br><span class="line">         Body body = <span class="keyword">new</span> Body();</span><br><span class="line">         body.makeBody();</span><br><span class="line">         Limb limb = <span class="keyword">new</span> Limb();</span><br><span class="line">        limb.makeLimb();</span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">捏个头</span><br><span class="line">揉成身体</span><br><span class="line">插上四肢</span><br><span class="line">成人形了...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通常情况下，我们都会这样来编写代码，可这样来看我们的客户端就得要和 三 个类打交道，假若我们这里不止 三 个类那这样耦合性太高了，且不符合迪米特法则，这里就可以用到外观模式。<br><br></p><h2 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式 (Facade)"></a>外观模式 (Facade)</h2><p>&emsp;&emsp;外观模式又被称为门面模式，它通过一个外观类使得整个系统的结构只有一个统一的高层接口，这样能降低用户的使用成本。</p><p><code>定义：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用.</code></p><p>代理模式中的角色及职责 ：</p><ul><li><p>Facade : 外观类，知道哪些子系统类负责处理请求，将客户端的请求代理给适当的子系统对象.</p></li><li><p>Subsystem : 子系统类，可以有一个或者多个子系统，实现子系统的功能，处理外观类指派的任务，注意子系统类不含有外观类的引用.</p></li></ul><p>&emsp;&emsp;好，接下来我们就用外观模式把上面的例子改写下 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     Head head;</span><br><span class="line">    Body body;</span><br><span class="line">    Limb limb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Head();</span><br><span class="line">        body = <span class="keyword">new</span> Body();</span><br><span class="line">        limb = <span class="keyword">new</span> Limb();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head.makeHead();</span><br><span class="line">        body.makeBody();</span><br><span class="line">        limb.makeLimb();</span><br><span class="line">        System.out.println(<span class="string">"成人形了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里其实我们添加个类，在初始化该类的同时将各个子系统类创建好，再提供一个方法将子系统类的方法或属性进行组合，以备外界调用，所以这个类便是外观类，当然了，这里为了简单演示，没有考虑将方法或属性组合，比如造人是男人还是女人，是瘦的还是胖的等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.makeHuman();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 输出结果：</span><br><span class="line">捏个头</span><br><span class="line">揉成身体</span><br><span class="line">插上四肢</span><br><span class="line">成人形了...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;客户端的代码非常简单，由于 Facade 的作用，客户端可以根本不知子系统类的存在。外观模式本身就是将子系统的逻辑和交互隐藏起来，为用户提供一个高层次的接口，使得系统更加易用，同时也隐藏了具体的实现，这样一来，即使具体的子系统类发生了变化，用户也感知不到。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;在最后我们来简单总结下 ：</p><p><code>使用场景 :</code></p><ul><li><p>维护遗留系统，让新系统与外观类交互，外观类则负责与老代码进行交互.</p></li><li><p>构建有层次结构的子系统时，使用外观模式给每个子系统定义入口，通过外观类进行通信，减少子系统类之间的依赖关系.</p></li></ul><p><code>优点 ：</code></p><ul><li><p>隐藏了子系统具体实现，减少耦合，即使具体子系统发生变化用户也感知不到.</p></li><li><p>减少系统的相互依赖，所有依赖都是对外观类的依赖，和子系统类无关.</p></li></ul><p><code>缺点 ：</code></p><ul><li>不符合开放封闭原则，假如出现变更，可能要修改外观类.</li></ul><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrk367pfj30j608c74v.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">Facade 结构图</div></p><p>&emsp;&emsp;对于面向对象有一定基础的同学，即使没有听说过外观模式，在很多时候也可能经常使用它，所以外观模式是非常常用的模式之一。</p><p>&emsp;&emsp;最后十三再说一下，自从女娲那次造人后就再也没有造人了，为什么呢？事后据女娲回忆说，她后来发现人类自己已经学会如何造人……哈哈！<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 外观模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>校园爱情故事后记</title>
      <link href="/2018/07/21/Proxy/"/>
      <url>/2018/07/21/Proxy/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，不知道是不是越长大就更难做到坚持……</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsbt4zgvj30j60cbdi5.jpg" alt=""></div></p><a id="more"></a><p><br>    </p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;自从上次十三有了女神闺蜜的情报，十三最后是否成功抱得美人归呢？这可能是个谜，因为写这篇文章的十三自己都不知道呢，嘿嘿。好吧，说着说着话题都偏了…不知道十三在说啥的同学，请到传送门接受安检 <a href="https://binshao.site/2018/07/19/Observer/">十三校园泡妞记</a>。</p><p>&emsp;&emsp;有了闺蜜的精准情报，十三每次自然不会扑空，只是当十三想要上去搭讪或是有进一步动作的时候，十三就怂了，没错，怂了。他害怕又感些许自卑，可又担心这样下去会失去，就这样一直循环重复，就连卧底闺蜜都抱怨十三太怂了，嚷嚷着不提供情报了，可每次看到十三那一脸痴情样又叹了口气。</p><p>&emsp;&emsp;某天晚上，十三手捧着束花，他动作熟练地打开手机微信，发了条信息，上面写着：“恩人阿恩人，我在你楼下帮我送束花给她吧，您的大恩大德永不忘！”，没过多久，对方回信：“可以啊，还懂得送花了，开窍了，不过自己送。”，原来十三想送花给女神，可他又不好意思当面送，看来十三是真的怂…只好委托她闺蜜帮他送花了，只是人家并不答应他，最后还是十三提出请她吃大餐才答应送花的…</p><p>&emsp;&emsp;注意，这里开始可是要画风突变了，上面这个委托送花过程其实可以用到个设计模式，它便是代理模式，好，接下来我们一起来看看代理模式的介绍。<br><br></p><h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 (Proxy)"></a>代理模式 (Proxy)</h2><p>&emsp;&emsp;代理模式也被称为委托模式，它是结构型设计模式的一种。在我们平时日常生活中类似代理模式的场景也非常常见，比如说请律师代理打官司、代理工具上网等等。</p><p><code>定义：为其他对象提供一种代理以控制对这个对象的访问.</code></p><p>代理模式中的角色及职责 ：</p><ul><li><p>Subject : 抽象主题类，声明真实主题与代理的共同接口方法.</p></li><li><p>RealSubject : 真实主题类，代理类所代表的真实主题，客户端通过代理类间接地调用真实主题类的方法.</p></li><li><p>Proxy : 代理类，持有对真实主题类的引用，在其所实现的接口方法中调用真实主题类中相应的接口方法执行.</p></li></ul><p>&emsp;&emsp;学了就要用，接下来我们把上面十三委托送花的事用代理模式简单实现下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GiveGift</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GiveFlowers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们先定义了一个抽象主题接口，抽象主题类它具有真实主题类和代理的共同接口方法，而这个共同方法就是送花了，所以在里面提供了 GiveFlowers 这个方法，继续往下看 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pursuit</span> <span class="keyword">implements</span> <span class="title">GiveGift</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String girlName;</span><br><span class="line">    <span class="keyword">private</span> String boyName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pursuit</span><span class="params">(String girlName, String boyName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.girlName = girlName;</span><br><span class="line">        <span class="keyword">this</span>.boyName = boyName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GiveFlowers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(girlName + <span class="string">","</span> + boyName + <span class="string">"送你花耶！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们定义了个追求者类，它实现了抽象主题类并重写接口里面的方法，实际上，它是代理模式中真实主题类这个角色，在送花这里十三无疑便是这个角色了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">GiveGift</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String proxyName;</span><br><span class="line">    Pursuit pursuit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(String proxyName, String girlName, String boyName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxyName = proxyName;</span><br><span class="line">        pursuit = <span class="keyword">new</span> Pursuit(girlName, boyName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GiveFlowers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(proxyName + <span class="string">":"</span>);</span><br><span class="line">        pursuit.GiveFlowers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来就是代理类了，它同样也是实现了抽象主题接口，我们可以看到它持有对真实主题类的引用，并在重写的接口方法中调用真实主题类重写的接口方法，也就是说，闺蜜代理帮十三完成送花这个动作，之所以通过调用真实主题类重写的方法，是因为这是十三委托我们的闺蜜帮他送花。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject proxy = <span class="keyword">new</span> Proxy(<span class="string">"LL闺蜜"</span>, <span class="string">"LL"</span>, <span class="string">"十三"</span>);</span><br><span class="line">        proxy.GiveFlowers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LL闺蜜:LL,十三送你花耶！</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;客户端的代码非常简单，我们直接通过代理对象并调用相关方法就完成了送花这个动作，最终调用的是真实主题类里实现的方法，我们这里就成功使用代理模式做了个简单实现。</p><p>&emsp;&emsp;事实上上面我们写的例子是静态代理，代理模式主要分为静态代理和动态代理。<code>静态代理在代码运行前就已经存在了代理类的 class 编译文件；动态代理则是在运行时通过反射来动态生成代理类的对象，并确定是谁来代理。</code><br><br></p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>&emsp;&emsp;既然静态代理我们上面已经实现过了，那么这个动态代理应该怎么来做呢？别急，JDK 提供了相关的类库供我们使用，InvocationHandler 是代理实例的调用程序实现的接口，实现了该接口需要重写 invoke() 方法，那么下面我们用十三送花这个例子来实现动态代理 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在代理实例上处理方法调用并返回结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] arg)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = method.invoke(object, arg);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们先声明了一个 Object 对象，它指向引用与真实主题类，也就是被代理类，紧接着我们在重写的 invoke 方法中去调用执行被代理类的具体方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Subject realSubject = <span class="keyword">new</span> Pursuit(<span class="string">"LL"</span>, <span class="string">"十三"</span>);</span><br><span class="line">        DynamicProxy mDynamicProxy = <span class="keyword">new</span> DynamicProxy(realSubject);</span><br><span class="line">        ClassLoader loader = Pursuit.class.getClassLoader();</span><br><span class="line">        Subject dynamicProxy = (Subject) java.lang.reflect.Proxy.</span><br><span class="line">                newProxyInstance(loader, <span class="keyword">new</span> Class[]&#123;Subject.class&#125;, mDynamicProxy);</span><br><span class="line">        dynamicProxy.GiveFlowers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后我们得要在客户端调用 Proxy.newProxyInstance() 方法来生成动态代理类，接着通过它去调用 GiveFlowers() 方法，而它则会去调用上面我们写的 DynamicProxy 类中的 invoke 方法，这样我们便简单完成了动态代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LL,十三送你花耶！</span><br></pre></td></tr></table></figure><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;那么到最后我们来简单总结下 ：</p><p><code>使用场景 （通过网络搜索，一般分下面几种）:</code></p><ul><li><p>远程代理，也就是为一个对象在不同的地址空间提供局部代表，这样便于隐藏.</p></li><li><p>虚拟代理，根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象.</p></li><li><p>安全代理，用来控制真实对象访问时的权限.</p></li><li><p>智能指引，当调用真实对象时，代理处理另外一些事.</p></li></ul><p><code>优点 ：</code></p><ul><li><p>真实主题类只需关心本职工作.</p></li><li><p>即使真实主题类发生变化，代理类仍然不受影响，因为真实主题类实现了公共接口.</p></li></ul><p>这里来张代理模式的合照，一 二 三，茄子 ： </p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsb9jlvwj30j608sdgj.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">Proxy 结构图<br><br></div></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>&emsp;&emsp;后来，LL 收到了十三送的花，其实 LL 知道十三喜欢她，因为闺蜜已经把什么都和她说了…LL 拿着花并轻轻说了句：“呆子！“。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之享元模式</title>
      <link href="/2018/07/20/Flyweight/"/>
      <url>/2018/07/20/Flyweight/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三。天气好热都要融化了，恐怖的三伏天……</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrn2wzezj30j60cu74o.jpg" alt=""></div></p><a id="more"></a><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;这是设计模式系列的第 十 篇学习记录，天气还是那么炎热，我盼望着富婆的到来，我不想努力了，然而什么都没有出现，继续搬砖…</p><p>&emsp;&emsp;在开始我们今天的学习前，十三首先问大家一个基础的问题，假设现在有 两 个字符串对象，它们的内容也就是赋值相同，那么它们是同一个对象吗？我们先用代码描述出来先 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"LL"</span>;</span><br><span class="line">        String text = <span class="string">"LL"</span>;</span><br><span class="line">        System.out.println(str == text);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么最后我们运行程序的结果是什么呢，是 true 还是 false 呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;没错，答案是 true，我们知道在 Java 中字符串常量都是存放在常量池中的，Java 会确保 一 个字符串常量在常量池中只有 一 个拷贝，并且 String 对象是 final 类型，对象一旦创建就不可改变。在平时开发中，会出现许多 String 类型的变量，如果只是小应用倒还好,假设是一个庞大的系统,有好多处都需要用定义 String 类型的变量，那开销可想而知，而 JDK 的开发者自然想到了这点，采用了享元模式解决创建大量相同 String 变量带来的开销问题。</p><p>&emsp;&emsp;那么问题就来了，这个享元模式到底是什么呢？我们接着往下看。<br><br></p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>&emsp;&emsp;享元模式是池技术的重要实现方式，它不仅可以减少应用程序创建的对象，而且降低了程序内存的占用，提高程序的性能。</p><p><code>定义：使用共享对象有效地支持大量细粒度的对象.</code></p><p>&emsp;&emsp;支持大量细粒度对象，就会使得对象数量多并且性质基本上是相同的，这些对象分为两部分：内部状态和外部状态。</p><p>&emsp;&emsp;内部状态是对象可分享出来的信息，存储在享元对象内部并且不会随环境的改变而改变；如上面的字符串例子中，字符串对象具有字符串类型的特性，这些特性是每个字符串对象都拥有的且是不会改变的。</p><p>&emsp;&emsp;外部状态则是对象依赖的一个标记，它是随环境改变而改变的并且不可共享的状态。如每个字符串对象的内容都可能会不同，它是会随时变化的。</p><p>享元模式中的角色及职责 ：</p><ul><li><p>Flyweight : 抽象享元角色，同时定义出对象的外部状态和内部状态的接口或者实现.</p></li><li><p>ConcreteFlyweight: 具体享元角色，实现抽象享元角色定义的业务方法.</p></li><li><p>FlyweightFactory: 享元工厂，负责管理对象池和创建享元对象.</p></li></ul><p>&emsp;&emsp;光说不练假把式，咱们这里我们就以一个线上手机商城为例子把享元模式用起来 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPrice</span><span class="params">(String phone_Name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们先定义了一个接口，里面分别提供了 showPrice 这个方法，它便对应模式里抽象享元这个角色。我们接着往下看 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple_Phone</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phoneName;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple_Phone</span><span class="params">(String phoneName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phoneName = phoneName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPrice</span><span class="params">(String version)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (version.equals(<span class="string">"32G"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"price : 5199 元"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (version.equals(<span class="string">"64G"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"price : 5699 元"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着我看到这里定义了个类，它实现了前面我们定义的抽象享元角色接口并实现了接口里的方法，那么它对应的角色便是具体享元这个角色了。除了实现接口方法外，我们还定义两个字段属性和构造方法，字段属性分别是手机名字以及手机型号。好，我们继续往下面看 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Apple_Phone&gt; pool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Phone <span class="title">getPhone</span><span class="params">(String PhoneName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pool.containsKey(PhoneName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"使用共享对象,手机型号为："</span> + PhoneName);</span><br><span class="line">            <span class="keyword">return</span> pool.get(PhoneName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Apple_Phone phone = <span class="keyword">new</span> Apple_Phone(PhoneName);</span><br><span class="line">            pool.put(PhoneName, phone);</span><br><span class="line">            System.out.println(<span class="string">"创建手机对象,手机型号为："</span> + PhoneName);</span><br><span class="line">            <span class="keyword">return</span> phone;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们看到这个类名带有 Factory，那么想都不用想，它就是享元工厂类这个角色了。享元工厂是用来创建享元对象的，它通过 Map 容器来存储对象，将内部状态的属性作为 Map 的 key，这里我们手机的内部状态便是 PhoneName，不管怎么样手机名字是不会改变的。然后我们进行判断，如果 Map 容器包含这个 key，那我们就使用 Map 容器存储的这个对象；否则就新创建对象并放入 Map 容器中，以达到共享的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Apple_Phone phoneA = (Apple_Phone) PhoneFactory.getPhone(<span class="string">"iPhone 8"</span>);</span><br><span class="line">        phoneA.showPrice(<span class="string">"64G"</span>);</span><br><span class="line">        Apple_Phone phoneB = (Apple_Phone) PhoneFactory.getPhone(<span class="string">"iPhone 8"</span>);</span><br><span class="line">        phoneB.showPrice(<span class="string">"32G"</span>);</span><br><span class="line">        Apple_Phone phoneC = (Apple_Phone) PhoneFactory.getPhone(<span class="string">"iPhone 8"</span>);</span><br><span class="line">        phoneC.showPrice(<span class="string">"64G"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建手机对象,手机型号为：iPhone 8</span><br><span class="line">price : 5699 元</span><br><span class="line">使用共享对象,手机型号为：iPhone 8</span><br><span class="line">price : 5199 元</span><br><span class="line">使用共享对象,手机型号为：iPhone 8</span><br><span class="line">price : 5699 元</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后我们通过运行结果可以得到，首先由于是第一次创建对象，Map 容器中并没有存储这个对象，所以它便新建对象便存储到 Map 容器中，接下来，只要再创建对象时便直接使用 Map 容器存储的对象。我们在回过头来想下，在这里，手机名字作为内部状态它是不会改变的，而手机型号则是外部状态它的值是会变化的，当然最终的手机价格也会发生改变。如此一来，因为有了共享对象，节约了开销。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么到最后我们来简单总结下 ：</p><p><code>使用场景 :</code><br>如果一个应用程序使用了大量的相似对象，而这些大量的对象造成了很大的存储开销就应该考虑使用；当需要缓冲池的场景。</p><p><code>优点 ：</code><br>减少应用程序创建的对象，降低程序内存的占用，提高程序的性能。</p><p>最后来张享元模式的合照 ： </p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrlx3rdjj30j606574t.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">Flyweight 结构图</div></p><p>&emsp;&emsp;好了，关于享元模式的学习记录就到这里了，天气那么热，各位注意防晒和多吃点水果。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 享元模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十三校园泡妞记</title>
      <link href="/2018/07/19/Observer/"/>
      <url>/2018/07/19/Observer/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三。一首华仔《暗里着迷》送给大家，怎样，是不是很符合气氛！</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs9exwz6j30j60cswfd.jpg" alt=""></div></p><a id="more"></a><p><div align="center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29723022&auto=1&height=66"></iframe></div></p><h2 id="心动的感觉"><a href="#心动的感觉" class="headerlink" title="心动的感觉"></a>心动的感觉</h2><p>&emsp;&emsp;这是设计模式系列的第 九 篇学习记录，什么，你 TM 在逗我，我要看的是妹子，你个标题党！大兄弟，你，你先别急，上吊也得喘口气，且听我娓娓道来……</p><p>&emsp;&emsp;很多人都说大学一定要谈一场轰轰烈烈的恋爱，不然大学不算完整，十三在这之前可能对这些不太上心，觉得谈恋爱还不如打代码来的爽快实在，可十三最近却变了，他变得不再像以前那样那么勤快地敲代码了，不仅这样，他一下子觉得生活仿佛失去了色彩，饭也吃不香，觉也睡不香，大家可能会奇怪了，怎么回事，多上进的小伙子，怎么一下成那样了？</p><p>&emsp;&emsp;十三说这些天他遇见了个妹子，第一眼看见便感很有眼缘，不免多看了几眼。此后几天，不管十三去哪都总能遇见她，总是那么的碰巧，犹如磁石那般有磁性，又像是被安排好一样，只待你走出场来。十三顿时觉得这感觉好奇妙，说不清道不明，每次看到她内心就好高兴可脸上却又一脸淡定，直到人家走远了又觉好失落，十三反问自己这是怎么了同时发现自己又好矛盾，然后就这样慢慢沦陷…</p><p>&emsp;&emsp;晚上，十三决定和兄弟们谈谈心，”都别敲代码了，咱们来聊聊。“，十三对着哥几个说道，”哟，今儿咋怎么有兴致。“，十三接着便把进来情况说了出来，一听见是关于妹子，宿舍几个基佬立马就围了过来…</p><p>&emsp;&emsp;“你是不是看上人家啦，你觉得她哪里好阿？”，一哥们问道。</p><p>&emsp;&emsp;只见十三脑袋微微左倾，像是在回忆似的，“我也不知道怎么说，每次看到她就好开心，看到她在饭堂拿着一碗盛满的热汤，小心翼翼地放下后烫得立马甩手，还吐着小舌头，我就觉得她好可爱；一次在饭堂外的洗水池，我洗完手后不小心撞到一位同学，然后我和这位同学竟然异口同声地说了句不好意思，待我定睛一看，居然是她，那个时候，我看着她我整个人都愣在那里了，要是可以，我希望时间可以静止在那！”。</p><p>&emsp;&emsp;”完了，这家伙坠入爱河了！那等什么阿，追她！“。</p><p>&emsp;&emsp;”对，上啊，追她，哥几个帮你制定作战计划！“，其他哥们纷纷附和着。</p><p>&emsp;&emsp;”知己知彼，百战百胜，我们首先收买她闺蜜，让她做我们的线人给你制造机会。“。</p><p>&emsp;&emsp;好主意，十三点点头暗暗想到。事实上，这个泡妞计划可以应用到设计模式中的观察者模式(画风突变，嘿嘿)。<br><br></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>&emsp;&emsp;观察者模式又叫做发布-订阅模式，属于行为型设计模式中的一种，在我们平时的开发中经常用到。</p><p><code>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</code></p><p>观察者模式中的角色及职责 ：</p><ul><li><p>Subject : 抽象主题(抽象被观察者)，抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象.</p></li><li><p>ConcreteSubject : 具体主题(具体被观察者)，该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知.</p></li><li><p>Observer : 抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己.</p></li><li><p>ConcreteObserver : 具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态.</p></li></ul><p>&emsp;&emsp;理论概念说了一大堆，咱们来点实在的 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们先定义了一个接口，里面分别提供了 attach、detach、notify 三个方法，它便对应模式里抽象主题这个角色。我们接着往下看 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GirlSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GirlSubject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; boyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        boyList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        boyList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : boyList) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">":"</span> + message);</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着我看到这里定义了个类，它实现了前面我们定义的抽象主题接口并实现了接口里的方法，那么它对应的角色便是具体主题这个角色了。在我们的泡妞计划中，这个类便是我们收买的线人了，我们还可以看到类里还有个容器，这个容器存储的便是十三这个观察者了，当然了，它可以有多个观察者，可这样一来，十三就会不高兴了，这意味着他有情敌。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里这个接口便是抽象观察者了，它里面提供了一个更新方法。然后我们再开看看具体实现它的具体观察者 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoyObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoyObserver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">":"</span> + <span class="string">"收到，等我抱得美人归，请你吃饭！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样具体观察者类实现了抽象观察者接口里的方法，在计划中这个类便是对应十三这个观察者了。好了，拟定好作战计划好，那么我们就要行动起来 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BoyObserver boy = <span class="keyword">new</span> BoyObserver(<span class="string">"十三"</span>);</span><br><span class="line"></span><br><span class="line">        GirlSubject girl = <span class="keyword">new</span> GirlSubject(<span class="string">"LL室友"</span>);</span><br><span class="line">        girl.attach(boy);</span><br><span class="line">        girl.notify(<span class="string">"LL出门啦，快去追她！"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LL室友: LL出门啦，快去追她！</span><br><span class="line">  十三: 收到，等我抱得美人归，请你吃饭！</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样子，我们这个作战计划便用了观察者模式来手动实现了，手动？难道还有其他不用手动的方法吗？当然了…<br><br></p><h2 id="Observable-和-Observer"><a href="#Observable-和-Observer" class="headerlink" title="Observable 和 Observer"></a>Observable 和 Observer</h2><p>&emsp;&emsp;其实 Java JDK 下已经有提供了相关的类库帮助我们快速实现观察者模式，它们分别是 Observable 类 和 Observer 接口，下面我们来看看怎么样来应用 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Observable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteSubject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNotify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(name +<span class="string">":"</span> + <span class="string">"LL出门啦，快去追她！"</span>);</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里个类便是具体主题(具体被观察者)，它继承了 JDK 包下的 Observable 这个类，在我们自己编写的 getNotify 方法中，当我们的被观察者状态发生改变后，我们直接调用继承的这个 Observable 这个类的 setChanged() 这个方法，它用来设置一个内部标志位注明状态发生了变化，而 notifyObservers() 方法会去调用一个列表中所有的 Observer 的 update() 方法，以通知它们被观察对象状态发生了变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteObserver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object object)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">":"</span> + <span class="string">"收到，等我抱得美人归，请你吃饭！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着这个类也就是我们的具体观察者，它实现了 Observer 这个接口，我们实现了它的 update()方法，也就是当被观察者的状态发生改变时，观察者的状态也随之更新。最后我们来看看结果 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject(<span class="string">"LL闺蜜"</span>);</span><br><span class="line">        ConcreteObserver observer = <span class="keyword">new</span> ConcreteObserver(<span class="string">"十三"</span>);</span><br><span class="line"></span><br><span class="line">        subject.addObserver(observer);</span><br><span class="line"></span><br><span class="line">        subject.getNotify(<span class="string">"LL出门啦，快去追她！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LL闺蜜: LL出门啦，快去追她！</span><br><span class="line">  十三: 收到，等我抱得美人归，请你吃饭！</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过实现 JDK 包下的提供的类库，我们同样也能实现观察者模式，而且相比与我们自己来手动实现，无疑使用官方提供的类库，我们可以更快地实现。但是十三还是推荐自己动手去实践下再用提供好的类库来实现，因为只有自己去动手操作，才能加深印象。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么到最后我们来简单总结下 ：</p><p><code>使用场景 :</code><br>&emsp;&emsp;当一个对象的改变需要同时改变其他对象的时候，并且它还不知道具体有多少对象待改变时，我们应该考虑观察者模式，此外，如 Android 中的广播也是相关的应用场景。</p><p><code>优点 ：</code></p><ul><li><p>观察者和被观察者之间是抽象耦合并且容易扩展.</p></li><li><p>双方的耦合都依赖于抽象，使得各自之间的变化不会影响到另一边.</p></li></ul><p>最后来张观察者模式的合照 ： </p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhs8tdj2rj30j605o3z0.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">Observer 结构图</div></p><p>&emsp;&emsp;好了，关于观察者模式的学习记录就到这里了，也希望各有情人终成眷属，最后十三想说的是，十三目前还是单身……绝没有任何秀恩爱之说，Ok，Goodbye！<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>爆发雄性荷尔蒙——从玩改装赛车中学习装饰模式</title>
      <link href="/2018/07/18/design-decorator/"/>
      <url>/2018/07/18/design-decorator/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三。时间一晃假期便过了三天，我人生中最后一个暑假，你慢点走…</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrfpeo6tj30j608cwfr.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: red;">今晚八点秋名山见…</div></p><a id="more"></a><p>&emsp;&emsp;这是设计模式系列的第 八 篇学习记录，假期也要坚持学习，加油！</p><p>&emsp;&emsp;上篇文章中咱们说到我们自己盖了一套花园别墅，一脸懵逼和不明所以的同学请到传送门接受安检 <a href="https://binshao.site/2018/07/17/Builder/">设计模式之建造者模式</a>。</p><p>&emsp;&emsp;有了房我们就满足了吗？当然没有，人心不足蛇吞象，我十三今天还得有辆车，喝最烈的酒、骑最野的马、泡最辣的妞……嗯哼哼，那个，最近几天怕不是活在了梦里哦。废话少说，你今天还开不开车，哦不，还造不造车……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们定义了个接口，既然是车子那肯定会跑，也就是对应 run 方法，而 show 方法则是显示车子属性，代码非常简单，我们接着往下看 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PandaCar</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AE_86最高时速..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们创建了个 AE86 汽车类，有哪个老司机开过，嘿嘿？走，咱去车库取车去溜溜 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Car car = <span class="keyword">new</span> PandaCar();</span><br><span class="line">        car.show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不错，开着 86 出去感觉街上的小姐姐都往着看，但是看过 《头文字D》 的老司机都知道，86 瘫痪了紧接着换上了更恐怖的引擎，简直爆炸输出阿！人的欲望永远都不会满足的，不行，这辆 86 我也要拿去改装 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunCar</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AE86最强跑车引擎..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改装前</span></span><br><span class="line">        Car car = <span class="keyword">new</span> PandaCar();</span><br><span class="line">        car.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改装后</span></span><br><span class="line">        Car Runcar = <span class="keyword">new</span> RunCar();</span><br><span class="line">        Runcar.show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这下子我们便有最强马力输出的 AE86 了，可是这时我们回过头想下，假若我们要想再进行改装，那我们还得再增加子类并重写方法，虽然说我们这样写的思路是没有错，可是我们还有其他更好的方法吗？<br><br></p><h2 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式 (Decorator)"></a>装饰模式 (Decorator)</h2><p>&emsp;&emsp;装饰模式又叫做包装模式，是结构型设计模式之一，其在不必改变类文件和使用继承的情况下，动态地扩展一个对象的功能，是继承的替代方案之一。</p><p><code>定义：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</code></p><p>装饰模式中角色和职责 ：</p><ul><li><p>Component : 抽象组件，可以是接口或是抽象类，被装饰的最原始的对象.</p></li><li><p>ConcreteComponent : 组件具体实现类，被装饰的具体对象.</p></li><li><p>Decorator : 抽象装饰者，从外类来扩展 Component 类的功能，但对于 Component 来说无须知道 Decorator 的存在.</p></li><li><p>ConcreteDecorator : 装饰者的具体实现类.</p></li></ul><p>&emsp;&emsp;概念介绍完了之后，我们来看看我们怎么应用装饰模式 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarDecorator</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarDecorator</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们定义了个 CarDecorator 抽象类，这里可以看到在它的属性有一个 private 变量指向 Component 抽象组件，所以这个 CarDecorator 便对应角色中的 Decorator，接着我们继续往下看 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyCarDecorator</span> <span class="keyword">extends</span> <span class="title">CarDecorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlyCarDecorator</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(car);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对车进行改装</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AE86氮气加速+后尾翼..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.run();</span><br><span class="line">        <span class="keyword">this</span>.fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getCar().show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到这个类继承自 CarDecorator 类，它就是具体的装饰者实现类，也就是对应着角色中的 ConcreteDecorator，我们来看下在 Main 方法里的代码 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Car car = <span class="keyword">new</span> RunCar();</span><br><span class="line">        System.out.println(<span class="string">"跑车 —— 无改装:"</span>);</span><br><span class="line">        car.show();</span><br><span class="line">        Car flyCar = <span class="keyword">new</span> FlyCarDecorator(car);</span><br><span class="line">        System.out.println(<span class="string">"跑车 —— 改装飞行属性:"</span>);</span><br><span class="line">        flyCar.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了方便查看运行结果，我们添加了些打印语句，来看下 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">跑车 —— 无改装:</span><br><span class="line">AE86最强跑车引擎...</span><br><span class="line">跑车 —— 改装飞行属性:</span><br><span class="line">AE86氮气加速+后尾翼...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看，我们在 AE86 的基础上又进行了改装，假若我们还想再在现在这个基础上进行改装，我们只需要这样来做 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwimCarDecorator</span> <span class="keyword">extends</span> <span class="title">CarDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SwimCarDecorator</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(car);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AE86水陆两栖属性..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.run();</span><br><span class="line">        <span class="keyword">this</span>.swim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getCar().show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们只需要增加个具体装饰者类就可以了，接着就可以在 Main 方法里调用了 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Car car = <span class="keyword">new</span> RunCar();</span><br><span class="line">        System.out.println(<span class="string">"跑车 —— 无改装:"</span>);</span><br><span class="line">        car.show();</span><br><span class="line"></span><br><span class="line">        Car flyCar = <span class="keyword">new</span> FlyCarDecorator(car);</span><br><span class="line">        System.out.println(<span class="string">"跑车 —— 改装飞行属性:"</span>);</span><br><span class="line">        flyCar.show();</span><br><span class="line"></span><br><span class="line">        Car swimCar = <span class="keyword">new</span> SwimCarDecorator(flyCar);</span><br><span class="line">        System.out.println(<span class="string">"跑车 —— 改装飞行、水陆两栖属性:"</span>);</span><br><span class="line">        swimCar.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">跑车 —— 无改装:</span><br><span class="line">AE86最强跑车引擎...</span><br><span class="line">跑车 —— 改装飞行属性:</span><br><span class="line">AE86氮气加速+后尾翼...</span><br><span class="line">跑车 —— 改装飞行、水陆两栖属性:</span><br><span class="line">AE86水陆两栖属性...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样到最后，我们经过改装后的 AE86 就有了跑车引擎 + 飞行属性 + 水陆两栖属性，相比于第一次的写法，我们得要在旧类中添加新代码，而装饰模式却提供了一个好的替代方案，它把每个要装饰的功能放在单独的类中，每个装饰对象只需要关心自己的功能就可以了，不知道大家发现没有，上面的代码是不是和 Java I/O 流代码有点像，事实上，I/O 流也是应用到了装饰者模式。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么到最后我们来简单总结下 ：<br><code>使用场景 :</code></p><ul><li><p>可以动态给对象增加功能.</p></li><li><p>在不影响其他对象的情况下，以动态透明的方式给单个对象添加职责.</p></li></ul><p><code>优点 ：</code></p><ul><li><p>可以动态扩展一个对象的功能，在运行时也可以选择不同的装饰器从而实现不同的行为.</p></li><li><p>相比于继承的方式，它更灵活.</p></li><li><p>用户可以根据需要增加新的具体装饰类，而不需要修改原有代码，符合开放——封闭原则.</p></li></ul><p><code>缺点 ：</code></p><ul><li><p>当 Component 内部发生改变时，则会影响所有子类，如装饰类和被装饰者.</p></li><li><p>当出现错误时，寻找错误可能需要逐级排查，这就有点蛋疼.</p></li></ul><p>&emsp;&emsp;最后来张装饰模式的合照 ：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhreuzpd7j30j60ab0tu.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">Decorator 结构图</div></p><p>&emsp;&emsp;其实在日常生活中，处处都有装饰模式，如穿衣打扮、室内装潢等等，前提是我们要有发现美的眼睛，码农的世界不止 coding 。<br>好了，今天的学习就记录到这里了，也希望大家早日有房有车，走上人生巅峰。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装饰模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>买不起房就自己“盖房”来聊聊建造者模式</title>
      <link href="/2018/07/17/Builder/"/>
      <url>/2018/07/17/Builder/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三。今天把自己的房间整理打扫了下，感觉心情很 nice 阿！</p></blockquote><p>&emsp;&emsp;这是设计模式系列的第 七 篇学习记录。最近有个段子挺火的，具体内容不记得了，大概是说你天天多早起床，然后天天坚持学习，可依旧还是买不起房…阿，房价始终还是压在心里的一块大石，十年生死两茫茫，房价涨，房奴殇。作为还是学生的十三，可能还没那么深的感触，但是按这目前情况来看，这辈子怕是买不起了。既然买不起那我们就自己”盖房子”，好，那我们就来过把瘾……</p><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhraumiegj30j60cs3zy.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray">先来张图</div></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String floor;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String roof;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFloor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> floor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFloor</span><span class="params">(String floor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.floor = floor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWall</span><span class="params">(String wall)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wall = wall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoof</span><span class="params">(String roof)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roof = roof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(floor + wall + roof);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;都是些非常基础的代码，三个字段属性分别对应着房子的地板、墙壁以及房顶。十三个人喜欢带花园的别墅，咱就来创建个 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户直接建房子</span></span><br><span class="line">        House houseD = <span class="keyword">new</span> House();</span><br><span class="line">        houseD.setFloor(<span class="string">"花园别墅地板 -&gt;"</span>);</span><br><span class="line">        houseD.setWall(<span class="string">"花园别墅墙壁 -&gt;"</span>);</span><br><span class="line">        houseD.setRoof(<span class="string">"花园别墅房顶"</span>);</span><br><span class="line">        houseD.display();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花园别墅地板 -&gt;花园别墅墙壁 -&gt;花园别墅房顶</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从运行结果中看出，我们先一步步从地板开始建造，到墙壁再到房顶，最后这样我们自己盖了个别墅(YY 的厉害)，只可惜这可住了不了人…哈哈，可是我们回过头来仔细想想，我们盖房子的代码全都是写在客户端里，这明显不是个好办法，而且我们自己来盖房子明显是不够专业的，一般情况下我们都会委托建筑工程队来盖房子，我们只要告诉工程队我要建的是花园别墅就可以了，具体的建造细节我们不需要知道，你只要给我把别墅盖好了就行，所以这里我们可以用到建造者模式。<br><br></p><h2 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式 (Builder)"></a>建造者模式 (Builder)</h2><p>&emsp;&emsp;Builder 模式也叫建造者模式或者生成器模式，是一种对象创建型模式之一，<code>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</code>如果我们用了建造者模式，那么用户就只需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。</p><p>&emsp;&emsp;建造者模式中角色和职责 ：</p><ul><li><p>Director : 指挥者，用来根据用户需求创建对象，它构建了一个使用 Builder 接口的对象.</p></li><li><p>Builder : 抽象 Builder 类，规范产品的组建，一般由子类实现.</p></li><li><p>ConcreteBuilder : 具体建造者，实现抽象 Builder 类定义的所有方法，并返回组建好的对象.</p></li><li><p>Product : 产品类</p></li></ul><p>说完了概念，那么下面就来看看我们应该怎么使用建造者模式 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeFloor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeWall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRoof</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">getHouse</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的 House 类显然就是 Product 产品类，而这里我们新建了接口，对应的角色便是 Builder 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VillaBuilder</span> <span class="keyword">implements</span> <span class="title">HouseBuilder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    House house = <span class="keyword">new</span> House();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeFloor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setFloor(<span class="string">"花园别墅地板 -&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setWall(<span class="string">"花园别墅墙壁 -&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRoof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setRoof(<span class="string">"花园别墅屋顶 -&gt;别墅建成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">getHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来这个类实现了 Builder 类的方法，并且返回了组建好了的实例对象，毫无疑问它就是 ConcreteBuilder 类了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HouseBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseDirector</span><span class="params">(HouseBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.makeFloor();</span><br><span class="line">        builder.makeWall();</span><br><span class="line">        builder.makeRoof();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后，我们再新建个类，它持有 Builder 对象的引用并且有通知 Builder 开始创建对象的方法，它对应便是 Director 这个角色了，就好比我们要盖花园别墅，我们找到工程队，并和工程队设计师说我要建的是花园别墅，接着设计师便开始设计别墅建筑风格并指挥通知工人开工。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HouseBuilder villa = <span class="keyword">new</span> VillaBuilder();</span><br><span class="line">        HouseDirector d = <span class="keyword">new</span> HouseDirector(villa);</span><br><span class="line">        d.makeHouse();</span><br><span class="line">        House villaHouse = villa.getHouse();</span><br><span class="line">        villaHouse.display();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花园别墅地板 -&gt;花园别墅墙壁 -&gt;花园别墅屋顶 -&gt;别墅建成</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后，我们委托的工程队盖好了别墅，而我们只需要提供类型就可以了，如欧式城堡、四合院等等，至于别墅具体的建造细节我们无须知道，以上便是建造者模式的学习，相比于我们第一次直接在 Main 方法中编写代码，使用建造者模式无疑可扩展性更好。那么，最后我们来总结一下。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;Builder 模式主要用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临这复杂的变化。</p><p>&emsp;&emsp;使用建造者模式可以使客户端不必知道产品内部组成的细节，具体的建造者类之间是相互独立的且容易扩展。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建造者模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之原型模式</title>
      <link href="/2018/07/16/Prototype/"/>
      <url>/2018/07/16/Prototype/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三。最近把之前的文章删了又重发了，时间上可能不匹配，大家不要觉得奇怪。</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsa6dq5kj30j60crgnk.jpg" alt=""></div></p><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&emsp;&emsp;这是设计模式系列的第 六 篇学习记录，量变引起质变，学习路上还要坚持。今天我们猪脚是原型模式，下面就让我们一起来看看原型模式是什么鬼。<br><br></p><h2 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 (Prototype)"></a>原型模式 (Prototype)</h2><p>&emsp;&emsp;<code>原型模式</code>是一种对象创建型模式，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br>什么意思呢？别急，我们先简单举个例子，假设我们有个 Person 类，有属性及 Get Set 方法，如下 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + name + <span class="string">"  age: "</span> + age + <span class="string">"  sex: "</span> + sex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码非常简单，都是些基础，接下来我们在 Main 方法里创建实例 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setName(<span class="string">"Binshao"</span>);</span><br><span class="line">        p.setAge(<span class="number">29</span>);</span><br><span class="line">        p.setSex(<span class="string">"Man"</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.setName(<span class="string">"十三"</span>);</span><br><span class="line">        p1.setAge(<span class="number">13</span>);</span><br><span class="line">        p1.setSex(<span class="string">"Man"</span>);</span><br><span class="line"></span><br><span class="line">        p.display();</span><br><span class="line">        p1.display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么运行结果显示就为下面所示 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: Binshao  age: 29  sex: Man</span><br><span class="line">name: 十三      age: 13  sex: Man</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样子我们创建两个对象就需要两次实例化，假如这时候我们要多个对象岂不是要实例化多次，这可要麻烦死了。而且不知道大家有没有发现，我们上面创建的两个实例对象的基本结构(属性方法等)都是相同的，那我们有没有其他好的解决办法呢？没错，就用我们刚刚提到的原型模式，那么怎么来做呢，放码 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅克隆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + name + <span class="string">"  age: "</span> + age + <span class="string">"  sex: "</span> + sex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们让 Person 类实现 Cloneable 这个接口，Clone 顾名思义便是克隆的意思，Java 本身就有提供支持。接着我们再添加个 clone() 方法用来克隆生成新对象，也就是说通过复制原型(Person)来创建新的实例对象，这便完成了克隆，通过原型模式创建的对象，不仅仅<code>与原型对象具有相同的结构，还与原型对象具有相同的值</code>。<br>眼见为实，让我们来看看结果 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setName(<span class="string">"Binshao"</span>);</span><br><span class="line">        p.setAge(<span class="number">29</span>);</span><br><span class="line">        p.setSex(<span class="string">"Man"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆 p 对象</span></span><br><span class="line">        Person p1 = p.clone();</span><br><span class="line">        <span class="comment">// 当然我们也可以修改值(仅相对于对象数据是值类型)</span></span><br><span class="line">        <span class="comment">//p1.setName("LL");</span></span><br><span class="line">        <span class="comment">//p1.setAge(13);</span></span><br><span class="line">        <span class="comment">//p1.setSex("Girl");</span></span><br><span class="line"></span><br><span class="line">        p.display();</span><br><span class="line">        p1.display();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: Binshao  age: 29  sex: Man</span><br><span class="line">name: Binshao  age: 29  sex: Man</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样一看，果然我们克隆的对象和原型对象的值是相同的。当然，我们也可以修改数据值，前提是对象数据(字段)都是值类型的,如果字段是引用类型，克隆对象则复制引用所有变量但不复制引用的对象，也就是说原型对象和克隆对象引用的是同一个对象。事实上，这样的写法叫做浅克隆。</p><p>&emsp;&emsp;一脸懵逼？没事，我们来看看代码，相信大家就会明白了，首先给 Person 类添加个 friend 字段及 get set 方法 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; friends;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getFriends</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> friends;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFriends</span><span class="params">(List&lt;String&gt; friends)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.friends = friends;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅克隆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + name + <span class="string">"  age: "</span> + age + <span class="string">"  sex: "</span> + sex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们都知道每个人当然不止一个朋友，所以我们用容器来装载。接下来在 Main 方法里看看 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Person per1 = <span class="keyword">new</span> Person();</span><br><span class="line">        List&lt;String&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        friends.add(<span class="string">"Binshao"</span>);</span><br><span class="line">        friends.add(<span class="string">"十三"</span>);</span><br><span class="line">        per1.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        Person per2 = per1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(per1.getFriends());</span><br><span class="line">        System.out.println(per2.getFriends());</span><br><span class="line"></span><br><span class="line">        friends.add(<span class="string">"LL"</span>);</span><br><span class="line">        per1.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        System.out.println(per1.getFriends());</span><br><span class="line">        System.out.println(per2.getFriends());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Binshao, 十三]</span><br><span class="line">[Binshao, 十三]</span><br><span class="line">[Binshao, 十三, LL]</span><br><span class="line">[Binshao, 十三, LL]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从结果我们看到，克隆对象复制引用了原型对象的所有变量，并且克隆对像和原型对象引用的是同一个对象，对应到我们的例子便是你认识的所有朋友我也认识，因为它们都是同个对象所以能不一样才怪…我们希望的是它们之间可以互相不影响，那么这又怎么做才好呢？<br><br></p><h2 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a>深度克隆</h2><p>&emsp;&emsp;既然有了浅度克隆便有了深度克隆，深度克隆便把引用对象的变量指向克隆过的新对象，而不是原有的被引用的对象，那么我们直接上大招 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; friends;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getFriends</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> friends;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFriends</span><span class="params">(List&lt;String&gt; friends)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.friends = friends;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅克隆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深克隆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person per = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">            List&lt;String&gt; newFriends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String friends : <span class="keyword">this</span>.getFriends()) &#123;</span><br><span class="line">                newFriends.add(friends);</span><br><span class="line">            &#125;</span><br><span class="line">            per.setFriends(newFriends);</span><br><span class="line">            <span class="keyword">return</span> per;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + name + <span class="string">"  age: "</span> + age + <span class="string">"  sex: "</span> + sex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在这里添加了个深度克隆的方法函数，同样先是获得克隆对象，接着我们通过对 list 容器进行相关赋值，最终返回一个深度克隆的对象，这样一来，克隆对象便把引用对象指向这个复制的新对象，而不是原有的引用对象。最后，我们来验证下看看 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Person per1 = <span class="keyword">new</span> Person();</span><br><span class="line">        List&lt;String&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        friends.add(<span class="string">"Binshao"</span>);</span><br><span class="line">        friends.add(<span class="string">"十三"</span>);</span><br><span class="line">        per1.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        Person per2 = per1.deepClone();</span><br><span class="line"></span><br><span class="line">        System.out.println(per1.getFriends());</span><br><span class="line">        System.out.println(per2.getFriends());</span><br><span class="line"></span><br><span class="line">        friends.add(<span class="string">"LL"</span>);</span><br><span class="line">        per1.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        System.out.println(per1.getFriends());</span><br><span class="line">        System.out.println(per2.getFriends());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Binshao, 十三]</span><br><span class="line">[Binshao, 十三]</span><br><span class="line">[Binshao, 十三, LL]</span><br><span class="line">[Binshao, 十三]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样一来，果然它们之间可以完全不互相影响。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我们来总结下原型模式 ：</p><ul><li><p>由原型对象自身创建目标对象，也就是说，对象创建这一动作发自原型对象本身.</p></li><li><p>目标对象是原型对象的一个克隆，也就是说，通过 Prototype 模式创建的对象，不仅仅与原型对象具有相同的结构，还与原型对象具有相同的值.</p></li><li><p>根据对象克隆深度层次的不同，有浅度克隆和深度克隆.</p></li></ul><p>Ok，今天就到这里，溜了……<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>以古代帝皇来讲单例模式</title>
      <link href="/2018/07/15/Singletop/"/>
      <url>/2018/07/15/Singletop/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，昨天回家了，一早起来继续搬砖，嘿嘿。</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvclb9i4tyj30zk0k1n44.jpg" alt=""></div></p><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&emsp;&emsp;这是设计模式系列的第 五 篇学习记录，不知道各位大家喜欢读历史吗？十三就非常喜欢看历史，比如《资治通鉴》、《东周列国记》、《三国演义》等等，还记得上小学那会儿在底下看书看得入迷，只是时间一晃就再也不是红领巾了…</p><p>&emsp;&emsp;读史书中总是能看到各个朝代的皇帝，三宫六院，掌握着最高权力，站在食物链顶端俯视着天下，咱还是想想就好…那么对应在软件领域，我们怎么以代码形式来描述呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">": 众爱卿平身."</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Secretary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"大臣：吾皇万岁万岁万万岁!"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        King k = <span class="keyword">new</span> King();</span><br><span class="line">        k.setName(<span class="string">"秦始皇"</span>);</span><br><span class="line"></span><br><span class="line">        Secretary s = <span class="keyword">new</span> Secretary();</span><br><span class="line">        s.say();</span><br><span class="line">        k.say();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么运行程序就可以看到 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大臣：吾皇万岁万岁万万岁!</span><br><span class="line">秦始皇: 众爱卿平身.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是我们还忽略了一点就是，我们都知道每个朝代都只能有一个皇上，如果我们像上面那样子来写的话，就会有多个君主这样的情况发生，我们来演示下情况 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Secretary s = <span class="keyword">new</span> Secretary();</span><br><span class="line">        s.say();</span><br><span class="line"></span><br><span class="line">        King king = <span class="keyword">new</span> King();</span><br><span class="line">        king.setName(<span class="string">"秦始皇"</span>);</span><br><span class="line">        king.say();</span><br><span class="line"></span><br><span class="line">        King k = <span class="keyword">new</span> King();</span><br><span class="line">        k.setName(<span class="string">"汉武帝"</span>);</span><br><span class="line">        k.say();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大臣：吾皇万岁万岁万万岁!</span><br><span class="line">秦始皇: 众爱卿平身.</span><br><span class="line">汉武帝: 众爱卿平身.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一个朝代两个皇帝？这估计下面的大臣一脸懵逼…所谓一山不能容二虎，除非是母老虎，那么我们怎么才能避免上面的情况发生呢？——没错，你猜对了，单例模式。<br><br></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>&emsp;&emsp;单例模式是一种对象创建型模式，使用单例模式，可以保证为一个类只生成唯一的实例对象，保证一个类只有一个实例存在，同时提供能对该实例加以访问的全局访问方法。</p><p>&emsp;&emsp;好，那么我们就一起来动手写一写这个单例类 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> King k = <span class="keyword">new</span> King();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数私有化，保证不被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个全局的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">": 众爱卿平身."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们通过这样来改写，它便是一种单例模式的写法，实际上这种写法叫做饿汉式写法，饿汉饿汉，顾名思义，你看，一上来就直接 new 了个对象，能不饥饿？那么我们在 main 方法里测试下看看 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Secretary s = <span class="keyword">new</span> Secretary();</span><br><span class="line">        s.say();</span><br><span class="line"></span><br><span class="line">        King king = King.getInstance();</span><br><span class="line">        king.setName(<span class="string">"秦始皇"</span>);</span><br><span class="line"></span><br><span class="line">        King k = King.getInstance();</span><br><span class="line">        k.setName(<span class="string">"汉武帝"</span>);</span><br><span class="line">        king.say();</span><br><span class="line">        k.say();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大臣：吾皇万岁万岁万万岁!</span><br><span class="line">汉武帝: 众爱卿平身.</span><br><span class="line">汉武帝: 众爱卿平身.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们来看，通过单例类我们去获得了唯一的实例对象，即使我们想修改成两个君主也是修改不了的，这样一来就避免了上面的情况。这种写法在类加载时就完成了初始化，所以类加载较慢但获取对象的速度快，单例模式除了饿汉式写法，还有其他一些写法。<br><br></p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>来，骚年上码 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> King k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数私有化，保证不被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个全局的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> k = <span class="keyword">new</span> King();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">": 众爱卿平身."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面就是懒汉式写法，它声明了个静态对象，在用户第一次调用时初始化，在第一次加载的时候它需要实例化，并且在多线程里可是线程不安全的，我们都知道 CPU 调度，那么该怎么改良呢，来把锁试试，第一反应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> King k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数私有化，保证不被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个全局的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> k = <span class="keyword">new</span> King();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">": 众爱卿平身."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样一来我们解决了多线程中访问的问题，可如果这样线程每次调用方法都需要进行同步，无疑会造成不必要的开销。没事，接下来我们开大招。<br><br></p><h2 id="双重锁定-DLC"><a href="#双重锁定-DLC" class="headerlink" title="双重锁定 (DLC)"></a>双重锁定 (DLC)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> King k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数私有化，保证不被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个全局的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (King.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> k = <span class="keyword">new</span> King();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">": 众爱卿平身."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在方法里进行了两次判空，第一次是为了判断实例是否存在，第二次则是判断实例是否为空，通过这样的方式可以保证多线程的安全。写到这，心想这已经是最好的写法，NO，NO，没有最好只有更好，当然了，每种写法都各有其利弊。<br><br></p><h2 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数私有化，保证不被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个全局的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> KingHolder.Instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KingHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> King Instance = <span class="keyword">new</span> King();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">": 众爱卿平身."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;只有第一次调用方法时才会去初始化实例对象，不仅确保线程安全并且保证类实例对象的唯一性。<br><br></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>&emsp;&emsp;单例模式的学习笔记就做到这里了，单例模式在我们平常开发中非常常见，所以也不做太多介绍了。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之工厂方法模式</title>
      <link href="/2018/07/09/Creator/"/>
      <url>/2018/07/09/Creator/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，今天来记录下工厂方法模式的学习。</p></blockquote><p><div align="center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31473269&auto=0&height=66"></iframe></div></p><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvckphusuij30zk0k0dmi.jpg" alt=""></div></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&emsp;&emsp;这是设计模式系列的第 四 篇学习记录，本来今天十三想好好休息一天，可当真的闲下来后却觉得有点虚度光阴的感觉，还是学习去吧…</p><p>&emsp;&emsp;还记得上篇提到水果生产机吗？这里来个传送门 <a href="https://binshao.site/2018/07/07/simpleFactory/">设计模式之简单工厂模式</a>，还没有看过的小伙伴可以先去看看。之前我们就在水果生产机里使用了简单工厂模式来编写指令，我们只需要选择我们想要的水果然后按下按钮(程序运行)，水果生产机便会开始生产。在客户端中(main 方法)我们不用管该用哪个种类的水果实例，我们只需把选择的水果种类交给工厂，工厂便会生产出对应的水果实例。那么问题来了，假如现在十三突然想吃葡萄了，而生产机里还没有葡萄的样本数据(葡萄类)，那么我们就创建呗，然后还要在工厂类里的方法添加多一个分支条件，如下 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 方法，获得所有产品对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getFruit</span><span class="params">(String type)</span> <span class="keyword">throws</span> InstantiationException, </span></span><br><span class="line"><span class="function"> 5IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// 判断水果种类，这里忽略大小写</span></span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"apple"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Apple.class.newInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"banana"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Banana.class.newInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"grape"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Banana.class.newInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"请添加该水果样本数据以便生产..."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可这样一来，便会修改到原有的类，这显然不是个好办法，这样就违背了开放-封闭原则，这可怎么办才好呢？这不，工厂方法模式来了。<br><br></p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>&emsp;&emsp;那么什么是工厂方法模式呢？还有，它和简单工厂模式又有什么区别呢？别急，我们一个个来看。</p><ol><li><p>工厂方法模式 ： </p><p> 工厂方法模式同样属于类的创建型模式，也被称为多态工厂模式.</p><p> 工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中，核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品，符合开放-封闭原则.</p></li><li><p>工厂方法模式中的角色和职责 ：</p><p> 抽象工厂(Creator) 工厂方法模式的核心，任何工厂类都必须实现这个接口.</p><p> 具体工厂(Concrete Creator) 具体工厂类是抽象工厂的一个实现，负责实例化产品对象.</p><p> 抽象(Product) 工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口.</p><p> 具体产品(Concrete Product) 工厂方法模式所创建的具体实例对象.</p></li></ol><p>&emsp;&emsp;理论概念还是要有，光说不练假把式，接下来我们结合代码来理解下，这里我们的代码还是在上次的水果生产机代码上做修改，好，放码，“驾、驾，吁~”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">getFruit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">getFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BananaFactory</span> <span class="keyword">implements</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">getFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Banana();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们先定义了一个创建水果产品对象的抽象工厂接口，然后分别创建两个具体的水果工厂类，它必须实现抽象接口并实例化相应的水果实例，这样子我们就写好了，是不是非常简单，那么我们来测试一下 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得AppleFactory</span></span><br><span class="line">        FruitFactory af = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">        <span class="comment">// 通过AppleFactory获得apple实例</span></span><br><span class="line">        Fruit apple = af.getFruit();</span><br><span class="line">        apple.get();</span><br><span class="line"></span><br><span class="line">        FruitFactory bf = <span class="keyword">new</span> BananaFactory();</span><br><span class="line">        Fruit banana = bf.getFruit();</span><br><span class="line">        banana.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后运行程序，水果生产机一样也可以生产出水果。那么它与简单工厂模式又有什么区别呢，让我们一起来总结下。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;<code>工厂方法类</code>的核心是一个抽象工厂类，工厂方法模式之所以有一个别名叫多态性工厂模式是因为具体工厂类都有共同的接口，或者有共同的抽象父类。当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体对象以及一个具体工厂对象，原有工厂对象不需要进行任何修改，也不需要修改客户端，很好的符合了开放-封闭原则。</p><p>&emsp;&emsp;<code>简单工厂模式</code>的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相应的对象，对于客户端而言，去除了与具体产品之间的依赖，可简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好且不符合开放-封闭原则。</p><p>&emsp;&emsp;最后，我们回过头来想了下，其实无论是简单工厂模式还是工厂方法模式，选择判断(水果种类)的问题还是存在，只不过工厂方法模式是在客户端里，而简单工厂模式则是在工厂类里。十三迷惑的望向远方……<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂方法模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>哆啦A梦来讲简单工厂模式</title>
      <link href="/2018/07/07/simpleFactory/"/>
      <url>/2018/07/07/simpleFactory/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，还有几天就放假了，果然学生还是最轻松的职业。</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvckak8dvkj30b40b4jrn.jpg" alt=""></div></p><a id="more"></a><p><div align="center" style="font-size: 11px; color: red;">给大家打个招呼</div></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&emsp;&emsp;这是设计模式系列的第 三 篇学习记录，今天做下笔记记录后，估计得缓几天再来记录设计模式系列的学习过程，十三接下来得要期末考试了，目前为止已经记录了 三 个设计模式，虽说都是些平浅的知识，但十三还是要做个回顾，不是说只为了追求快而把学习过程过一遍，犹如囫囵吞枣。当然了，学好用好不只是一味埋头苦学，还需要大量的编码实践，共勉。</p><p>&emsp;&emsp;相信大家都看过哆啦A梦吧，它的口袋里似乎有着许多好玩有趣的道具，这不，它知道十三经常对着电脑，并且也知道十三喜欢吃水果可又穷得吃土，就送给了十三 一 台万能水果生产机器，可厉害了，按下按钮选择想要的水果便会自动生产出来，简直就是福音啊！<br><br></p><h2 id="神秘的万能水果生产机"><a href="#神秘的万能水果生产机" class="headerlink" title="神秘的万能水果生产机"></a>神秘的万能水果生产机</h2><p>&emsp;&emsp;十三要想吃到可口的水果也没有那么简单，这个生产机你得需要给它下达指令才能开始生产工作，十三来到了指令输入台看了示例，发现可以使用 Java 语言来写指令(惊了，哈哈），这可难不倒十三，不出一会儿功夫就写好了指令 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banana</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产香蕉..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产苹果..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;十三编好了两种生产水果的指令后，最后再来给启动按钮写了个指令，如下 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 开始生产水果</span></span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        apple.get();</span><br><span class="line">        Banana banana = <span class="keyword">new</span> Banana();</span><br><span class="line">        banana.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;十三完成所有指令后，迫不及待地按下生产机上的按钮，只听生产机发出一阵轻微的转动声响，然后就像烤面包机完成工作后发出“-叮-”的一声，接着便看到生产机吐出了水果，正是我们想要的苹果和香蕉，十三高兴地叫了出来并吃起了水果来，吃着吃着，十三心想，我是否可以再对刚才的指令进行一下优化，看看是否可以把程序耦合度降低，想了一会儿，突然十三灵光一闪，“有了，我可以考虑通过多态来做”，于是十三重新修改了指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产香蕉..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产苹果..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;增加了一个接口 Fruit ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态来实例化</span></span><br><span class="line">        Fruit apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        Fruit banana = <span class="keyword">new</span> Banana();</span><br><span class="line">        apple.get();</span><br><span class="line">        banana.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;按下按钮后，生产机同样也能生产出水果，“相比于第一次的写法，程序耦合度降低了不少。”，十三心想，但是如果我还想生产其他些水果，比如火龙果、葡萄等，这些都是很容易变化的地方，应该要考虑这个生产过程。通过一番查阅，十三找到了简单工厂模式可以解决这个问题。<br><br></p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>&emsp;&emsp;十三看到资料上是这样介绍简单工厂模式的：简单工厂模式属于类的创建型模式，又叫做静态工厂方法模式。通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><ul><li><p>工厂模式中的角色和职责 ： </p><p>  工厂(Creator) : 简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。</p><p>  抽象(Product) : 简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</p><p>  具体产品(Concrete Product) ：简单工厂模式所创建的具体实例对象。</p></li></ul><p>&emsp;&emsp;那么怎么对我们的水果生产机上运用呢？别急，看码 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 方法，获得所有产品对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getFruit</span><span class="params">(String type)</span> <span class="keyword">throws</span> InstantiationException, </span></span><br><span class="line"><span class="function"> 5IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// 判断水果种类，这里忽略大小写</span></span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"apple"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Apple.class.newInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"banana"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Banana.class.newInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"请添加该水果属性以便生产..."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里，我们就创建了个工厂类负责生产水果，只要我们选择并输入想要的水果，工厂类便会生产具体的水果产品，然后把生产好的水果产品返回给我们。当然，我们想要的水果必须得有样本属性在我们的水果生产机里，否则将生产不出来，这个时候，我们就得往生产机添加样本属性。假如添加梨，我们就得创建个类并实现接口，如下 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pear</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产梨..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样，我们就可以修改 main 方法里的代码了 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, </span></span><br><span class="line"><span class="function">    IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Fruit apple = FruitFactory.getFruit(<span class="string">"Apple"</span>);</span><br><span class="line">        Fruit banana = FruitFactory.getFruit(<span class="string">"Banana"</span>);</span><br><span class="line">        Fruit pear = FruitFactory.getFruit(<span class="string">"Pear"</span>);</span><br><span class="line">        apple.get();</span><br><span class="line">        banana.get();</span><br><span class="line">        pear.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样，我们的水果生产机便是可以快速生产出我们想要的水果，哈哈…好了，本篇简单工厂模式的学习就到这里了，建议大家也多吃点水果，有益健康哦！<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之策略模式</title>
      <link href="/2018/07/06/Strategy/"/>
      <url>/2018/07/06/Strategy/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，今天学院要拍毕业证照片，紧接着明年就要毕业了，滴答滴答，时间就这样悄悄地过去了…</p></blockquote><p>&emsp;&emsp;这是设计模式学习的第二篇学习记录，或许涉及知识层面不深，但十三始终认为好记性不如烂笔头，进阶高深知识也得要有扎实的基础，废话就不多说了，咱们开始今天的学习。</p><a id="more"></a><p>&emsp;&emsp;还记得前段时间各大电商平台的 618 年中大促活动吗？各种优惠返利活动，满 200 减 100，满 300 减 150 等等，让人看了眼花缭乱，控制不住自己分分钟想剁手有没有！那么上面这些优惠活动用代码该怎么实现呢？十三想都没想，直接对着键盘就是一顿狂敲，噼里啪啦，不出一会儿，十三就写好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (price &gt;= <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> price - <span class="number">100</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (price &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> price - <span class="number">150</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码非常简单，也能得到我们想要的结果，可是大家想过没有，如果这时还有其他打折优惠，那按照我们这样来写代码，那岂不是要写非常多的 if else 语句，要知道电商平台是可能经常性的更改打折额度和返利额度的，这样不得写死人，不仅代码不美观而且不利于维护，那该怎么办呢？这时十三熟练地打开 Google，面向搜索编程大法好，一番搜索下来发现，这个问题可以通过策略模式来解决。<br><br></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>&emsp;&emsp;那么问题来了，什么是策略模式呢？</p><ul><li>策略模式（Strategy）：它定义了算法家族，分别封装起来，让它们之间可以互相替换，即使算法发生了变化，使用算法的客户也不会受到影响。</li></ul><p>&emsp;&emsp;事实上，无论是哪家电商平台的打折又或是返利活动，其实都是一些算法，这些算法本身也只是商家为了赚钱的一种策略，算法可能随时替换变化，而我们可以用策略模式把这些变化给封装起来，别急，让我们先看下策略模式有哪些角色及对应职责：</p><ul><li><p>策略模式的角色和职责：<br>  Strategy：策略抽象.</p><p>  ConcreteStrategy：各种策略的具体实现.</p><p>  Context：策略的外部封装类，或者说策略的容器类，根据不同的策略执行不同的行为.<br>  策略由外部环境来决定的.</p></li></ul><p>&emsp;&emsp;那么接下来我们就来看看怎么用策略模式来改写我们上面的例子，首先我们先编写 Strategy 这个角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们写好了 Straategy 这个角色，它的职责便是定义所有支持的算法的公共接口，接着便是 ConcreteStrategy 这个角色，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (price &gt;= <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> price - <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (price &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> price - <span class="number">150</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到我们写了两个 ConcreteStrategy，它封装了具体的算法或行为，而它是继承自 Strategy，也就是我们所说的打折优惠活动，最后来看下最后一个角色 Context：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="comment">// 初始化时传入具体的策略对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据具体的策略对象，调用其算法的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.strategy.cost(price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Context 它维护了一个对 Strategy 对象的引用，而我们的 Main 方法，也就是客户端主要也是和它打交道，那么就来对它做下测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设购物所花费为 200 元</span></span><br><span class="line">        <span class="keyword">double</span> price = <span class="number">200</span>;</span><br><span class="line"><span class="comment">//        Context context = new Context(new StrategyA());</span></span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> StrategyB());</span><br><span class="line">        <span class="keyword">double</span> newPrice = context.cost(price);</span><br><span class="line">        System.out.println(<span class="string">"实际消费 : "</span> + newPrice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后，通过运行我们也能得到正确的结果，由于实例化不同的策略，所以在调用 context.cost()方法时，所获得的结果也是不尽相同的，到这里我们的这个小例子也就完成了。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;回过头来，我们来总结下策略模式，策略模式是一种定义一系列算法的方法，我们知道其实所有算法完成的都是相同的工作，也就是为了给消费者打折优惠，只是不同的算法有不同的实现，而我们可以以相同的方式调用所有的算法，减少各种算法之间的耦合，我们把具体的算法实现封装了起来，这样也就避免了重复编写条件语句。最后，来张策略模式的结构图：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvck9w8mlpj30z50gomzh.jpg" alt="策略模式 UML 图"></div></p><p>&emsp;&emsp;好了，关于策略模式的学习记录就到了这里，一会儿十三还得去拍毕业证照片，不多说了，下次见。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之备忘录模式</title>
      <link href="/2018/07/04/Memento/"/>
      <url>/2018/07/04/Memento/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三。今天广州的天气怕是要把我融化了，撑着伞走去实验室的路上，衣服都出汗湿透……</p></blockquote><a id="more"></a><p><div align="center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=165184&auto=1&height=66"></iframe></div></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;昨天嚷嚷着要学点理财知识，今天又撸代码了，风格转变真快…嘿嘿，这不还是撸代码来的痛快，偶尔换下口味嘛，读书、健身、写作一个都不落下，德智体全面发展，废话就不多说了。平常我们在学习或者看博客文章的时候，多多少少都会接触到源码方面，往往看源码看的却是一头雾水，源码不仅多且各种封装，以及设计模式的使用，新手看的是一个头两个大，比如我就是…刚好，最近也在学习设计模式，借此机会也来记录下，都是些平浅的知识，望各位不吝赐教。<br><br></p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>&emsp;&emsp;相信大家可能都有遇到这种情况，有时候我们在编辑 Word 文档或者在 PS 里修图的时候，应用突然奔溃，当我们再次打开的时候，它便提示我们是否进行恢复数据，那么它是怎么实现的呢，我没想过…假设现在我们有一个 Person 类，分别有姓名，性别，年龄。那么我们给它赋值后，假如我还想修改，那么该怎么做呢？我们就快速写一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String sex, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name:"</span> + name + <span class="string">",sex:"</span> + sex + <span class="string">",age:"</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;非常简单，接下来我们继续看 main 方法的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mainClass</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person(<span class="string">"Binshao"</span>, <span class="string">"Man"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行备份</span></span><br><span class="line">        Person backUp = <span class="keyword">new</span> Person();</span><br><span class="line">        backUp.setName(per.getName());</span><br><span class="line">        backUp.setSex(per.getSex());</span><br><span class="line">        backUp.setAge(per.getAge());</span><br><span class="line"></span><br><span class="line">        per.display();</span><br><span class="line">        <span class="comment">// 修改</span></span><br><span class="line">        per.setAge(<span class="number">23</span>);</span><br><span class="line">        per.display();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复</span></span><br><span class="line">        per.setName(backUp.getName());</span><br><span class="line">        per.setSex(backUp.getSex());</span><br><span class="line">        per.setAge(backUp.getAge());</span><br><span class="line"></span><br><span class="line">        per.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上面简单的代码我们就实现了恢复数据属性的操作，但是不知道大家发现没有，这样一来，在 main 方法中进行了太多的操作，又是赋值又是修改的，过于繁杂且不符合单一职责原则，那怎么办呢？这时候，备忘录模式就登场了。<br><br></p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>&emsp;&emsp;如果一个对象需要保存状态并可通过 undo 或 rollback 等操作恢复到以前的状态时，可以使用备忘录模式。其名所示，可以进行恢复回滚数据的操作。</p><ul><li>备忘录(Memento) : 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以对该对象恢复到原先保存的状态。</li></ul><ul><li><p>备忘录的角色和职责 :<br>  Originator(原生者)：需要被保存状态以便恢复的那个对象.</p><p>  Memento(备忘录)：该对象由 Originator 创建，主要用来保存 Originator 的内部状态.</p><p>  Caretaker(管理者)：负责在适当的时间保存/恢复 Originator 对象的状态.</p></li></ul><p>&emsp;&emsp;说了这么多，我们来看看上面那个例子用代码怎么实现。</p><p>&emsp;&emsp;首先是 Person 类的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String sex, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name:"</span> + name + <span class="string">",sex:"</span> + sex + <span class="string">",age:"</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个备份</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(name, sex, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复备份，还原</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = memento.getName();</span><br><span class="line">        <span class="keyword">this</span>.sex = memento.getSex();</span><br><span class="line">        <span class="keyword">this</span>.age = memento.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到这里多了两个方法，也就是创建备忘录方法和恢复备份这两个方法，我们的 Person 类便是对应角色里的 Originator，而 Memento 备忘录对象则是要由 Originator 来创建，然后我们创建备忘录对象并把要保存的数据导入并实例化到 Memento 对象里去，这也就是我们在 Person 类里面创建的 createMemento 方法。</p><p>&emsp;&emsp;那么这个 Memento 类又是长的什么样子呢？别急，接着往下面看 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String name, String sex, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;猛地一拍大腿，这怎么和 Person 类的代码差不了多少，没错，因为 Memento 类保存的便是 Originator 的内部状态，也就是保存的是我们的 Person 类的内部状态，所以当然差不了哪里去。</p><p>&emsp;&emsp;那么到这里，就还剩下最后一个 Caretaker，来，看码 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里面便是对 Memento 引用，代码非常简单。接下来，我们在 main 方法里看看使用？睁大眼睛，骚年 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person(<span class="string">"Binshao"</span>, <span class="string">"Man"</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 创建管理者并设置备忘录</span></span><br><span class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">        caretaker.setMemento(per.createMemento());</span><br><span class="line"></span><br><span class="line">        per.display();</span><br><span class="line">        <span class="comment">// 修改年龄</span></span><br><span class="line">        per.setAge(<span class="number">23</span>);</span><br><span class="line">        per.display();</span><br><span class="line">        <span class="comment">// 调用恢复备份的方法</span></span><br><span class="line">        per.setMemento(caretaker.getMemento());</span><br><span class="line">        per.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行并看到结果，我们先修改了值然后又把值恢复了。而保存的细节我们封装在 Memento 中，要保存的细节也不会影响到客户端了，就这样，我们这个小例子就写完了，最后再来张备忘录模式的结构图 : </p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvcjgzp9vgj30lw0ajab4.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">结构图</div></p><p>&emsp;&emsp;好了，就写到这里了，祝大家有个愉快的下午茶，下午茶？不存在的……<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘录模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>黑苹果踩坑指南</title>
      <link href="/2018/06/25/blackApple/"/>
      <url>/2018/06/25/blackApple/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三。刚刚高考分数线发布出来了，想必也是有人欢喜有人愁，回想起来，不免心生些许感概。</p></blockquote><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvciqr1843j30zk0n9n2g.jpg" alt=""></div></p><p><div align="center" style="font-size: 13px; color: gray;">十三也想要台 Mac</div></p><h2 id="最近"><a href="#最近" class="headerlink" title="最近"></a>最近</h2><p>&emsp;&emsp;自从上星期端午假后，接下来十三一直都在忙课程设计，What，什么课程设计？iOS…十三所在专业是移动应用专业，也正因此走上 Android 不归路，当然了，既然是移动端，少不了 iOS，这不，十三最近不是正忙着课程设计上嘛。当然了，由于这些年，移动互联网热度的下降，这大大地打击同学们上课的热情（十三从来就很认真，哼哼..大雾），导致于最近不少同学在弄课程设计上都哭爹喊娘的，我也替这些同学感到些惋惜，学院配备全 Mac 一体机的机房环境，这还真是浪费了这良好的学习环境。这不是重点，重点是 Mac 实在是太好用了，我都想放弃自己这台大卡逼 Window 了，还是因为这万恶的金钱，穷啊！</p><p>&emsp;&emsp;所以既然要完成课程设计，无可奈何，只能黑苹果了。通常情况下，都是用 VMware 来跑 Mac 系统，具体安装的流程大家网上搜索下就能找到了，比较坑的是网上提供的系统资源要么跑不起来，要么就是系统版本和 VMware 解锁黑苹果补丁不匹配，除了这点比较坑之外，其他的都可以正常按流程走下去。十三至少花了一天半的时间下镜像和 Xcode 安装包，至少十几个 G，加上学院宿舍里渣渣网速，醉了醉了…<br><br></p><h2 id="黑苹果"><a href="#黑苹果" class="headerlink" title="黑苹果"></a>黑苹果</h2><p>&emsp;&emsp;当然了，十三今天已经把课程设计完成了，十三就把要用到的资源共享下，顺便来说下黑苹果要注意的地方。</p><ul><li><p>首先 VMware 默认是没有安装苹果镜像选项的，所以需要打补丁，而补丁又得要和对应 VMware 版本搭配才能使用，否则无效。</p></li><li><p>其次，当我们完成上面第一步的时候，基本也就能进入苹果系统了，接下来安装 Xcode，要注意 Xcode 版本是对我们安装 Mac OS 版本是有要求的，低版本的 OS X 是不支持高版本的 Xcode，这点大家务必注意下，毕竟 XCode 下载动辄几个 G，对应关系给个例图。</p></li></ul><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvcivf1cpdj30qa06omy0.jpg" alt=""></div></p><p><div align="center" style="font-size: 13px; color: gray;">对应版本关系图</div></p><p>&emsp;&emsp;走到了这一步，基本上我们 iOS 的开发环境就已经是搭建起来了，别急，我们还可以再优化一下，毕竟虚拟机下跑个系统，机器硬盘下那是卡出了翔……</p><ol><li><p>首先，刚进入桌面就发现一堆的通知显示，这些我们都可以在<code>系统偏好设置</code>中进入<code>扩展</code>选项中，把不需要的通知组件都取消勾选掉，不仅清爽还能流畅不少。</p></li><li><p>其次，OS X 中的菜单和 Dock 都采用了透明效果，好看是好看，可 TM 吃性能，在<code>系统偏好设置</code>中进入<code>辅助功能</code>选项中，然后我们找到<code>减少透明度</code>选项并把它勾选上。</p></li><li><p>最后，来个大杀器——<code>beamoff</code>，安装它可以提升 OS X 在 VMware 的性能，我们可以把它设置为开机自动运行。</p></li></ol><p>&emsp;&emsp;好了，经过上面几步的优化，都可以流畅使用，偶尔会些许卡顿，哎哟，真是累死我了…好了，我把一些用到的资源都共享到百度云盘上，大家去阅读原文点击就能跳转到资源页面了。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;这几天在做课程设计上，发现写代码还是比较行云流水的，主要还是课上 OC 基础语法掌握的不错，我想，这也可以涉及到广度的选择上吧，记得主席任玉刚在博客曾说道他在校期间深入学习 Android 的同时也去了解其他，如 Html，Java 等等，这不也算是扩大自己的知识面吗？这样技术的广度和深度也就有了，而 iOS 作为移动开发，玩 Android 的我们也是可以去看看的，没有坏处。学习之路漫长，还有很多东西要学，大家一起加油，我也争取早一天拥有我第一台的 Mac，无它，好用。溜了溜了…<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑苹果 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>推荐一些读过的技术书籍</title>
      <link href="/2018/06/17/readBook/"/>
      <url>/2018/06/17/readBook/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三，端午三天小长假，不知道大家都去哪里浪？</p></blockquote><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvcgt2rm09j30zk0npjwb.jpg" alt=""></div></p><p><div align="center" style="font-size: 13px; color: gray;">photo by Wistaria from Polayoutu</div></p><h2 id="杂七杂八……"><a href="#杂七杂八……" class="headerlink" title="杂七杂八……"></a>杂七杂八……</h2><p>&emsp;&emsp;各位，又是一段时间没来这里写东西了，最近朋友圈可都被世界杯刷屏了，吐槽下，平时看起来不关心的同学，一下子仿佛成了资深球迷，点评的头头是道，就像是要蹭个热点刷个存在感似，发现人都是害怕孤独的，然而一切都被机智的我看穿了（丫的，挺能装！），哈哈！</p><p>&emsp;&emsp;端午节大家去浪的同时，记得给家里人打个电话，有时候吧，亲情阿，懂得自然就懂，十三从来就很珍惜当下，或许我是性情中人？可能真的哪一天才发现失去了最美好的，那时候才真的是后悔莫及。</p><p>&emsp;&emsp;好了，自从最近看完了《Java编程思想》后，我萌发了从头看看自己之前学习的 Android 代码和笔记的念头，说干就干，近几天，由浅入深，我都在回过头来看看之前做的笔记和代码，当然，这比刚入门那会儿来的要轻松，我知道这是基础打得牢固的重要性，一直都要注重基础。滴答滴答，时间就这么过去了，也算是对之前学过的东西做了次回顾，查缺补漏，市面上讲叫做建立自己的知识体系，而一点一点的知识基础，汇总成一个个知识面，由点到面逐渐形成体系。就像书的目录编排，它是有系统性的，由浅入深的。当然了，学的越多不懂得也就越多，这里，大家一起加油！</p><p>&emsp;&emsp;最后就是，这些天刚好各大电商平台都在搞活动，京东和当当都在促销，这里推荐一些 Android 书籍，这些书我都买了并且认为不错。书籍作者都是一些我们熟知的大神，有郭神，主席任玉刚，刘望舒，医生，当然了还有鸿洋大神的玩安卓网站等等，就不废话了。</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvcgtx1c7bj305k074jrk.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">《第一行代码 第二版》 郭霖著</div></p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvch56zgm6j305k077glu.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">《Android群英传》 徐宜生著</div></p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvch5jn13tj305k07ajrh.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">Android开发艺术探索》 任玉刚著</div></p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvch1f11j3j305k07dt8x.jpg" alt=""></div></p><p><div align="center" style="font-size: 11px; color: gray;">Android进阶之光》 刘望舒著</div></p><p>&emsp;&emsp;当然了，除了技术书籍，其他的书籍我也喜欢看，以后再推荐吧，也欢迎大家推荐一些好书给我，端午节快乐，大家！<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 书籍 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读 《Java编程思想》</title>
      <link href="/2018/06/09/Thinking-in-Java/"/>
      <url>/2018/06/09/Thinking-in-Java/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，我是十三。大家最近又去哪里快活了？广州这边近几天受台风影响狂下雨，凉飕飕的，下雨天很适合睡觉啊。</p></blockquote><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsq2jfz7j305k07udg6.jpg" alt=""></div></p><p><div align="center" style="color: gray; font-size: 13px;">Java编程思想</div></p><a id="more"></a><h2 id="写点小感悟"><a href="#写点小感悟" class="headerlink" title="写点小感悟"></a>写点小感悟</h2><p>&emsp;&emsp;就在今天早上，我“粗略”地读完了《Java编程思想》这本书，之所以说是粗略看完，是因为书中有好些地方没能搞懂，奈何本人太过菜鸡，功力太浅。而这些没搞懂的地方我暂且把它搁置在了一边，或许某天再去翻过时，我可能会恍然大悟，这期间我还需要经过历练，需要大量的修行。</p><p>&emsp;&emsp;这本书相比一般的书籍来说它非常厚，个人认为入门新手不太适合用这本书，实在是太打击学习热情了。读完这本书，收益也是颇多。首先，能静下心来去看这本书，不说能学到什么，首先能有这份脚踏实地，心平气和的心态就已经很了不起了，现如今浮躁之人比比皆是。其次，与我而言读此书也算是一个回炉重造的过程吧，学 Android 以来，再去回顾 Java ，你就会发现有些知识点会稍显生疏了，而有些东西是我在刚入门 Java 的时候没学过或不知甚解的，才发现其实有很多东西是不知道的，或者说是了解的太过于表面。这个过程会很痛苦，但同时你也知道自己该往哪里学。</p><p>&emsp;&emsp;现在 Google 都在推 Kotlin 了。身边有许多同学这样说，还是不要太浮躁。万变不离其宗，只有深入其原理，再去学习其他也能快速上手，这也是我再回顾 Java 知识的原因，对于基础要扎实同时还要深入。不知道自己不知道，知道自己不知道，知道自己知道。这里与大家共勉，大家一起加油。</p><p>&emsp;&emsp;好了，就说那么多！又到饭点了，可周末学院里的饭菜不太喜欢吃…可想想，明年毕业的我可能再也没机会吃后，又开开心心的去饭堂了。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习路上的一些感悟</title>
      <link href="/2018/04/27/StudyWay/"/>
      <url>/2018/04/27/StudyWay/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，大家好！再过三天就是五一了，想好去哪浪了没？今天分享学习路上的一些感悟，一首李荣浩的 《老街》 送给大家。</p></blockquote><a id="more"></a><p><div align="center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=133998&auto=1&height=66"></iframe></div></p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhso1eitgj30j60csdil.jpg" alt=""></div></p><p><div align="center" style="font-size: 13px; color: gray">Photo by qjk6538 from Polayoutu</div></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>&emsp;&emsp;最近听到有同学抱怨寝室环境不好，加上平时上课觉得老师讲的知识没什么用，还不如自己去自学，上课纯属浪费时间，我认为这是不妥的，在校学习的知识都是基础，我们都知道万丈大楼都是从地基垒起，万变不离其宗，只有打下扎实的基础才能走的更远，虽然基础学习过于枯燥，但不可放弃啊。<br><br></p><h2 id="PotPlayer"><a href="#PotPlayer" class="headerlink" title="PotPlayer"></a>PotPlayer</h2><p>&emsp;&emsp;PotPlayer 是个播放器，它有多强大就不做过多介绍了，最好用就是它的倍速播放，效率提高的可不是一点半点，当然播速是在你能接受范围内，不要只是一味追求速度。不管是看视频也好，看书也罢，每个人都应该有自己的一套学习体系，适合自己的才是最好的，最后，编程是个手艺活，要动手实践，牛逼的奥义在于重复，与大家共勉。<br><br></p><h2 id="做你想做的事"><a href="#做你想做的事" class="headerlink" title="做你想做的事"></a>做你想做的事</h2><p>&emsp;&emsp;难道除了学习就是学习了吗？当然不是，毕竟生活丰富多彩，特别是校园生活，不要为了学习而学习，拒绝“苦行僧”式学习，那样子和机器有什么区别？运动、读书都是值得我们付出时间去做的，我从小就喜欢打乒乓球，坐在电脑前久了就去打上几球，同时我还喜欢旅游，虽然穷逼一个，最想去大理了，觉得那里风景好美。<br><br></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>&emsp;&emsp;珍惜现在的校园时光，时间过得真快，或许这是人生中最后一次的校园生活，记录下这些感悟，也许在以后的某天翻见会一笑带过。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> 时光任意门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习路上 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Activity 基础总结</title>
      <link href="/2018/03/13/Activity/"/>
      <url>/2018/03/13/Activity/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hello，大家好！今天周一，大家鼓足干劲就是干，反手就是一巴掌（哈哈）。</p></blockquote><p>&emsp;&emsp;这篇文章是关于 Activity 的一些总结（小白文，莫喷)，其中部分是刚哥《艺术探索》的读书笔记，Activity 作为四大金刚中出现频率最高的组件，我们可以在各个地方都可以见到它。总结过程中也借此好好回顾下，分享给大家，当然也希望各位大牛能不吝赐教。</p><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.in/large/0072Lfvtly1fzhqwo6odlj30j60csgog.jpg" alt=""></div></p><p><div align="center" style="font-size: 13px; color: gray;">Photo by lwowomeme from polaxiong</div></p><h2 id="Activity-的四种状态"><a href="#Activity-的四种状态" class="headerlink" title="Activity 的四种状态"></a>Activity 的四种状态</h2><p>&emsp;&emsp;关于什么是 Activity 的概念我就不介绍了，都烂大街了。Activity 有多种状态，它可以在这几种状态之间切换，并以此影响着 Activity 的生命周期。</p><ul><li><p>Running：<br>  表明 Activity 处于活动状态，用户可以点击屏幕并作出响应，这时候处于 Activity 栈顶。</p></li><li><p>Paused：<br>  表明 Activity 失去焦点或被非全屏 Activity 覆盖，失去和用户交互的能力，在内存不紧张情况下，所有状态信息都还会存在。</p></li><li><p>stopped：<br>  被其他 Activity 完全覆盖，不再是可见的，状态信息同上。</p></li><li><p>Killed:<br>  Activity 已经被系统回收且所有状态信息不存在。<br>  从上面我们可以看出，用户者不同的操作行为会让 Activity 在不同的状态间切换，接下来我们来看看它的生命周期。</p></li></ul><p><br></p><h2 id="Activity-的生命周期"><a href="#Activity-的生命周期" class="headerlink" title="Activity 的生命周期"></a>Activity 的生命周期</h2><p>&emsp;&emsp;先来张经典的官方 Activity 生命周期图：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqyhln3bj30e90ifgm6.jpg" alt=""></div></p><p><div align="center" style="font-size: 13px; color: gray;">Activity 生命周期</div></p><p>&emsp;&emsp;我们来回顾下上面的方法，看看自己还记得多少（偷笑）：</p><ul><li><p>onCreate()<br>  这是生命周期的第一个方法，此时 Activity 正在创建，一般我们会做一些初始化工作，如加载界面、初始化数据等。</p></li><li><p>onStart()<br>  此时 Activity 正在启动，这时的 Activity 已经可见，可是还没有出现在前台，也就无法和用户进行交互。</p></li><li><p>onResume()<br>  这时候的 Activity 已经可见了且是出现在前台了，<code>注意：和 onStart()相比，onResume()的时候，Activity 已经显示在前台了。</code></p></li><li><p>onPause()<br>  此时的 Activity 正在停止，然后 onStop()就会被调用，一般我们可以做些存储数据等操作，<code>但是这里要注意，不可以做太过耗时操作。</code></p></li><li><p>onStop()<br>  此时的 Activity 即将停止。</p></li><li><p>onRestart()<br>  此时 Activity 正在重新启动，假如 Activity 从不可见重新变为可见的时候，这个方法就会被调用，如打开一个新的页面然后又返回当前 Activity。</p></li><li><p>onDestroy()<br>  这是生命周期最后一个回调方法，此时的 Activity 即将销毁，通常我们会做写资源释放等操作。</p></li></ul><p><br></p><h2 id="生命周期的分析"><a href="#生命周期的分析" class="headerlink" title="生命周期的分析"></a>生命周期的分析</h2><ul><li><p>Activity 启动：onCreate() -&gt; onStart() -&gt; onResume()</p></li><li><p>Home 键返回主界面或被覆盖(Activity 不可见)：onPause() -&gt; onStop()</p></li><li><p>回到原 Activity：onRestart() -&gt; onStart() -&gt; onResume()</p></li><li><p>退出当前 Activity：onPause() -&gt; onStop() -&gt; onDestroy()</p></li></ul><p>&emsp;&emsp;以上就是 Activity 的生命周期分析，各位是不是对整个流程信手捏来，我只能说 666 了！</p><p>&emsp;&emsp;最后这里再说一个问题，如果当前 Activity 为 A，此时用户再打开一个新的 Activity 页面 B，<code>Activity A 的 onPause()方法会先调用，然后才调用 B 的 onResume()方法，也就是 Activity B 才启动。这也就是我们说为什么不能在 onPause()方法做太耗时操作。</code>    </p><p>&emsp;&emsp;你以为生命周期介绍到这里就没了？当然不是，上面那是正常情况下，难不保有意外，不然保险公司为啥赚的盆满坡满？<br>这些意外就是系统配置发生了改变，如旋转屏幕。又或是因为内存不足导致 Activity 被 Kill 掉，都是极有可能的。</p><ul><li><p>系统配置发生改变，Activity 就会被销毁然后再重新创建，如果我们不想让 Activity 重新创建，我们也可以通过 Activity 指定 configChanges 属性值为 orientation 值。同时因为 Activity 在这种意外情况下被销毁，系统就会通过 onSaveInstanceState()方法 保存当前 Activity 的状态信息，然后我们可以通过 onRestoreInstanceState()方法 取出并恢复保存的数据，关于这方面的 View 的存储和恢复，具体我就不介绍了，大家感兴趣的可以自己去看看，当然大家可能早就熟门熟路了，嘿嘿。当然了，Android 系统默认实现了控件的状态缓存，减少了开发者的工作量。</p></li><li><p>内存不足导致 Activity 被杀死，当然系统也是按照情况来杀掉进程的，这也就是进程优先级，它们之间的关系如下：<br>  前台 &gt; 可见 &gt; 服务 &gt; 后台 &gt; 空<br>  优先级越大越不容易被杀死，从这里也可以看出，一些重要的后台工作应当放入 Service 中保证不被系统杀死。</p></li></ul><p><br></p><h2 id="Activity-的-LaunchMode"><a href="#Activity-的-LaunchMode" class="headerlink" title="Activity 的 LaunchMode"></a>Activity 的 LaunchMode</h2><p>&emsp;&emsp;在介绍启动模式前，我们先来说说 Android 的任务栈，Android 系统通过栈保存 App 的 Activity，这个栈也就是 Task，表示若干个 Activity 集合，一个 Task 中的 Activity 可以来自不同的 App。对于栈，大家应该都很熟悉，它是一个先进后出的线性表，我就不啰嗦了。</p><p>&emsp;&emsp;启动模式一共有四种启动模式：standard，singleTop，singleTask 和 singleInstance。</p><p>对于它们之间的区别以及功能我就不介绍了，想必大家应该耳熟能详了。那么如何设置启动模式？</p><ul><li>通过 AndroidMenifest 指定：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.example.binshao.mainActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:configChanges</span>=<span class="string">"orientation"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"singleTop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过 Intent 设置 Flag 指定启动模式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(MainActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;还有其他一些常用的 Flag 大家也可以去搜一搜，我这里也不一一介绍了。<br><br></p><h2 id="IntentFilter-使用"><a href="#IntentFilter-使用" class="headerlink" title="IntentFilter 使用"></a>IntentFilter 使用</h2><p>&emsp;&emsp;我们都清楚启动 Activity 可以分为显式调用和隐式调用。显式调用，顾名思义就是明确指定被启动目标对象的信息，非常简单也就不详细介绍了。而隐式调用则相反，它需要 Intent 去匹配目标对象的 IntentFilter 设置的过滤信息，IntentFilter 的过滤信息有 action、category、data。假如与目标对象的不一致则无法启动目标对象。</p><p>&emsp;&emsp;一个过滤信息表中的 action、category 和 data 可以有多个，一个 Activity 当中也可以有过个过滤信息表 intent-filter，只要一个 Intent 能对应其中一组过滤信息表就可以启动对应的目标对象。</p><ul><li><p>action<br>  action其实是字符串，系统也定义了一些 action，还记得那会入门的拨打电话小案例吗？嘿嘿，当然我们可以自定义action。只要 Intent 中的 action 能够和过滤列表中的任何一个 action 值相同就配对成功，值相同指的是 action 的字符串值是一样的。<code>注意：action 是区分大小写的。</code></p></li><li><p>category<br>  category 也是字符串，但是它的配对规则和 action 不同，它要求如果 Intent 中如果含有 category 信息，那么这些所有的 category 都要和过滤列表中的任意一个 category 值相同，也就是 Intent 中的 category 已经是在过滤表中定义过的 category。<code>注意：Intent 可以没有 category，而且它也能配对成功，原因在于系统去启动 Activity 的时候默认会加上“android.intent.category.DEFAULT”这个 category，所以为了成功配对，我们要在过滤列表中添加这个 category。</code></p></li><li><p>data<br>  data 由 mimeType 和 URL 组成，mimeType 是媒体类型，这里就一笔带过吧！其实 data 的配对规则和 action 是相似的，它要求 Intent 中含有 data 数据且可以和过滤列表中任意一个 data 匹配，这个过程是过滤列表中的 data 也出现在 Intent 的 data 中，即配对成功。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:name</span>=<span class="string">"com.example.binshao.mainActivity"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.binshao.z"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.binshao.s"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"com.example.binshao.z"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"com.example.binshao.s"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;好了，到这里这篇文章也到了尾声，不知道各位看完是否有收获吗？大家可别因为是继承而忽视，当然这篇文章说是总结，却不够详细，如关于 View 的存储和恢复及源码等也还没深入，以及各种启动模式的应用场景等等，因为时间关系没有总结成文，很多时候自己会但是要提笔写出来真的挺费时间的，怎么说呢，抛砖引玉吧！接下来和大家一起共同进步！<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 主题和样式</title>
      <link href="/2018/03/10/AndroidTheme/"/>
      <url>/2018/03/10/AndroidTheme/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hi，大家好！今天是周末，不知道大家是和好友聚聚会还是去外面逛逛，又或是读上一两本好书，不管怎样，希望大家有一个愉快的周末。</p></blockquote><p>&emsp;&emsp;今天来和大家聊聊 Android 开发中的 Theme 和 Style，不知道大家是否和我一样，在刚刚学习 Android 那会，经常很迷惑，它们究竟是什么，之间又有什么关系？那好，我也在这里做个简单的介绍，希望起到一个抛砖引玉的效果（其实是我太菜，嘿嘿！）。</p><a id="more"></a><p>&emsp;&emsp;在这之前，给大家看看 Theme 是用来干什么的，上一个官方的图：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhr386kuaj30j6094glu.jpg" alt=""></div></p><p><div align="center" style="font-size: 13px; color: red;">两种不同主题带来的效果</div></p><p>&emsp;&emsp;相信各位看完，会不会猛地一拍大腿，“这 TM 的不是换肤吗？还是那种要充 QQ 会员才有的特权！”，嘿嘿。<br><br></p><h2 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h2><p>&emsp;&emsp;首先我们先来看看 Style，顾名思义，Style 风格、样式的意思，用来定义 View 的样式，比如 height、width、padding 等，是一套能够应用于视图组件的属性。</p><p>&emsp;&emsp;我们常常编写在 res/values/styles.xml 下，编写如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"GreenText"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textColor"</span>&gt;</span>#00FF00<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编写样式完成后，引用样式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"@style/GreenText"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行应用后，可以看到我们的字体颜色为我们定义的样式里字体颜色，非常简单，效果就不贴了。除此之外，样式还支持继承，它能继承并覆盖其他样式的属性。那么应该怎么编写呢？，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"GreenText.Large"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textSize"</span>&gt;</span>13dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;GreenText.Large 的命名表明，这个样式它继承了 GreenText 样式的属性，是不是感觉有点特别！除此之外，它不仅可以通过像这样通过命名表示样式继承关系，也还可以通过采用指定父样式来实现继承，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"BigGreenText"</span> <span class="attr">parent</span>=<span class="string">"GreenText"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textSize"</span>&gt;</span>13dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上就是 Style 的介绍，是不是非常简单呢？<br><br></p><h2 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h2><p>&emsp;&emsp;看完了 Style，再来看看 Theme，翻译过来是主题的意思，它与 Style 作用一样，不同于 Style 作用于个一个单独 View，而它是作用于 Activity 上或是整个应用。试想下，如果要为所有组件逐个添加样式，那样子工作量得多大呀！同样是定义一套公共主题属性，样式属性需要逐个添加，而主题属性自动应用于整个应用。</p><p>&emsp;&emsp;我们先打开 AndroidManifest.xml 文件，就可以看到 application 标签下的 theme 属性，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:theme</span>=<span class="string">"@style/Theme.AppCompat.Light"</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;theme 属性指向主题叫做 Theme.AppCompat.Light，也是定义在 styles.xml 文件中。所以在 AndroidManifest 文件中出现，主题自然可以应用整个应用。查看主题定义（styles.xml 文件下），如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>@color/colorPrimaryDark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>@color/colorAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;它们对应的属性值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"> <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--   color for the app bar and other primary UI elements --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>#3F51B5<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--   a darker variant of the primary color, used for</span></span><br><span class="line"><span class="comment">            the status bar (on Android 5.0+) and contextual app bars --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>#303F9F<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--   a secondary color for controls like checkboxes and text fields --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>#FF4081<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;colorPrimary 属性主要用来设置工具栏背景色，而 colorPrimaryDark 用于顶部的状态栏，注意：只有 5.0 之后的系统支持状态栏主题色，文不如图，下面来张图，更加直观：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhr2k4y81j30j60b5mxs.jpg" alt=""></div></p><p><div align="center" style="font-size: 13px; color: red;">图片来源于网络</div></p><p>&emsp;&emsp;现在在 Android Studio 中创建项目都是自带 AppCompat 主题，也就是兼容包下，还有就是Android 系统自带的主题以及我们自定义的主题，以上是主题的主要来源，同样也来张合照吧：</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhr20gkekj30ek0k5ta4.jpg" alt=""></div></p><p><div align="center" style="font-size: 13px; color: red;">图片来源于博客：<a href="https://www.cnblogs.com/zhouyou96/p/5323138.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhouyou96/p/5323138.html</a></div></p><p>&emsp;&emsp;当然，如果我们有需要，也可以添加自己的属性值或覆盖属性值。假如我们想要修改应用背景色，我们也可以在布局文件手动设置背景色属性，如果有许多页面都这样去修改处理，无疑是比较费时的，其实我们只需要覆盖主题背景色属性就可以解决上面的问题了，但是我们首先得找到主题的源头，主题继承导致我们要一层一层往下找，找到我们要的属性，再回到我们的 Styles.xml 文件下覆盖这个属性，也就是设置我们想要的属性值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    ...</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorBackground"</span>&gt;</span>@color/activityBackground<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>注意：colorBackground 属性来自系统，要使用 android 命名空间</code>。关于寻找属性值这个过程由于篇幅所限，我这里就不贴过程了。</p><p>好了，关于它们的介绍就简单说到这里，最后放下文档的链接：<br>【官网文档链接】：<a href="https://developer.android.google.cn/guide/topics/ui/look-and-feel/themes.html#Customize" target="_blank" rel="noopener">https://developer.android.google.cn/guide/topics/ui/look-and-feel/themes.html#Customize</a><br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 主题和样式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈事件分发机制</title>
      <link href="/2018/03/09/dispatch/"/>
      <url>/2018/03/09/dispatch/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hello，大家好！今天广州的天气真好，暖洋洋的，好适合出去玩玩出去走走。哈哈，毕竟老是待在电脑前也不是很好，其实我挺想去云南玩的，觉得那里真的好美！有机会，一定去！</p></blockquote><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhri6da6uj30j60as3zr.jpg" alt=""></div></p><h2 id="什么是事件分发"><a href="#什么是事件分发" class="headerlink" title="什么是事件分发"></a>什么是事件分发</h2><p>&emsp;&emsp;今天简单总结下事件分发机制，主要是了解事件的分发、拦截、以及处理事件的流程。在我们学习的时候，最好先对整体流程有一个大致的了解后，我们再去深入学习分发机制，这样就不好学得一头雾水，摸不着头脑！</p><p>&emsp;&emsp;了解事件之前，首先我们要知道触摸事件，一般为按下、滑动、抬起，这个想必大家都很清楚，而 Android 为这些触摸事件封装了个类 MotionEvent, 我们可以通过它去获取触摸点的坐标，或者去获得点击的事件类型，通过不同的 Action 实现不同的逻辑。我们都知道 View 可以放在 ViewGroup 里面，而 ViewGroup 又可以嵌套在另一个 ViewGroup 中，这时候问题就来了，我们的触摸事件到底要给谁处理，是给子 View 还是 父辈 ViewGroup？而事件分发其实就是这个 MotionEvent 事件的分发过程，当事件产生之后，需要把这个事件交给具体的一个 View 进行处理，而这个交付过程就是分发过程。<br><br></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&emsp;&emsp;这里我们可以联想一下生活中的常见场景，平时上班中，经理把个任务交给下属组长去办，而组长又把这个任务交给了我。当我奋力加班终于把任务完成后，就把完成结果交给了组长，组长又把任务完成结果交给了经理，这样一个任务顺利完成，到最后你发现，领导照样活的滋润，你还是你，苦逼！</p><p>&emsp;&emsp;通过上面这个例子是否更加了解整个过程呢？接下来继续说，事件的分发过程由三个方法完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"Binshao"</span>, <span class="string">"ViewGroupA dispatchTouchEvent"</span> + ev.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"Binshao"</span>, <span class="string">"ViewGroupA onInterceptTouchEvent"</span> + ev.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">       Log.d(<span class="string">"Binshao"</span>, <span class="string">"ViewGroupA onTouchEvent"</span> + event.getAction());</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>下面来介绍一下这三个方法：</p><ul><li><p>public boolean dispatchTouchEvent(MotionEvent ev)<br>  这个方法是用来进行事件分发的，事件如果传递给当前 View，方法会被调用.</p></li><li><p>public boolean onInterceptTouchEvent(MotionEvent ev)<br>  在上面的方法内部调用，是用来判断是否拦截事件，它的返回值为 True 不继续流程；默认为 False，不拦截继续流程.</p></li><li><p>public boolean onTouchEvent(MotionEvent event)<br>  用来处理点击事件，返回结果表示是否消耗当前事件.<br><br></p></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>&emsp;&emsp;光说不练假把式，这里上个简单演示，验证我们的结论：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">com.example.binshao.testdemo1.MyViewGroupA</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:background</span>=<span class="string">"@android:color/holo_blue_bright"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.example.binshao.testdemo1.MyViewGroupB</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"@android:color/holo_green_dark"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">com.example.binshao.testdemo1.MyView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"150dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"150dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:background</span>=<span class="string">"@android:color/darker_gray"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">com.example.binshao.testdemo1.MyViewGroupB</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.example.binshao.testdemo1.MyViewGroupA</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里直接就上布局文件了，自定义 View 和 ViewGroup 代码就不上了，非常简单，下面我们来看看日志打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E/Binshao: ViewGroupA dispatchTouchEvent0</span><br><span class="line">E/Binshao: ViewGroupA onInterceptTouchEvent0</span><br><span class="line">E/Binshao: ViewGroupB dispatchTouchEvent0</span><br><span class="line">E/Binshao: ViewGroupB onInterceptTouchEvent0</span><br><span class="line">E/Binshao: View dispatchTouchEvent0</span><br><span class="line">E/Binshao: View onTouchEvent0</span><br><span class="line">E/Binshao: ViewGroupB onTouchEvent0</span><br><span class="line">E/Binshao: ViewGroupA onTouchEvent0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;果然结果和我们分析的一样。</p><p>&emsp;&emsp;当一个事件产生后，首先会传递给根 ViewGroup，这时 dispatchTouchEvent 就会被调用，此时如果当前 ViewGroup 的 onInterceptTouchEvent 方法返回值为 true 就表示它要拦截当前事件，如果为 false 就表示不拦截当前事件，这时候事件就会继续传递到它的子元素，接着子元素就会像上面说的一样，如此重复直到事件被处理。假如所有的元素都不处理这个事件，那么这个事件最终传递给 Activity 处理，也就是它的 onTouchEvent 方法会被调用。<br><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><br></p><ul><li><p>ViewGroup 默认不拦截事件，它的 onInterceptTouchEvent 方法默认返回 false.</p></li><li><p>View 是没有 onInterceptTouchEvent 方法，一旦有事件传递给它，它的 onTouchEvent 方法就会被调用.</p></li><li><p>事件传递过程是由外向内的，也就是先传递给父元素，再由父元素分发给子元素.</p></li></ul><p><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件分发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 自定义属性</title>
      <link href="/2018/03/08/AttributeSet/"/>
      <url>/2018/03/08/AttributeSet/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>Hello，大家好！今天总结一篇自定义属性的文章，很久之前就想要总结了，懒……对了今天还是三月八日，祝各位小仙女女神节快乐！</p></blockquote><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhr5lawhij30dw0k6q55.jpg" alt=""></div></p><h2 id="自定义属性流程"><a href="#自定义属性流程" class="headerlink" title="自定义属性流程"></a>自定义属性流程</h2><p>&emsp;&emsp;对于自定义属性，大家肯定都已经滚瓜烂熟了（看来是我太菜了），主要是以下几步：</p><pre><code>*  自定义一个类继承自 View 类.*  在 values 目录下新建 XML 文件并编写标签元素.*  在自定义类布局文件中使用自定义属性.*  在自定义类中的构造方法通过 TypedArray 获取自定义属性.</code></pre><p>下面贴出代码演示下流程：</p><ol><li>自定义属性文件：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"number"</span> <span class="attr">format</span>=<span class="string">"integer"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"text"</span> <span class="attr">format</span>=<span class="string">"string"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>自定义 View 类并获取自定义属性：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MCustomView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Binshao"</span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MCustomView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>(context, attrs);</span><br><span class="line">         TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.test);</span><br><span class="line">         <span class="keyword">int</span> num = ta.getString(R.styleable.test_number, <span class="number">0</span>);</span><br><span class="line">         String text = ta.getInteger(R.styleable.test_text);</span><br><span class="line">         Log.e(TAG, <span class="string">"num = "</span> + num + <span class="string">" , text = "</span> + text);</span><br><span class="line">         <span class="comment">//  记得回收资源</span></span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>布局文件中就可以使用我们的自定义属性：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"> <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:binshao</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">tools:context</span>=<span class="string">"com.example.binshao.testdemo1.MCustomView"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">com.example.binshao.testdemo1.MCustomView</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">binshao:number</span>=<span class="string">"1339"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">binshao:text</span>=<span class="string">"十三"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;好了，接下来我们看一下日志打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">03-08 14:14:30.385 13084-13084/com.example.binshao.testdemo1 E/Binshao: num = 1339 , text = 十三</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到这里我们自定义属性流程就完成了，你以为就结束了？ No，通过网上搜索鸿神博客，构造方法中的参数 AttributeSet 也能获取我们的自定义属性，那我们要怎么获取呢？下面贴出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MCustomView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Binshao"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MCustomView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="keyword">int</span> attrsCount = attrs.getAttributeCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attrsCount; i++) &#123;</span><br><span class="line">            String attrNum = attrs.getAttributeName(i);</span><br><span class="line">            String attrText = attrs.getAttributeValue(i);</span><br><span class="line">            Log.e(TAG, <span class="string">"num = "</span> + attrNum + <span class="string">" , text = "</span> + attrText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">03-08 14:31:03.750 17331-17331/? E/Binshao: num = number , text = 1339</span><br><span class="line">203-08 14:31:03.750 17331-17331/? E/Binshao: num = text , text = 十三</span><br></pre></td></tr></table></figure><p><br></p><h2 id="关于-AttributeSet-与-TypedArray"><a href="#关于-AttributeSet-与-TypedArray" class="headerlink" title="关于 AttributeSet 与 TypedArray"></a>关于 AttributeSet 与 TypedArray</h2><p>&emsp;&emsp;那么问题来了，既然 AttributeSet 也能获取所有自定义属性，那么我们还要 TypedArray 干嘛呢？其实 TypedArray 其实可以帮助我们简化工作，如果我们使用 AttributeSet 去获取自定义属性，首先需要获取 id，其次再去进行解析，比较麻烦！而我们的 TypedArray 正是简化这一过程！</p><p>&emsp;&emsp;好了，今天就总结到这里了，最后我贴出鸿神博客地址，那里更加详细：<a href="http://blog.csdn.net/lmj623565791/article/details/45022631/" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/45022631/</a><br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 自定义属性 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SurfaceView</title>
      <link href="/2018/03/07/SurfaceView/"/>
      <url>/2018/03/07/SurfaceView/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>这几天让我感觉春天来了！到处散发着“春”（荷尔蒙）的气息？（微笑脸）<br>最近项目需要用到 SurfaceView，发现很久没有写 SurfaceView，什么都忘记了！真是好记性不如烂笔头，记录下吧！</p></blockquote><a id="more"></a><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhsour7uxj30j60arwgs.jpg" alt=""></div></p><h2 id="关于-SurfaceView"><a href="#关于-SurfaceView" class="headerlink" title="关于 SurfaceView"></a>关于 SurfaceView</h2><p>&emsp;&emsp;首先我们发现 SurfaceView 继承自 View，我们都知道 Android 系统提供了 View 让开发者进行绘图处理，那么这个 SurfaceView 又是用来干什么的呢？它和 View 之间又有什么爱恨情仇呢？别急！喝杯茶，且听我娓娓道来。  </p><p>View 的确可以进行绘图处理，但在某些情况下也有些心有余而力不足（才美不外现？），Android 系统通过发出信号对屏幕进行重新绘制，刷新页面间隔为 16 ms，在这段时间内，View 如果执行完成刷新页面操作，页面在视觉上就不会产生卡顿的现象，执行逻辑不多还好，任务一多，如需要频繁刷新页面，特别是 View 在主线程中更新 UI 界面，就会造成主线程阻塞、画面卡顿。你说那可怎么办才好？这不，Android 系统就提供了 SurfaceView 来解决这个问题！<br><br></p><h2 id="区别及使用场景"><a href="#区别及使用场景" class="headerlink" title="区别及使用场景"></a>区别及使用场景</h2><ul><li>SurfaceView 通过子线程中进行画面更新，View 则在主线程中进行画面更新。</li><li>SurfaceView 用于被动更新，如频繁画面更新，View 则用于主动更新，如触摸点击等事件响应等。</li><li>SurfaceView 在底层实现了双缓冲机制，效率大大提升了，View 则没有。</li></ul><p>那么什么时候使用 SurfaceView？<br>&emsp;&emsp;如果当前画面需要不停绘制或者数据处理量较大时，为避免 UI 线程堵塞，就用 SurfaceView 代替 View。<br><br></p><h2 id="光说不练假把式"><a href="#光说不练假把式" class="headerlink" title="光说不练假把式"></a>光说不练假把式</h2><p>&emsp;&emsp;编写 SurfaceView 是可以套用模板代码的，这里贴一下模板代码，然后我们这里面编写相应的逻辑即可！  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SurfaceViewTemplate</span> <span class="keyword">extends</span> <span class="title">SurfaceView</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">         <span class="title">SurfaceHolder</span>.<span class="title">Callback</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// SurfaceHolder</span></span><br><span class="line">    <span class="keyword">private</span> SurfaceHolder mHolder;</span><br><span class="line">    <span class="comment">// 用于绘图的Canvas</span></span><br><span class="line">    <span class="keyword">private</span> Canvas mCanvas;</span><br><span class="line">    <span class="comment">// 子线程开启标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsRunning;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SurfaceViewTemplate</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SurfaceViewTemplate</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SurfaceViewTemplate</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mHolder = getHolder();</span><br><span class="line">        mHolder.addCallback(<span class="keyword">this</span>);</span><br><span class="line">        setFocusable(<span class="keyword">true</span>);</span><br><span class="line">        setFocusableInTouchMode(<span class="keyword">true</span>);</span><br><span class="line">        setKeepScreenOn(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">        mIsRunning = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">        mIsRunning = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (mIsRunning) &#123;</span><br><span class="line">            draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCanvas = mHolder.lockCanvas();</span><br><span class="line">            <span class="comment">// 在这里编写绘制逻辑</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCanvas != <span class="keyword">null</span>)</span><br><span class="line">                mHolder.unlockCanvasAndPost(mCanvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到我们首先创建个模板继承自 SurfaceView，分别实现 SurfaceHolder.Callback 和 Runnable 这两个接口并实现接口里的方法，然后初始化 SurfaceHolder以及注册 SurfaceHolder的回调方法。和 View 一样，成员变量 Canvas 也是用来给 SurfaceView 进行绘图的，而布尔类型的 mIsRunning 则是用来控制子线程的，因为 SurfaceView 会在子线程中进行绘制操作。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceView 的创建</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">       mIsDrawing = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// SurfaceView 的改变</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// SurfaceView 的销毁</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">       mIsDrawing = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><div align="center" style="color: red; font-size: 13px;">实现 SurfaceHolder.Callback 接口的方法</div></p><p>&emsp;&emsp;绘制时，利用上图三个回调方法，在 surfaceCreated()方法开启子线程进行绘制操作，子线程中则使用 while 循环进行画面绘制，而绘制逻辑中通过 lockCanvas()方法获得 Canvas 对象去绘制对象，绘制完成后，最后通过 unlockCanvasAndPost(mCanvas)方法提交内容。</p><p>&emsp;&emsp;到这里整个模板代码就完成了，我们编写 SurfaceView 只需要套用模板，在里面编写相应的逻辑就可以了！<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SurfaceView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/02/17/hello-world/"/>
      <url>/2018/02/17/hello-world/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>&emsp;&emsp;Hi，我是十三，当然也可以叫我 Binshao。这是我的第一篇个人博客！</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrtqfqfkj30j60cswew.jpg" alt=""></div></p><a id="more"></a><h2 id="关于本博客"><a href="#关于本博客" class="headerlink" title="关于本博客"></a>关于本博客</h2><p>&emsp;&emsp;很早就有想法说搭个博客记录下学习过程以及遇到的问题，在这之前我已经是在微信维护着一个公众号，公众号上写写文字发发感悟还好，可要是记录技术总结就难免要涉及代码，可手机屏幕就那么大，这对我们看代码也不是很方便，要不就搭建个博客吧，说干就干，于是就有了这个博客的存在，花了点时间把公众号上的文字记录也搬了一份过来。<br><br></p><h2 id="记录初衷"><a href="#记录初衷" class="headerlink" title="记录初衷"></a>记录初衷</h2><p>&emsp;&emsp;俗话说：“好记性不如烂笔头！”，通过思考和提笔输出内容，这对于巩固知识无疑是一种很好的方式，在这个过程中我们又能从中看出自己的不足，且又能锻炼自己的写作能力。当然了，在分享的同时别人也能指出自己的错误，还能认识一波志同道合的好朋友。</p><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhrtaokevj30j60csmxc.jpg" alt=""></div></p><p>&emsp;&emsp;时光是个稍纵即逝的东西，时光匆匆白驹过隙，总得留下些东西，或文字或照片或吐槽，不至于让回忆空白！最后也欢迎大家关注我的公众号——十三的记事本。<br><br><br><br></p><hr><p><div align="center"><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fzhqzgq9tuj303l03lglm.jpg" alt="扫一扫点击关注"><br>十三的记事本<br>欢迎大家关注我的公众号</div></p>]]></content>
      
      <categories>
          
          <category> Hello World </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello World </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
